(() => {
  var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);

  // src/pdf-editor/pdf-editor.css
  var require_ = __commonJS((exports, module) => {
    module.exports = {};
  });

  // dependencies/flexboxgrid/flexboxgrid.min.css
  var require_2 = __commonJS((exports, module) => {
    module.exports = {};
  });

  // package.json
  var require_package = __commonJS((exports, module) => {
    module.exports = {
      name: "pdf-builder-2020",
      version: "0.0.32",
      description: "",
      main: "index.js",
      scripts: {
        build: "node build.js"
      },
      devDependencies: {
        esbuild: "^0.11.12"
      },
      author: "",
      license: "ISC",
      dependencies: {
        "@ckeditor/ckeditor5-media-embed": "^20.0.0",
        "d3-selection": "^1.4.0",
        dragula: "^3.7.2"
      }
    };
  });

  // node_modules/dragula/dist/dragula.min.css
  var require_3 = __commonJS((exports, module) => {
    module.exports = {};
  });

  // node_modules/atoa/atoa.js
  var require_atoa = __commonJS((exports, module) => {
    module.exports = function atoa(a, n) {
      return Array.prototype.slice.call(a, n);
    };
  });

  // node_modules/ticky/ticky-browser.js
  var require_ticky_browser = __commonJS((exports, module) => {
    var si = typeof setImmediate === "function";
    var tick;
    if (si) {
      tick = function(fn) {
        setImmediate(fn);
      };
    } else {
      tick = function(fn) {
        setTimeout(fn, 0);
      };
    }
    module.exports = tick;
  });

  // node_modules/contra/debounce.js
  var require_debounce = __commonJS((exports, module) => {
    "use strict";
    var ticky = require_ticky_browser();
    module.exports = function debounce(fn, args, ctx) {
      if (!fn) {
        return;
      }
      ticky(function run() {
        fn.apply(ctx || null, args || []);
      });
    };
  });

  // node_modules/contra/emitter.js
  var require_emitter = __commonJS((exports, module) => {
    "use strict";
    var atoa = require_atoa();
    var debounce = require_debounce();
    module.exports = function emitter(thing, options) {
      var opts = options || {};
      var evt = {};
      if (thing === void 0) {
        thing = {};
      }
      thing.on = function(type, fn) {
        if (!evt[type]) {
          evt[type] = [fn];
        } else {
          evt[type].push(fn);
        }
        return thing;
      };
      thing.once = function(type, fn) {
        fn._once = true;
        thing.on(type, fn);
        return thing;
      };
      thing.off = function(type, fn) {
        var c = arguments.length;
        if (c === 1) {
          delete evt[type];
        } else if (c === 0) {
          evt = {};
        } else {
          var et = evt[type];
          if (!et) {
            return thing;
          }
          et.splice(et.indexOf(fn), 1);
        }
        return thing;
      };
      thing.emit = function() {
        var args = atoa(arguments);
        return thing.emitterSnapshot(args.shift()).apply(this, args);
      };
      thing.emitterSnapshot = function(type) {
        var et = (evt[type] || []).slice(0);
        return function() {
          var args = atoa(arguments);
          var ctx = this || thing;
          if (type === "error" && opts.throws !== false && !et.length) {
            throw args.length === 1 ? args[0] : args;
          }
          et.forEach(function emitter2(listen) {
            if (opts.async) {
              debounce(listen, args, ctx);
            } else {
              listen.apply(ctx, args);
            }
            if (listen._once) {
              thing.off(type, listen);
            }
          });
          return thing;
        };
      };
      return thing;
    };
  });

  // node_modules/custom-event/index.js
  var require_custom_event = __commonJS((exports, module) => {
    var NativeCustomEvent = window.CustomEvent;
    function useNative() {
      try {
        var p = new NativeCustomEvent("cat", {detail: {foo: "bar"}});
        return p.type === "cat" && p.detail.foo === "bar";
      } catch (e) {
      }
      return false;
    }
    module.exports = useNative() ? NativeCustomEvent : typeof document !== "undefined" && typeof document.createEvent === "function" ? function CustomEvent(type, params) {
      var e = document.createEvent("CustomEvent");
      if (params) {
        e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
      } else {
        e.initCustomEvent(type, false, false, void 0);
      }
      return e;
    } : function CustomEvent(type, params) {
      var e = document.createEventObject();
      e.type = type;
      if (params) {
        e.bubbles = Boolean(params.bubbles);
        e.cancelable = Boolean(params.cancelable);
        e.detail = params.detail;
      } else {
        e.bubbles = false;
        e.cancelable = false;
        e.detail = void 0;
      }
      return e;
    };
  });

  // node_modules/crossvent/src/eventmap.js
  var require_eventmap = __commonJS((exports, module) => {
    "use strict";
    var eventmap = [];
    var eventname = "";
    var ron = /^on/;
    for (eventname in window) {
      if (ron.test(eventname)) {
        eventmap.push(eventname.slice(2));
      }
    }
    module.exports = eventmap;
  });

  // node_modules/crossvent/src/crossvent.js
  var require_crossvent = __commonJS((exports, module) => {
    "use strict";
    var customEvent = require_custom_event();
    var eventmap = require_eventmap();
    var doc = window.document;
    var addEvent = addEventEasy;
    var removeEvent = removeEventEasy;
    var hardCache = [];
    if (!window.addEventListener) {
      addEvent = addEventHard;
      removeEvent = removeEventHard;
    }
    module.exports = {
      add: addEvent,
      remove: removeEvent,
      fabricate: fabricateEvent
    };
    function addEventEasy(el, type, fn, capturing) {
      return el.addEventListener(type, fn, capturing);
    }
    function addEventHard(el, type, fn) {
      return el.attachEvent("on" + type, wrap(el, type, fn));
    }
    function removeEventEasy(el, type, fn, capturing) {
      return el.removeEventListener(type, fn, capturing);
    }
    function removeEventHard(el, type, fn) {
      var listener = unwrap(el, type, fn);
      if (listener) {
        return el.detachEvent("on" + type, listener);
      }
    }
    function fabricateEvent(el, type, model) {
      var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();
      if (el.dispatchEvent) {
        el.dispatchEvent(e);
      } else {
        el.fireEvent("on" + type, e);
      }
      function makeClassicEvent() {
        var e2;
        if (doc.createEvent) {
          e2 = doc.createEvent("Event");
          e2.initEvent(type, true, true);
        } else if (doc.createEventObject) {
          e2 = doc.createEventObject();
        }
        return e2;
      }
      function makeCustomEvent() {
        return new customEvent(type, {detail: model});
      }
    }
    function wrapperFactory(el, type, fn) {
      return function wrapper(originalEvent) {
        var e = originalEvent || window.event;
        e.target = e.target || e.srcElement;
        e.preventDefault = e.preventDefault || function preventDefault() {
          e.returnValue = false;
        };
        e.stopPropagation = e.stopPropagation || function stopPropagation() {
          e.cancelBubble = true;
        };
        e.which = e.which || e.keyCode;
        fn.call(el, e);
      };
    }
    function wrap(el, type, fn) {
      var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);
      hardCache.push({
        wrapper,
        element: el,
        type,
        fn
      });
      return wrapper;
    }
    function unwrap(el, type, fn) {
      var i = find(el, type, fn);
      if (i) {
        var wrapper = hardCache[i].wrapper;
        hardCache.splice(i, 1);
        return wrapper;
      }
    }
    function find(el, type, fn) {
      var i, item;
      for (i = 0; i < hardCache.length; i++) {
        item = hardCache[i];
        if (item.element === el && item.type === type && item.fn === fn) {
          return i;
        }
      }
    }
  });

  // node_modules/dragula/classes.js
  var require_classes = __commonJS((exports, module) => {
    "use strict";
    var cache = {};
    var start = "(?:^|\\s)";
    var end = "(?:\\s|$)";
    function lookupClass(className) {
      var cached = cache[className];
      if (cached) {
        cached.lastIndex = 0;
      } else {
        cache[className] = cached = new RegExp(start + className + end, "g");
      }
      return cached;
    }
    function addClass(el, className) {
      var current = el.className;
      if (!current.length) {
        el.className = className;
      } else if (!lookupClass(className).test(current)) {
        el.className += " " + className;
      }
    }
    function rmClass(el, className) {
      el.className = el.className.replace(lookupClass(className), " ").trim();
    }
    module.exports = {
      add: addClass,
      rm: rmClass
    };
  });

  // node_modules/dragula/dragula.js
  var require_dragula = __commonJS((exports, module) => {
    "use strict";
    var emitter = require_emitter();
    var crossvent = require_crossvent();
    var classes = require_classes();
    var doc = document;
    var documentElement = doc.documentElement;
    function dragula(initialContainers, options) {
      var len = arguments.length;
      if (len === 1 && Array.isArray(initialContainers) === false) {
        options = initialContainers;
        initialContainers = [];
      }
      var _mirror;
      var _source;
      var _item;
      var _offsetX;
      var _offsetY;
      var _moveX;
      var _moveY;
      var _initialSibling;
      var _currentSibling;
      var _copy;
      var _renderTimer;
      var _lastDropTarget = null;
      var _grabbed;
      var o = options || {};
      if (o.moves === void 0) {
        o.moves = always;
      }
      if (o.accepts === void 0) {
        o.accepts = always;
      }
      if (o.invalid === void 0) {
        o.invalid = invalidTarget;
      }
      if (o.containers === void 0) {
        o.containers = initialContainers || [];
      }
      if (o.isContainer === void 0) {
        o.isContainer = never;
      }
      if (o.copy === void 0) {
        o.copy = false;
      }
      if (o.copySortSource === void 0) {
        o.copySortSource = false;
      }
      if (o.revertOnSpill === void 0) {
        o.revertOnSpill = false;
      }
      if (o.removeOnSpill === void 0) {
        o.removeOnSpill = false;
      }
      if (o.direction === void 0) {
        o.direction = "vertical";
      }
      if (o.ignoreInputTextSelection === void 0) {
        o.ignoreInputTextSelection = true;
      }
      if (o.mirrorContainer === void 0) {
        o.mirrorContainer = doc.body;
      }
      var drake = emitter({
        containers: o.containers,
        start: manualStart,
        end,
        cancel,
        remove,
        destroy,
        canMove,
        dragging: false
      });
      if (o.removeOnSpill === true) {
        drake.on("over", spillOver).on("out", spillOut);
      }
      events();
      return drake;
      function isContainer(el) {
        return drake.containers.indexOf(el) !== -1 || o.isContainer(el);
      }
      function events(remove2) {
        var op = remove2 ? "remove" : "add";
        touchy(documentElement, op, "mousedown", grab);
        touchy(documentElement, op, "mouseup", release);
      }
      function eventualMovements(remove2) {
        var op = remove2 ? "remove" : "add";
        touchy(documentElement, op, "mousemove", startBecauseMouseMoved);
      }
      function movements(remove2) {
        var op = remove2 ? "remove" : "add";
        crossvent[op](documentElement, "selectstart", preventGrabbed);
        crossvent[op](documentElement, "click", preventGrabbed);
      }
      function destroy() {
        events(true);
        release({});
      }
      function preventGrabbed(e) {
        if (_grabbed) {
          e.preventDefault();
        }
      }
      function grab(e) {
        _moveX = e.clientX;
        _moveY = e.clientY;
        var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;
        if (ignore) {
          return;
        }
        var item = e.target;
        var context = canStart(item);
        if (!context) {
          return;
        }
        _grabbed = context;
        eventualMovements();
        if (e.type === "mousedown") {
          if (isInput(item)) {
            item.focus();
          } else {
            e.preventDefault();
          }
        }
      }
      function startBecauseMouseMoved(e) {
        if (!_grabbed) {
          return;
        }
        if (whichMouseButton(e) === 0) {
          release({});
          return;
        }
        if (e.clientX !== void 0 && Math.abs(e.clientX - _moveX) <= (o.slideFactorX || 0) && (e.clientY !== void 0 && Math.abs(e.clientY - _moveY) <= (o.slideFactorY || 0))) {
          return;
        }
        if (o.ignoreInputTextSelection) {
          var clientX = getCoord("clientX", e) || 0;
          var clientY = getCoord("clientY", e) || 0;
          var elementBehindCursor = doc.elementFromPoint(clientX, clientY);
          if (isInput(elementBehindCursor)) {
            return;
          }
        }
        var grabbed = _grabbed;
        eventualMovements(true);
        movements();
        end();
        start(grabbed);
        var offset = getOffset(_item);
        _offsetX = getCoord("pageX", e) - offset.left;
        _offsetY = getCoord("pageY", e) - offset.top;
        classes.add(_copy || _item, "gu-transit");
        renderMirrorImage();
        drag(e);
      }
      function canStart(item) {
        if (drake.dragging && _mirror) {
          return;
        }
        if (isContainer(item)) {
          return;
        }
        var handle = item;
        while (getParent(item) && isContainer(getParent(item)) === false) {
          if (o.invalid(item, handle)) {
            return;
          }
          item = getParent(item);
          if (!item) {
            return;
          }
        }
        var source = getParent(item);
        if (!source) {
          return;
        }
        if (o.invalid(item, handle)) {
          return;
        }
        var movable = o.moves(item, source, handle, nextEl(item));
        if (!movable) {
          return;
        }
        return {
          item,
          source
        };
      }
      function canMove(item) {
        return !!canStart(item);
      }
      function manualStart(item) {
        var context = canStart(item);
        if (context) {
          start(context);
        }
      }
      function start(context) {
        if (isCopy(context.item, context.source)) {
          _copy = context.item.cloneNode(true);
          drake.emit("cloned", _copy, context.item, "copy");
        }
        _source = context.source;
        _item = context.item;
        _initialSibling = _currentSibling = nextEl(context.item);
        drake.dragging = true;
        drake.emit("drag", _item, _source);
      }
      function invalidTarget() {
        return false;
      }
      function end() {
        if (!drake.dragging) {
          return;
        }
        var item = _copy || _item;
        drop(item, getParent(item));
      }
      function ungrab() {
        _grabbed = false;
        eventualMovements(true);
        movements(true);
      }
      function release(e) {
        ungrab();
        if (!drake.dragging) {
          return;
        }
        var item = _copy || _item;
        var clientX = getCoord("clientX", e) || 0;
        var clientY = getCoord("clientY", e) || 0;
        var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
        var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
        if (dropTarget && (_copy && o.copySortSource || (!_copy || dropTarget !== _source))) {
          drop(item, dropTarget);
        } else if (o.removeOnSpill) {
          remove();
        } else {
          cancel();
        }
      }
      function drop(item, target) {
        var parent = getParent(item);
        if (_copy && o.copySortSource && target === _source) {
          parent.removeChild(_item);
        }
        if (isInitialPlacement(target)) {
          drake.emit("cancel", item, _source, _source);
        } else {
          drake.emit("drop", item, target, _source, _currentSibling);
        }
        cleanup();
      }
      function remove() {
        if (!drake.dragging) {
          return;
        }
        var item = _copy || _item;
        var parent = getParent(item);
        if (parent) {
          parent.removeChild(item);
        }
        drake.emit(_copy ? "cancel" : "remove", item, parent, _source);
        cleanup();
      }
      function cancel(revert) {
        if (!drake.dragging) {
          return;
        }
        var reverts = arguments.length > 0 ? revert : o.revertOnSpill;
        var item = _copy || _item;
        var parent = getParent(item);
        var initial = isInitialPlacement(parent);
        if (initial === false && reverts) {
          if (_copy) {
            if (parent) {
              parent.removeChild(_copy);
            }
          } else {
            _source.insertBefore(item, _initialSibling);
          }
        }
        if (initial || reverts) {
          drake.emit("cancel", item, _source, _source);
        } else {
          drake.emit("drop", item, parent, _source, _currentSibling);
        }
        cleanup();
      }
      function cleanup() {
        var item = _copy || _item;
        ungrab();
        removeMirrorImage();
        if (item) {
          classes.rm(item, "gu-transit");
        }
        if (_renderTimer) {
          clearTimeout(_renderTimer);
        }
        drake.dragging = false;
        if (_lastDropTarget) {
          drake.emit("out", item, _lastDropTarget, _source);
        }
        drake.emit("dragend", item);
        _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;
      }
      function isInitialPlacement(target, s) {
        var sibling;
        if (s !== void 0) {
          sibling = s;
        } else if (_mirror) {
          sibling = _currentSibling;
        } else {
          sibling = nextEl(_copy || _item);
        }
        return target === _source && sibling === _initialSibling;
      }
      function findDropTarget(elementBehindCursor, clientX, clientY) {
        var target = elementBehindCursor;
        while (target && !accepted()) {
          target = getParent(target);
        }
        return target;
        function accepted() {
          var droppable = isContainer(target);
          if (droppable === false) {
            return false;
          }
          var immediate = getImmediateChild(target, elementBehindCursor);
          var reference = getReference(target, immediate, clientX, clientY);
          var initial = isInitialPlacement(target, reference);
          if (initial) {
            return true;
          }
          return o.accepts(_item, target, _source, reference);
        }
      }
      function drag(e) {
        if (!_mirror) {
          return;
        }
        e.preventDefault();
        var clientX = getCoord("clientX", e) || 0;
        var clientY = getCoord("clientY", e) || 0;
        var x = clientX - _offsetX;
        var y = clientY - _offsetY;
        _mirror.style.left = x + "px";
        _mirror.style.top = y + "px";
        var item = _copy || _item;
        var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
        var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
        var changed = dropTarget !== null && dropTarget !== _lastDropTarget;
        if (changed || dropTarget === null) {
          out();
          _lastDropTarget = dropTarget;
          over();
        }
        var parent = getParent(item);
        if (dropTarget === _source && _copy && !o.copySortSource) {
          if (parent) {
            parent.removeChild(item);
          }
          return;
        }
        var reference;
        var immediate = getImmediateChild(dropTarget, elementBehindCursor);
        if (immediate !== null) {
          reference = getReference(dropTarget, immediate, clientX, clientY);
        } else if (o.revertOnSpill === true && !_copy) {
          reference = _initialSibling;
          dropTarget = _source;
        } else {
          if (_copy && parent) {
            parent.removeChild(item);
          }
          return;
        }
        if (reference === null && changed || reference !== item && reference !== nextEl(item)) {
          _currentSibling = reference;
          dropTarget.insertBefore(item, reference);
          drake.emit("shadow", item, dropTarget, _source);
        }
        function moved(type) {
          drake.emit(type, item, _lastDropTarget, _source);
        }
        function over() {
          if (changed) {
            moved("over");
          }
        }
        function out() {
          if (_lastDropTarget) {
            moved("out");
          }
        }
      }
      function spillOver(el) {
        classes.rm(el, "gu-hide");
      }
      function spillOut(el) {
        if (drake.dragging) {
          classes.add(el, "gu-hide");
        }
      }
      function renderMirrorImage() {
        if (_mirror) {
          return;
        }
        var rect = _item.getBoundingClientRect();
        _mirror = _item.cloneNode(true);
        _mirror.style.width = getRectWidth(rect) + "px";
        _mirror.style.height = getRectHeight(rect) + "px";
        classes.rm(_mirror, "gu-transit");
        classes.add(_mirror, "gu-mirror");
        o.mirrorContainer.appendChild(_mirror);
        touchy(documentElement, "add", "mousemove", drag);
        classes.add(o.mirrorContainer, "gu-unselectable");
        drake.emit("cloned", _mirror, _item, "mirror");
      }
      function removeMirrorImage() {
        if (_mirror) {
          classes.rm(o.mirrorContainer, "gu-unselectable");
          touchy(documentElement, "remove", "mousemove", drag);
          getParent(_mirror).removeChild(_mirror);
          _mirror = null;
        }
      }
      function getImmediateChild(dropTarget, target) {
        var immediate = target;
        while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {
          immediate = getParent(immediate);
        }
        if (immediate === documentElement) {
          return null;
        }
        return immediate;
      }
      function getReference(dropTarget, target, x, y) {
        var horizontal = o.direction === "horizontal";
        var reference = target !== dropTarget ? inside() : outside();
        return reference;
        function outside() {
          var len2 = dropTarget.children.length;
          var i;
          var el;
          var rect;
          for (i = 0; i < len2; i++) {
            el = dropTarget.children[i];
            rect = el.getBoundingClientRect();
            if (horizontal && rect.left + rect.width / 2 > x) {
              return el;
            }
            if (!horizontal && rect.top + rect.height / 2 > y) {
              return el;
            }
          }
          return null;
        }
        function inside() {
          var rect = target.getBoundingClientRect();
          if (horizontal) {
            return resolve(x > rect.left + getRectWidth(rect) / 2);
          }
          return resolve(y > rect.top + getRectHeight(rect) / 2);
        }
        function resolve(after) {
          return after ? nextEl(target) : target;
        }
      }
      function isCopy(item, container) {
        return typeof o.copy === "boolean" ? o.copy : o.copy(item, container);
      }
    }
    function touchy(el, op, type, fn) {
      var touch = {
        mouseup: "touchend",
        mousedown: "touchstart",
        mousemove: "touchmove"
      };
      var pointers = {
        mouseup: "pointerup",
        mousedown: "pointerdown",
        mousemove: "pointermove"
      };
      var microsoft = {
        mouseup: "MSPointerUp",
        mousedown: "MSPointerDown",
        mousemove: "MSPointerMove"
      };
      if (window.navigator.pointerEnabled) {
        crossvent[op](el, pointers[type], fn);
      } else if (window.navigator.msPointerEnabled) {
        crossvent[op](el, microsoft[type], fn);
      } else {
        crossvent[op](el, touch[type], fn);
        crossvent[op](el, type, fn);
      }
    }
    function whichMouseButton(e) {
      if (e.touches !== void 0) {
        return e.touches.length;
      }
      if (e.which !== void 0 && e.which !== 0) {
        return e.which;
      }
      if (e.buttons !== void 0) {
        return e.buttons;
      }
      var button = e.button;
      if (button !== void 0) {
        return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
      }
    }
    function getOffset(el) {
      var rect = el.getBoundingClientRect();
      return {
        left: rect.left + getScroll("scrollLeft", "pageXOffset"),
        top: rect.top + getScroll("scrollTop", "pageYOffset")
      };
    }
    function getScroll(scrollProp, offsetProp) {
      if (typeof window[offsetProp] !== "undefined") {
        return window[offsetProp];
      }
      if (documentElement.clientHeight) {
        return documentElement[scrollProp];
      }
      return doc.body[scrollProp];
    }
    function getElementBehindPoint(point, x, y) {
      point = point || {};
      var state = point.className || "";
      var el;
      point.className += " gu-hide";
      el = doc.elementFromPoint(x, y);
      point.className = state;
      return el;
    }
    function never() {
      return false;
    }
    function always() {
      return true;
    }
    function getRectWidth(rect) {
      return rect.width || rect.right - rect.left;
    }
    function getRectHeight(rect) {
      return rect.height || rect.bottom - rect.top;
    }
    function getParent(el) {
      return el.parentNode === doc ? null : el.parentNode;
    }
    function isInput(el) {
      return el.tagName === "INPUT" || el.tagName === "TEXTAREA" || el.tagName === "SELECT" || isEditable(el);
    }
    function isEditable(el) {
      if (!el) {
        return false;
      }
      if (el.contentEditable === "false") {
        return false;
      }
      if (el.contentEditable === "true") {
        return true;
      }
      return isEditable(getParent(el));
    }
    function nextEl(el) {
      return el.nextElementSibling || manually();
      function manually() {
        var sibling = el;
        do {
          sibling = sibling.nextSibling;
        } while (sibling && sibling.nodeType !== 1);
        return sibling;
      }
    }
    function getEventHost(e) {
      if (e.targetTouches && e.targetTouches.length) {
        return e.targetTouches[0];
      }
      if (e.changedTouches && e.changedTouches.length) {
        return e.changedTouches[0];
      }
      return e;
    }
    function getCoord(coord, e) {
      var host = getEventHost(e);
      var missMap = {
        pageX: "clientX",
        pageY: "clientY"
      };
      if (coord in missMap && !(coord in host) && missMap[coord] in host) {
        coord = missMap[coord];
      }
      return host[coord];
    }
    module.exports = dragula;
  });

  // src/pdf-editor/documentCleaner.js
  var require_documentCleaner = __commonJS((exports, module) => {
    module.exports = {
      clean: function(pageContent) {
        let tmp = document.createElement("div");
        tmp.innerHTML = pageContent;
        removeElements(tmp);
        cleanClasses(tmp);
        cleanAttributes(tmp);
        removeEmptyClassAttr(tmp);
        removeImageWidgetText(tmp);
        return tmp;
      },
      removeImageWidgetText
    };
    function removeEmptyClassAttr(tmp) {
      tmp.querySelectorAll(`[class=""]`).forEach((el) => el.removeAttribute("class"));
    }
    function removeElements(tmp) {
      tmp.querySelectorAll([
        "style",
        ".ck-widget__selection-handle",
        ".ck-widget__resizer",
        ".dz-buttons",
        ".template-buttons",
        ".empty-drop-zone:first-child",
        ".empty-drop-zone:last-child"
      ].join(", ")).forEach((el) => el.remove());
    }
    function cleanClasses(tmp) {
      [
        "initialized",
        "ck-blurred",
        "ck-editor__editable",
        "ck-rounded-corners",
        "ck-editor__editable_inline",
        "ck-editor__nested-editable",
        "ck-widget",
        "ck-widget_with-resizer",
        "ck-widget_selected",
        "ck-widget_with-selection-handle",
        "add_editor_here",
        "ckeditor-uploading",
        "ckeditor-uploading-complete",
        "ckeditor-uploading-error"
      ].forEach((c) => tmp.querySelectorAll("." + c).forEach((el) => el.classList.remove(c)));
    }
    function cleanAttributes(tmp) {
      [
        "aria-label",
        "contenteditable",
        "role",
        "lang",
        "dir",
        "data-cke-filler"
      ].forEach((attr) => tmp.querySelectorAll(`[${attr}]`).forEach((el) => el.removeAttribute(attr)));
    }
    function removeImageWidgetText(tmp) {
      tmp.querySelectorAll("p, div").forEach((el) => el.innerHTML === "\u0412\u0438\u0434\u0436\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439" && el.remove());
      tmp.querySelectorAll("p, div").forEach((el) => el.innerHTML === "\u0413\u043E\u0440\u0438\u0437\u043E\u043D\u0442\u0430\u043B\u044C\u043D\u0430\u044F \u043B\u0438\u043D\u0438\u044F" && el.remove());
    }
  });

  // src/pdf-editor/blocks.js
  var require_blocks = __commonJS((exports, module) => {
    var documentCleaner2 = require_documentCleaner();
    module.exports = {
      pdfEditor: null,
      newBlockNameText: "\u041D\u043E\u0432\u044B\u0439 \u0431\u043B\u043E\u043A ",
      propertyKeys: {
        block_name: "block_name",
        block_descr: "block_descr",
        block_no_edit: "block_no_edit",
        block_no_move: "block_no_move",
        block_no_copy: "block_no_copy"
      },
      initBlocks(pdfEditor) {
        this.pdfEditor = pdfEditor;
        this.initBlockEditors();
      },
      handleClick(el) {
        let pdfEditor = this.pdfEditor;
        if (!pdfEditor.properties.propertiesPage)
          return;
        let attachButton = pdfEditor.targetElement.querySelector("#block_attach_button");
        attachButton && (attachButton.disabled = true);
        if (!el)
          return;
        let keys = this.propertyKeys;
        [keys.block_name, keys.block_descr].forEach((key) => {
          if (pdfEditor.properties.blockProperties[key])
            pdfEditor.targetElement.querySelector("#" + key).value = el.getAttribute(key);
        });
        [keys.block_no_edit, keys.block_no_move, keys.block_no_copy].forEach((key) => {
          if (pdfEditor.properties.blockProperties[key])
            pdfEditor.targetElement.querySelector("#" + key).checked = el.getAttribute(key) !== "true";
        });
        attachButton && (attachButton.disabled = false);
      },
      copyBlock(e) {
        e.stopPropagation();
        let tpl = e.target.closest(".template");
        let cloned = tpl.cloneNode(true);
        tpl.parentElement.insertBefore(cloned, tpl);
        tpl.parentElement.insertBefore(tpl, cloned);
        cloned.id = "";
        let name = this.propertyKeys.block_name;
        cloned.setAttribute(name, cloned.getAttribute(name) + " \u043A\u043E\u043F\u0438\u044F");
        this.initTemplate(cloned, ".dropzone");
        cloned.querySelectorAll("div.add_editor_here").forEach((el) => {
          el.classList.remove("initialized");
          this.pdfEditor.initEditor(el);
        });
        documentCleaner2.removeImageWidgetText(cloned);
      },
      initTemplate(el, dropZoneSelector) {
        if (el.querySelector(".dropzone")) {
          if (!el.id)
            el.id = "block_" + this.rnd() + this.rnd();
          let name = this.propertyKeys.block_name;
          if (!el.getAttribute(name))
            el.setAttribute(name, this.findNextNumber());
          el.addEventListener("click", () => this.pdfEditor.clickOnBlock(el));
          el.querySelectorAll(dropZoneSelector).forEach((dz) => this.pdfEditor.initDz(dz));
        } else {
          el.onclick = () => {
            this.pdfEditor.initEditor(el.querySelector("div.add_editor_here"));
            el.onclick = () => {
            };
          };
        }
      },
      rnd() {
        return Math.random().toString(36).substring(2);
      },
      findNextNumber() {
        let numbers = [...this.pdfEditor.targetElement.querySelectorAll(".page > .template")].map((el) => {
          let name = el.getAttribute(this.propertyKeys.block_name);
          return name && parseInt(name.split(this.newBlockNameText).pop());
        }).filter((n) => n);
        let i = 1;
        for (; i < 1e5; i++)
          if (numbers.indexOf(i) === -1)
            break;
        return this.newBlockNameText + i;
      },
      initBlockEditors() {
        let pdfEditor = this.pdfEditor;
        if (!pdfEditor.properties.propertiesPage)
          return;
        Object.values(this.propertyKeys).forEach(function(id) {
          if (pdfEditor.properties.blockProperties[id])
            pdfEditor.targetElement.querySelector("#" + id).oninput = onInput;
        });
        function onInput() {
          if (!pdfEditor.selectedBlock || !pdfEditor.properties.blockProperties[this.id])
            return;
          pdfEditor.selectedBlock.setAttribute(this.id, this.type === "checkbox" ? !this.checked : this.value);
          if (this.id !== "block_no_edit")
            return;
          pdfEditor.selectedBlock.querySelectorAll(".add_editor_here").forEach((el) => {
            if (this.checked)
              el.setAttribute("contenteditable", true);
            else
              el.removeAttribute("contenteditable");
          });
        }
      }
    };
  });

  // src/pdf-editor/dnd.js
  var require_dnd = __commonJS((exports, module) => {
    require_3();
    var dragula = require_dragula();
    var blocks2 = require_blocks();
    var drake;
    var pdfEditor;
    module.exports = {
      initDnD(pdfEditorInstance) {
        pdfEditor = pdfEditorInstance;
        drake = dragula([
          pdfEditor.targetElement.querySelector("#blocks"),
          pdfEditor.targetElement.querySelector("#elements"),
          pdfEditor.targetElement.querySelector(".page")
        ], {
          removeOnSpill: true,
          copy: function(el, source) {
            return source.classList.contains("templates");
          },
          accepts: (el, target) => dropAccepts(el, target),
          moves: function(el, container, handle) {
            return handle.classList.contains("handle") || container.classList.contains("templates");
          }
        });
        drake.on("drag", (e) => dragStart(e));
        drake.on("drop", (el, target) => handleDrop(el, target));
      },
      pushElement(element) {
        drake.containers.push(element);
      },
      removeElement(element) {
        drake.containers.splice(drake.containers.indexOf(element), 1);
      }
    };
    function dragStart(e) {
    }
    function dropAccepts(el, target) {
      let t = target.classList;
      if (t.contains("templates"))
        return false;
      if (el.querySelector(".dropzone") || el.querySelector(".page-break")) {
        return t.contains("page");
      } else {
        let canEdit = t.contains("dropzone") && target.parentNode.getAttribute("block_no_edit") !== "true";
        canEdit && pdfEditor.manageHoverState(target.parentNode, true);
        return canEdit;
      }
    }
    function handleDrop(el, target) {
      if (!target.classList.contains("page")) {
        setTimeout(() => {
          pdfEditor.clearNotNeededRows(target);
          pdfEditor.manageExtraRows(target);
          pdfEditor.markEmptyRows(target);
        }, 10);
      }
      pdfEditor.clickOnBlock(pdfEditor.selectedBlock);
      blocks2.initTemplate(el, ".origin");
    }
  });

  // src/pdf-editor/tabs.js
  var require_tabs = __commonJS((exports, module) => {
    module.exports = {
      styles: function() {
        return `
            <style>
                .pdf-editor-tab {
                    color: #ccc8;
                    display: table-cell;
                    max-width: 100px;
                    padding: 5px;
                    cursor: pointer;
                    font-size: 16px;
                    font-family: -apple-system, BlinkMacSystemFont, Roboto, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
                    font-weight: 500;
                     transition: 0.14s  cubic-bezier(.12, .32, .54, 1);
                }
                .pdf-editor-tab:hover {
                    color: #cccc;
                }
                
                 .pdf-editor-tab:after {
                    content: "";
                    position: relative;
                    display: block;
                    bottom: 0;
                    left: 50%;
                    width: 26px;
                    height: 2px;
                    
                    background-color:rgb(255, 83, 0);;
                    border-radius: 5px 5px 0 0;
                    transform: translate(-50%,6px) scale(0);
                    transform-origin: 50% 100%;
                    transition: 0.14s transform cubic-bezier(.12, .32, .54, 1);
                    will-change: transform;
                }
                
                .pdf-editor-tab-content {
                    display: none;
                 }
                 #structure:checked + .pdf-editor-tab, 
                 #properties:checked + .pdf-editor-tab {
                    cursor: default;
                    color: #cccf;
                 }
                
                 #structure:checked + .pdf-editor-tab:after,
             
                 #properties:checked + .pdf-editor-tab:after{
                    transform: translate(-50%,6px) scale(1);
                 }
                 #structure:checked ~ .structure,
                 #properties:checked ~ .properties {
                    display: inline-block !important;
                 }
            </style>
        `;
      },
      createTeb: function(name, title, checked) {
        return `
            <input id="${name}" 
                    type="radio" 
                    name="pdf-editor-tabs" 
                    style="display: none" ${checked ? 'checked="true"' : ""} >
            <label class="pdf-editor-tab" for="${name}">${title}</label>
        `;
      }
    };
  });

  // src/pdf-editor/Icons.js
  var require_Icons = __commonJS((exports, module) => {
    var fill = "#432c12";
    var move = `
    <path fill="${fill}" d="M352.201 425.775l-79.196 79.196c-9.373 9.373-24.568 9.373-33.941 
        0l-79.196-79.196c-15.119-15.119-4.411-40.971 16.971-40.97h51.162L228 284H127.196v51.162c0 
        21.382-25.851 32.09-40.971 16.971L7.029 272.937c-9.373-9.373-9.373-24.569 0-33.941L86.225 
        159.8c15.119-15.119 40.971-4.411 40.971 16.971V228H228V127.196h-51.23c-21.382 
        0-32.09-25.851-16.971-40.971l79.196-79.196c9.373-9.373 24.568-9.373 33.941 0l79.196 79.196c15.119 
        15.119 4.411 40.971-16.971 40.971h-51.162V228h100.804v-51.162c0-21.382 25.851-32.09 
        40.97-16.971l79.196 79.196c9.373 9.373 9.373 24.569 0 33.941L425.773 352.2c-15.119 15.119-40.971 
        4.411-40.97-16.971V284H284v100.804h51.23c21.382 0 32.09 25.851 16.971 40.971z"/>
`;
    var copy = `
    <path fill="${fill}" d="M320 448v40c0 13.255-10.745 24-24 24H24c-13.255 
        0-24-10.745-24-24V120c0-13.255 10.745-24 24-24h72v296c0 
        30.879 25.121 56 56 56h168zm0-344V0H152c-13.255 0-24 10.745-24 24v368c0 
        13.255 10.745 24 24 24h272c13.255 0 24-10.745 24-24V128H344c-13.2 
        0-24-10.8-24-24zm120.971-31.029L375.029 7.029A24 24 0 0 0 358.059 
        0H352v96h96v-6.059a24 24 0 0 0-7.029-16.97z"/>
`;
    var del = `
    <path stroke="${fill}" d="M20,20 l60,60" stroke-width="10"/>
    <path stroke="${fill}" d="M80,20 l-60,60" stroke-width="10" />
`;
    var down = `
    <path fill="${fill}" d="M20,30 l30,40 l30,-40 z"/>
`;
    var up = `
    <path fill="${fill}" d="M20,70 l30,-40 l30,40 z"/>
`;
    module.exports = {
      move: (w, h) => svg(w, h, move, [-100, -100, 712, 712]),
      copy: (w, h) => svg(w, h, copy, [-100, -100, 648, 712]),
      del: (w, h) => svg(w, h, del, [0, 0, 100, 100]),
      up: (w, h) => svg(w, h, up, [0, 0, 100, 100]),
      down: (w, h) => svg(w, h, down, [0, 0, 100, 100])
    };
    function svg(w, h, html, vb) {
      return `<svg xmlns="http://www.w3.org/2000/svg" 
                viewBox="${vb}" 
                width="${w}px"  
                height="${h}px">
            ${html}
        </svg>`;
    }
  });

  // src/pdf-editor/mouseoverButtons.js
  var require_mouseoverButtons = __commonJS((exports, module) => {
    var Icons = require_Icons();
    var blocks2 = require_blocks();
    module.exports = {
      manage: function(e, pdfEditor) {
        if (e.target.classList.contains("handle"))
          return;
        elementButtons(e, pdfEditor, blockButtons(e, pdfEditor));
      },
      styles: (props) => `
        <style>
            .pdf-editor .page .template:hover  .dz-buttons,
            .pdf-editor .page .template:hover  .template-buttons {
                opacity: 1;
            }
           .dz-buttons, .template-buttons {
                z-index: 111;
            } 
            .dz-buttons > div {
                transform: translate(${60 + props.buttonsSize}px,0);
                width: 50px;
                user-select: none;
                text-align: right;
                height: 145px;
            }
            .dz-buttons svg, .template-buttons svg{
                pointer-events: none;
            }
            div.dz-buttons {
                margin-left: 700px;
            }
            .dz-buttons, .template-buttons {
                opacity: 0;
                position: relative;
                overflow: visible;
                width: 0px;
                height: 0px;
                line-height:0;
            }
            .template-buttons {
                transform: translate(${-10 - props.buttonsSize}px, 0);
            }
            .template-buttons > div {
                width: 40px;
                height: 60px;
            }
        </style>
    `
    };
    function blockButtons(e, pdfEditor) {
      let size = pdfEditor.properties.buttonsSize;
      let closestDz = e.target.closest(".page .template:not(.col-xs)");
      closestDz = closestDz || e.target.cl;
      if (closestDz !== pdfEditor.mouseOverDz) {
        pdfEditor.removeBySel(".dz-buttons");
        pdfEditor.mouseOverDz = closestDz;
        if (closestDz) {
          let tb = document.createElement("div");
          tb.classList.add("dz-buttons");
          let canMove = closestDz.getAttribute("block_no_move") !== "true";
          let canCopy = closestDz.getAttribute("block_no_copy") !== "true";
          if (e.target.querySelector(".page-break"))
            canCopy = 0;
          tb.innerHTML = `
                    <div>
                        ${canMove ? `<span class='handle' title="\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C">${Icons.move(size, size)}</span>` : ""}
                        ${canCopy ? `<span class='copy' title="\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C">${Icons.copy(size, size)}</span>` : ""}
                        ${canMove ? `<span class='del' title="\u0423\u0434\u0430\u043B\u0438\u0442\u044C">${Icons.del(size, size)}</span>` : ""}
                        ${canMove ? `<span class='up' title="\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0432\u0432\u0435\u0440\u0445">${Icons.up(size, size)}</span>` : ""}
                        ${canMove ? `<span class='down' title="\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0432\u043D\u0438\u0437">${Icons.down(size, size)}</span>` : ""}
                    </div>
                `;
          closestDz.insertBefore(tb, closestDz.firstChild);
          let copy = tb.querySelector(".copy");
          copy && (copy.onclick = (e2) => blocks2.copyBlock(e2));
          let del = tb.querySelector(".del");
          del && (del.onclick = (e2) => {
            e2.stopPropagation();
            let tpl = e2.target.closest(".template");
            tpl.remove();
          });
          let up = tb.querySelector(".up");
          up && (up.onclick = (e2) => {
            e2.stopPropagation();
            let tpl = e2.target.closest(".template");
            if (tpl.previousSibling && tpl.previousSibling.nodeName.toLowerCase() === "div")
              tpl.parentNode.insertBefore(tpl, tpl.previousSibling);
          });
          let down = tb.querySelector(".down");
          down && (down.onclick = (e2) => {
            e2.stopPropagation();
            let tpl = e2.target.closest(".template");
            tpl.parentNode.insertBefore(tpl, tpl.nextSibling.nextSibling);
          });
        }
      }
      return closestDz;
    }
    function elementButtons(e, pdfEditor, closestDz) {
      let size = pdfEditor.properties.buttonsSize;
      let closestTpl = e.target.closest(".page .template.col-xs");
      if (closestTpl !== pdfEditor.mouseOverTpl) {
        pdfEditor.removeBySel(".template-buttons");
        pdfEditor.mouseOverTpl = closestTpl;
        let canEdit = closestDz && closestDz.getAttribute("block_no_edit") !== "true";
        if (closestTpl && canEdit) {
          let closestTpl1 = e.target.closest(".page .template.col-xs:not(.mce-edit-focus)");
          let tb = document.createElement("div");
          tb.classList.add("template-buttons");
          tb.innerHTML = `
                    <div>
                        <div class='handle'>${Icons.move(size, size)}</div>
                    </div>
                `;
          closestTpl1.insertBefore(tb, closestTpl1.firstChild);
        }
      }
    }
  });

  // src/pdf-editor/pageProperties.js
  var require_pageProperties = __commonJS((exports, module) => {
    module.exports = {
      htmlTemplate: function() {
        return `
            <div style="font-size: 16px; padding-left:10px; color: #999;font-family: Arial, sans-serif;">
         
                <span style="color: lightgray; padding-top: 10px;display: inline-block">\u041E\u0442\u0441\u0442\u0443\u043F\u044B</span>&nbsp;<br>
                ${pad("pdf-editor-page-pad-left", "\u0421\u043B\u0435\u0432\u0430")}
                ${pad("pdf-editor-page-pad-top", "\u0421\u0432\u0435\u0440\u0445\u0443")}
                ${pad("pdf-editor-page-pad-right", "\u0421\u043F\u0440\u0430\u0432\u0430")}
                ${pad("pdf-editor-page-pad-bottom", "\u0421\u043D\u0438\u0437\u0443")}
                ${pad("pdf-editor-page-pad-between-elements", "\u041C\u0435\u0436\u0434\u0443 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u043C\u0438")}
                ${pad("pdf-editor-page-pad-between-blocks", "\u041C\u0435\u0436\u0434\u0443 \u0431\u043B\u043E\u043A\u0430\u043C\u0438")}
                
                 <label for="pdf-editor-page-color" style="display:inline-block; width:150px">\u0426\u0432\u0435\u0442 \u0444\u043E\u043D\u0430</label>
                <input id="pdf-editor-page-color" type="color" value="#ffffff" style="width: 55px"><br>
            </div>
        `;
      },
      initPageProperties(pdfEditor) {
        this.pdfEditor = pdfEditor;
        let targetElement = this.pdfEditor.targetElement;
        initPaddingsProps(targetElement);
        initBgColorProp(targetElement);
      }
    };
    function initPaddingsProps(targetElement) {
      targetElement.querySelectorAll(".pdf-editor-page-padding").forEach((input) => {
        let page = targetElement.querySelector(".page");
        input.value = page.hasAttribute(input.id) ? page.getAttribute(input.id) : 5;
        input.onchange = () => {
          if (input.value < 0)
            input.value = 0;
          page.setAttribute(input.id, input.value);
        };
      });
    }
    function initBgColorProp(targetElement) {
      const input = targetElement.querySelector("#pdf-editor-page-color");
      const page = targetElement.querySelector(".page");
      if (page.hasAttribute(input.id)) {
        input.value = page.getAttribute(input.id);
      } else {
        input.value = localStorage.getItem(input.id) || "#ffffff";
        savePageColorToPageData(page, input);
      }
      input.oninput = () => {
        savePageColorToPageData(page, input);
        localStorage.setItem(input.id, input.value);
      };
    }
    function savePageColorToPageData(page, input) {
      page.setAttribute(input.id, input.value);
      page.style.background = input.value;
    }
    function pad(name, title) {
      return `
        <label for="${name}" style="display:inline-block; width:150px">${title}</label>
        <input min="0" class="pdf-editor-page-padding" id="${name}" type="number" style="width: 50px"><br>
    `;
    }
  });

  // src/pdf-editor/blockProperties.js
  var require_blockProperties = __commonJS((exports, module) => {
    var templates = {
      block_name: `
        <div class="sub-label">\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0431\u043B\u043E\u043A\u0430</div>
        <input type="text" id="block_name">
    `,
      block_descr: `
        <div class="sub-label">\u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435 \u0431\u043B\u043E\u043A\u0430</div>
        <textarea id="block_descr"></textarea>
    `,
      block_no_edit: `
        <br>
        <input id="block_no_edit" type="checkbox">
        <label for="block_no_edit" class="sub-label">\u0420\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044C \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435</label>
    `,
      block_no_move: `
        <br>
        <input id="block_no_move" type="checkbox">
        <label for="block_no_move" class="sub-label">\u0420\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044C \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435</label>     
    `,
      block_no_copy: `
        <br>
        <input id="block_no_copy" type="checkbox">
        <label for="block_no_copy"  class="sub-label">\u0420\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044C \u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435</label>
    `,
      block_attach_button: `
        <br>
        <br>
        <button id="block_attach_button" disabled>\u041F\u0440\u0438\u043A\u0440\u0435\u043F\u0438\u0442\u044C \u0438\u0437 \u0431\u0430\u0437\u044B</button>
    `
    };
    module.exports = {
      htmlTemplate: (properties) => `
         <div style="padding:  0 10px; color:white; width:100%">
            ${Object.entries(properties.blockProperties).map(propertyBlock).join("")}
        </div>
    `
    };
    function propertyBlock(entry) {
      return entry[1] !== false ? templates[entry[0]] : "";
    }
  });

  // src/pdf-editor/page-styles.js
  var require_page_styles = __commonJS((exports, module) => {
    module.exports = `
<style>
p {
    margin-block-start: 0!important;
    margin-block-end: 0 !important;
}
.page {
    display: inline-block;
    min-height: 1110px;
    width: 100%;
    background: white;
    text-align: left;
    padding: 5px;
}
.template {
    color: black;
    width: 100%;
    padding: 0px;
}
.page > .template:not(:last-child) {
    margin-bottom: 5px;
}
div.dropzone.row {
    min-height: 35px;
    margin: 0;
    transition: 300ms;
}
div.dropzone.row.empty-drop-zone {
     min-height: 0px;
     opacity: 0;
}
div.template.hover-state div.dropzone.row.empty-drop-zone {
     min-height: 25px;
     opacity: 1;
     background-color: #0002;
}
.page .page-break {
    margin-left: -20px;
    margin-right: -20px;
    background: var(--bg-col);
    color: orange;
}
.page-break {
    background: #eee;
    height: 35px;
    pointer-events:none;
    text-align: center;
    line-height: 35px;
}
 .ck-widget__selection-handle {
    display: none;
 }
 .ck-widget_with-selection-handle{
    margin-top: 15px !important;
 }
 .ck-widget__selection-handle .ck.ck-icon {
    opacity: 0;
    pointer-events: none;
 }
 /*.template.col-xs {*/
 /*   padding: 2px!important;*/
 /*}*/
 /*.dropzone > .template {*/
 /*   height: 100%;*/
 /*}*/
 .page table {
    border-collapse: collapse;
 }
 .page table td {
    min-width: 32px;
 }
 
.content .page.container div.add_editor_here{
    overflow: hidden;
    height: 100%;
}
</style>
`.split("\n").join("").split("    ").join("");
  });

  // src/pdf-editor/svgOverlay/floatingBlockName.js
  var require_floatingBlockName = __commonJS((exports, module) => {
    var blocks2 = require_blocks();
    module.exports = {
      htmlTemplate(properties) {
        return (this.enabled = properties.floatingBlockName) ? `
            <g>
                <rect y="-30" rx="5" height="25" fill="rgb(187, 135, 64)"></rect>
                <text y="-10" x="10"></text>
            </g>
        ` : "";
      },
      initComponent(parentComponent) {
        if (!this.enabled)
          return;
        this.blockNameGroup = parentComponent.querySelector(".svg-overlay g g");
        this.blockNameBg = parentComponent.querySelector(".svg-overlay g g rect");
        this.blockNameText = parentComponent.querySelector(".svg-overlay g g text");
      },
      updateComponent(pdfEditor) {
        if (!this.enabled)
          return;
        let selectedBlock = pdfEditor.selectedBlock;
        if (!selectedBlock)
          return this.blockNameGroup.setAttribute(`transform`, `translate(0,-1000)`);
        let r = selectedBlock.getBoundingClientRect();
        this.blockNameGroup.setAttribute(`transform`, `translate(${r.x},${r.y})`);
        this.blockNameText.textContent = selectedBlock.getAttribute(blocks2.propertyKeys.block_name);
        r = this.blockNameText.getBoundingClientRect();
        this.blockNameBg.setAttribute("width", r.width + 20);
      }
    };
  });

  // src/pdf-editor/svgOverlay/blockSelection.js
  var require_blockSelection = __commonJS((exports, module) => {
    module.exports = {
      htmlTemplate: (properties) => `
         <path fill="none" stroke="#ff6e1b"></path>
    `,
      initComponent(parentComponent) {
        this.blockSelectionFrame = parentComponent.querySelector("path");
      },
      updateComponent(pdfEditor) {
        if (!pdfEditor.selectedBlock)
          return this.blockSelectionFrame.removeAttribute("d");
        let r = pdfEditor.selectedBlock.getBoundingClientRect();
        this.blockSelectionFrame.setAttribute("d", `M${r.x},${r.y}h${r.width}v${r.height + 2}h-${r.width}z`);
      }
    };
  });

  // src/pdf-editor/svgOverlay/svgOverlay.js
  var require_svgOverlay = __commonJS((exports, module) => {
    var floatingBlockName = require_floatingBlockName();
    var blockSelection = require_blockSelection();
    module.exports = {
      htmlTemplate: (properties) => `
        <svg class="svg-overlay">
            <defs>
                <clipPath id="editor_clip_rect">
                    <polygon></polygon>
                </clipPath>
            </defs>
            <g clip-path="url(#editor_clip_rect)">
                ${blockSelection.htmlTemplate(properties)}
                ${floatingBlockName.htmlTemplate(properties)}
            </g>
        </svg>
    `,
      initSvgOverlay: function(pdfEditor) {
        this.pdfEditor = pdfEditor;
        this.overlay = pdfEditor.targetElement.querySelector(".svg-overlay");
        this.overlayClipPolygon = this.overlay.querySelector("#editor_clip_rect polygon");
        blockSelection.initComponent(this.overlay);
        floatingBlockName.initComponent(this.overlay);
        this.updateComponent(this.pdfEditor);
      },
      updateComponent(pdfEditor) {
        requestAnimationFrame(() => this.updateComponent(pdfEditor));
        if (!this.pdfEditor.targetElement.querySelector(".pdf-editor .content"))
          return;
        this.overlay.setAttribute("viewBox", `0 0 ${innerWidth} ${innerHeight}`);
        this.overlay.setAttribute("width", innerWidth);
        this.overlay.setAttribute("height", innerHeight);
        let r = this.pdfEditor.targetElement.querySelector(".pdf-editor .content").getBoundingClientRect();
        let scrollWidth = 17;
        let pts = [
          r.x,
          r.y,
          r.x + r.width - scrollWidth,
          r.y,
          r.x + r.width - scrollWidth,
          r.y + r.height,
          r.x,
          r.y + r.height
        ];
        this.overlayClipPolygon.setAttribute("points", pts.join(" "));
        blockSelection.updateComponent(this.pdfEditor);
        floatingBlockName.updateComponent(this.pdfEditor);
      }
    };
  });

  // src/pdf-editor/html-template.js
  var require_html_template = __commonJS((exports, module) => {
    var tabs = require_tabs();
    module.exports = (properties) => `

    ${require_mouseoverButtons().styles(properties)}
    
    ${tabs.styles(properties)}
    
    <div class="pdf-editor wrapper">
    
        <div class="sidePanel bg1">
        
          <div>
                ${tabs.createTeb("structure", "\u0421\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0430", true)}
                ${tabs.createTeb("properties", "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430")}
                
                <div class="pdf-editor-tab-content structure">
                    <div class="groupName">\u0411\u043B\u043E\u043A\u0438</div>
                    <div id="blocks" class="templates"></div>
                    <div class="groupName">\u042D\u043B\u0435\u043C\u0435\u043D\u0442\u044B</div>
                    <div id="elements" class="templates"></div>
                </div>
                
                <div class="pdf-editor-tab-content properties">
                    <div class="groupName">\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430</div>
                    ${require_pageProperties().htmlTemplate(properties)}
                    ${properties.propertiesPage ? `
                        <div class="groupName">\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u0431\u043B\u043E\u043A\u0430</div>
                        ${require_blockProperties().htmlTemplate(properties)}
                    ` : ""}
                </div>
            
            </div> 
        </div>
        
        <div class="content">
            <div class="page container"> 
            ${require_page_styles()}</div>
        </div>

        ${require_svgOverlay().htmlTemplate(properties)}

    </div>
`;
  });

  // dependencies/ckeditor/ru.js
  var require_ru = __commonJS((exports, module) => {
    module.exports = {
      a: "Image toolbar",
      b: "\u0421\u043F\u0435\u0446\u0441\u0438\u043C\u0432\u043E\u043B\u044B",
      c: "leftwards double arrow",
      d: "rightwards double arrow",
      e: "upwards double arrow",
      f: "downwards double arrow",
      g: "leftwards dashed arrow",
      h: "rightwards dashed arrow",
      i: "upwards dashed arrow",
      j: "downwards dashed arrow",
      k: "leftwards arrow to bar",
      l: "rightwards arrow to bar",
      m: "upwards arrow to bar",
      n: "downwards arrow to bar",
      o: "up down arrow with base",
      p: "back with leftwards arrow above",
      q: "end with leftwards arrow above",
      r: "on with exclamation mark with left right arrow above",
      s: "soon with rightwards arrow above",
      t: "top with upwards arrow above",
      u: "Dollar sign",
      v: "Euro sign",
      w: "Yen sign",
      x: "Pound sign",
      y: "Cent sign",
      z: "Euro-currency sign",
      aa: "Colon sign",
      ab: "Cruzeiro sign",
      ac: "French franc sign",
      ad: "Lira sign",
      ae: "Currency sign",
      af: "Bitcoin sign",
      ag: "Mill sign",
      ah: "Naira sign",
      ai: "Peseta sign",
      aj: "Rupee sign",
      ak: "Won sign",
      al: "New sheqel sign",
      am: "Dong sign",
      an: "Kip sign",
      ao: "Tugrik sign",
      ap: "Drachma sign",
      aq: "German penny sign",
      ar: "Peso sign",
      as: "Guarani sign",
      at: "Austral sign",
      au: "Hryvnia sign",
      av: "Cedi sign",
      aw: "Livre tournois sign",
      ax: "Spesmilo sign",
      ay: "Tenge sign",
      az: "Indian rupee sign",
      ba: "Turkish lira sign",
      bb: "Nordic mark sign",
      bc: "Manat sign",
      bd: "Ruble sign",
      be: "Latin capital letter a with macron",
      bf: "Latin small letter a with macron",
      bg: "Latin capital letter a with breve",
      bh: "Latin small letter a with breve",
      bi: "Latin capital letter a with ogonek",
      bj: "Latin small letter a with ogonek",
      bk: "Latin capital letter c with acute",
      bl: "Latin small letter c with acute",
      bm: "Latin capital letter c with circumflex",
      bn: "Latin small letter c with circumflex",
      bo: "Latin capital letter c with dot above",
      bp: "Latin small letter c with dot above",
      bq: "Latin capital letter c with caron",
      br: "Latin small letter c with caron",
      bs: "Latin capital letter d with caron",
      bt: "Latin small letter d with caron",
      bu: "Latin capital letter d with stroke",
      bv: "Latin small letter d with stroke",
      bw: "Latin capital letter e with macron",
      bx: "Latin small letter e with macron",
      by: "Latin capital letter e with breve",
      bz: "Latin small letter e with breve",
      ca: "Latin capital letter e with dot above",
      cb: "Latin small letter e with dot above",
      cc: "Latin capital letter e with ogonek",
      cd: "Latin small letter e with ogonek",
      ce: "Latin capital letter e with caron",
      cf: "Latin small letter e with caron",
      cg: "Latin capital letter g with circumflex",
      ch: "Latin small letter g with circumflex",
      ci: "Latin capital letter g with breve",
      cj: "Latin small letter g with breve",
      ck: "Latin capital letter g with dot above",
      cl: "Latin small letter g with dot above",
      cm: "Latin capital letter g with cedilla",
      cn: "Latin small letter g with cedilla",
      co: "Latin capital letter h with circumflex",
      cp: "Latin small letter h with circumflex",
      cq: "Latin capital letter h with stroke",
      cr: "Latin small letter h with stroke",
      cs: "Latin capital letter i with tilde",
      ct: "Latin small letter i with tilde",
      cu: "Latin capital letter i with macron",
      cv: "Latin small letter i with macron",
      cw: "Latin capital letter i with breve",
      cx: "Latin small letter i with breve",
      cy: "Latin capital letter i with ogonek",
      cz: "Latin small letter i with ogonek",
      da: "Latin capital letter i with dot above",
      db: "Latin small letter dotless i",
      dc: "Latin capital ligature ij",
      dd: "Latin small ligature ij",
      de: "Latin capital letter j with circumflex",
      df: "Latin small letter j with circumflex",
      dg: "Latin capital letter k with cedilla",
      dh: "Latin small letter k with cedilla",
      di: "Latin small letter kra",
      dj: "Latin capital letter l with acute",
      dk: "Latin small letter l with acute",
      dl: "Latin capital letter l with cedilla",
      dm: "Latin small letter l with cedilla",
      dn: "Latin capital letter l with caron",
      do: "Latin small letter l with caron",
      dp: "Latin capital letter l with middle dot",
      dq: "Latin small letter l with middle dot",
      dr: "Latin capital letter l with stroke",
      ds: "Latin small letter l with stroke",
      dt: "Latin capital letter n with acute",
      du: "Latin small letter n with acute",
      dv: "Latin capital letter n with cedilla",
      dw: "Latin small letter n with cedilla",
      dx: "Latin capital letter n with caron",
      dy: "Latin small letter n with caron",
      dz: "Latin small letter n preceded by apostrophe",
      ea: "Latin capital letter eng",
      eb: "Latin small letter eng",
      ec: "Latin capital letter o with macron",
      ed: "Latin small letter o with macron",
      ee: "Latin capital letter o with breve",
      ef: "Latin small letter o with breve",
      eg: "Latin capital letter o with double acute",
      eh: "Latin small letter o with double acute",
      ei: "Latin capital ligature oe",
      ej: "Latin small ligature oe",
      ek: "Latin capital letter r with acute",
      el: "Latin small letter r with acute",
      em: "Latin capital letter r with cedilla",
      en: "Latin small letter r with cedilla",
      eo: "Latin capital letter r with caron",
      ep: "Latin small letter r with caron",
      eq: "Latin capital letter s with acute",
      er: "Latin small letter s with acute",
      es: "Latin capital letter s with circumflex",
      et: "Latin small letter s with circumflex",
      eu: "Latin capital letter s with cedilla",
      ev: "Latin small letter s with cedilla",
      ew: "Latin capital letter s with caron",
      ex: "Latin small letter s with caron",
      ey: "Latin capital letter t with cedilla",
      ez: "Latin small letter t with cedilla",
      fa: "Latin capital letter t with caron",
      fb: "Latin small letter t with caron",
      fc: "Latin capital letter t with stroke",
      fd: "Latin small letter t with stroke",
      fe: "Latin capital letter u with tilde",
      ff: "Latin small letter u with tilde",
      fg: "Latin capital letter u with macron",
      fh: "Latin small letter u with macron",
      fi: "Latin capital letter u with breve",
      fj: "Latin small letter u with breve",
      fk: "Latin capital letter u with ring above",
      fl: "Latin small letter u with ring above",
      fm: "Latin capital letter u with double acute",
      fn: "Latin small letter u with double acute",
      fo: "Latin capital letter u with ogonek",
      fp: "Latin small letter u with ogonek",
      fq: "Latin capital letter w with circumflex",
      fr: "Latin small letter w with circumflex",
      fs: "Latin capital letter y with circumflex",
      ft: "Latin small letter y with circumflex",
      fu: "Latin capital letter y with diaeresis",
      fv: "Latin capital letter z with acute",
      fw: "Latin small letter z with acute",
      fx: "Latin capital letter z with dot above",
      fy: "Latin small letter z with dot above",
      fz: "Latin capital letter z with caron",
      ga: "Latin small letter z with caron",
      gb: "Latin small letter long s",
      gc: "Less-than sign",
      gd: "Greater-than sign",
      ge: "Less-than or equal to",
      gf: "Greater-than or equal to",
      gg: "En dash",
      gh: "Em dash",
      gi: "Macron",
      gj: "Overline",
      gk: "Degree sign",
      gl: "Minus sign",
      gm: "Plus-minus sign",
      gn: "Division sign",
      go: "Fraction slash",
      gp: "Multiplication sign",
      gq: "Latin small letter f with hook",
      gr: "Integral",
      gs: "N-ary summation",
      gt: "Infinity",
      gu: "Square root",
      gv: "Tilde operator",
      gw: "Approximately equal to",
      gx: "Almost equal to",
      gy: "Not equal to",
      gz: "Identical to",
      ha: "Element of",
      hb: "Not an element of",
      hc: "Contains as member",
      hd: "N-ary product",
      he: "Logical and",
      hf: "Logical or",
      hg: "Not sign",
      hh: "Intersection",
      hi: "Union",
      hj: "Partial differential",
      hk: "For all",
      hl: "There exists",
      hm: "Empty set",
      hn: "Nabla",
      ho: "Asterisk operator",
      hp: "Proportional to",
      hq: "Angle",
      hr: "Vulgar fraction one quarter",
      hs: "Vulgar fraction one half",
      ht: "Vulgar fraction three quarters",
      hu: "Single left-pointing angle quotation mark",
      hv: "Single right-pointing angle quotation mark",
      hw: "Left-pointing double angle quotation mark",
      hx: "Right-pointing double angle quotation mark",
      hy: "Left single quotation mark",
      hz: "Right single quotation mark",
      ia: "Left double quotation mark",
      ib: "Right double quotation mark",
      ic: "Single low-9 quotation mark",
      id: "Double low-9 quotation mark",
      ie: "Inverted exclamation mark",
      if: "Inverted question mark",
      ig: "Two dot leader",
      ih: "Horizontal ellipsis",
      ii: "Double dagger",
      ij: "Per mille sign",
      ik: "Per ten thousand sign",
      il: "Double exclamation mark",
      im: "Question exclamation mark",
      in: "Exclamation question mark",
      io: "Double question mark",
      ip: "Copyright sign",
      iq: "Registered sign",
      ir: "Trade mark sign",
      is: "Section sign",
      it: "Paragraph sign",
      iu: "Reversed paragraph sign",
      iv: "Table toolbar",
      iw: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E \u043B\u0435\u0432\u043E\u043C\u0443 \u043A\u0440\u0430\u044E",
      ix: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E \u043F\u0440\u0430\u0432\u043E\u043C\u0443 \u043A\u0440\u0430\u044E",
      iy: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E \u0446\u0435\u043D\u0442\u0440\u0443",
      iz: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E \u0448\u0438\u0440\u0438\u043D\u0435",
      ja: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u0442\u0435\u043A\u0441\u0442\u0430",
      jb: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435",
      jc: "\u0426\u0438\u0442\u0430\u0442\u0430",
      jd: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A",
      je: "\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A",
      jf: "\u0413\u043E\u0440\u0438\u0437\u043E\u043D\u0442\u0430\u043B\u044C\u043D\u0430\u044F \u043B\u0438\u043D\u0438\u044F",
      jg: "\u0423\u0432\u0435\u043B\u0438\u0447\u0438\u0442\u044C \u043E\u0442\u0441\u0442\u0443\u043F",
      jh: "\u0423\u043C\u0435\u043D\u044C\u0448\u0438\u0442\u044C \u043E\u0442\u0441\u0442\u0443\u043F",
      ji: "\u0416\u0438\u0440\u043D\u044B\u0439",
      jj: "\u041A\u0443\u0440\u0441\u0438\u0432",
      jk: "\u0417\u0430\u0447\u0435\u0440\u043A\u043D\u0443\u0442\u044B\u0439",
      jl: "\u041F\u043E\u0434\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0439",
      jm: "\u041D\u0430\u0434\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0439",
      jn: "\u041F\u043E\u0434\u0447\u0435\u0440\u043A\u043D\u0443\u0442\u044B\u0439",
      jo: "\u0421\u0435\u043C\u0435\u0439\u0441\u0442\u0432\u043E \u0448\u0440\u0438\u0444\u0442\u043E\u0432",
      jp: "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
      jq: "\u0420\u0430\u0437\u043C\u0435\u0440 \u0448\u0440\u0438\u0444\u0442\u0430",
      jr: "\u041E\u0447\u0435\u043D\u044C \u043C\u0435\u043B\u043A\u0438\u0439",
      js: "\u041C\u0435\u043B\u043A\u0438\u0439",
      jt: "\u041A\u0440\u0443\u043F\u043D\u044B\u0439",
      ju: "\u041E\u0447\u0435\u043D\u044C \u043A\u0440\u0443\u043F\u043D\u044B\u0439",
      jv: "\u0426\u0432\u0435\u0442 \u0448\u0440\u0438\u0444\u0442\u0430",
      jw: "\u0426\u0432\u0435\u0442 \u0444\u043E\u043D\u0430",
      jx: "\u0412\u0438\u0434\u0436\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
      jy: "\u041E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
      jz: "\u0411\u043E\u043A\u043E\u0432\u043E\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
      ka: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E \u043B\u0435\u0432\u043E\u043C\u0443 \u043A\u0440\u0430\u044E",
      kb: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E \u0446\u0435\u043D\u0442\u0440\u0443",
      kc: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E \u043F\u0440\u0430\u0432\u043E\u043C\u0443 \u043A\u0440\u0430\u044E",
      kd: "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
      ke: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u043D\u0435 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u0430",
      kf: "Widget toolbar",
      kg: "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u0442\u0430\u0431\u043B\u0438\u0446\u044B",
      kh: "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u044F\u0447\u0435\u0439\u043A\u0438",
      ki: "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0442\u0430\u0431\u043B\u0438\u0446\u0443",
      kj: "\u0421\u0442\u043E\u043B\u0431\u0435\u0446 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432",
      kk: "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446 \u0441\u043B\u0435\u0432\u0430",
      kl: "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446 \u0441\u043F\u0440\u0430\u0432\u0430",
      km: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446",
      kn: "\u0421\u0442\u043E\u043B\u0431\u0435\u0446",
      ko: "\u0421\u0442\u0440\u043E\u043A\u0430 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432",
      kp: "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443 \u043D\u0438\u0436\u0435",
      kq: "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443 \u0432\u044B\u0448\u0435",
      kr: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443",
      ks: "\u0421\u0442\u0440\u043E\u043A\u0430",
      kt: "\u041E\u0431\u044A\u0435\u0434\u0438\u043D\u0438\u0442\u044C \u0441 \u044F\u0447\u0435\u0439\u043A\u043E\u0439 \u0441\u0432\u0435\u0440\u0445\u0443",
      ku: "\u041E\u0431\u044A\u0435\u0434\u0438\u043D\u0438\u0442\u044C \u0441 \u044F\u0447\u0435\u0439\u043A\u043E\u0439 \u0441\u043F\u0440\u0430\u0432\u0430",
      kv: "\u041E\u0431\u044A\u0435\u0434\u0438\u043D\u0438\u0442\u044C \u0441 \u044F\u0447\u0435\u0439\u043A\u043E\u0439 \u0441\u043D\u0438\u0437\u0443",
      kw: "\u041E\u0431\u044A\u0435\u0434\u0438\u043D\u0438\u0442\u044C \u0441 \u044F\u0447\u0435\u0439\u043A\u043E\u0439 \u0441\u043B\u0435\u0432\u0430",
      kx: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u044C \u044F\u0447\u0435\u0439\u043A\u0443 \u0432\u0435\u0440\u0442\u0438\u043A\u0430\u043B\u044C\u043D\u043E",
      ky: "\u0420\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u044C \u044F\u0447\u0435\u0439\u043A\u0443 \u0433\u043E\u0440\u0438\u0437\u043E\u043D\u0442\u0430\u043B\u044C\u043D\u043E",
      kz: "\u041E\u0431\u044A\u0435\u0434\u0438\u043D\u0438\u0442\u044C \u044F\u0447\u0435\u0439\u043A\u0438",
      la: "\u0423\u0431\u0440\u0430\u0442\u044C \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435",
      lb: "\u0418\u0434\u0451\u0442 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0430",
      lc: "\u041D\u0443\u043C\u0435\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      ld: "\u041C\u0430\u0440\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      le: "Character categories",
      lf: "\u0421\u0441\u044B\u043B\u043A\u0430",
      lg: "Dropdown toolbar",
      lh: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442",
      li: "\u0423\u0431\u0440\u0430\u0442\u044C \u0446\u0432\u0435\u0442",
      lj: "\u0426\u0432\u0435\u0442 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B",
      lk: "\u0423\u0431\u0440\u0430\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0443",
      ll: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0443",
      lm: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0443 \u0432 \u043D\u043E\u0432\u043E\u0439 \u0432\u043A\u043B\u0430\u0434\u043A\u0435",
      ln: "\u0414\u043B\u044F \u044D\u0442\u043E\u0439 \u0441\u0441\u044B\u043B\u043A\u0438 \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D \u0430\u0434\u0440\u0435\u0441 URL",
      lo: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
      lp: "\u041E\u0442\u043C\u0435\u043D\u0430",
      lq: "\u0421\u0441\u044B\u043B\u043A\u0430 URL",
      lr: "Editor toolbar",
      ls: "\u0414\u0440\u0443\u0433\u0438\u0435 \u0438\u043D\u0441\u0442\u0440\u0443\u043C\u0435\u043D\u0442\u044B",
      lt: "\u0410\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442",
      lu: "%0 of %1",
      lv: "Previous",
      lw: "Next",
      lx: "\u0427\u0451\u0440\u043D\u044B\u0439",
      ly: "\u0422\u0451\u043C\u043D\u043E-\u0441\u0435\u0440\u044B\u0439",
      lz: "\u0421\u0435\u0440\u044B\u0439",
      ma: "\u0421\u0432\u0435\u0442\u043B\u043E-\u0441\u0435\u0440\u044B\u0439",
      mb: "\u0411\u0435\u043B\u044B\u0439",
      mc: "\u041A\u0440\u0430\u0441\u043D\u044B\u0439",
      md: "\u041E\u0440\u0430\u043D\u0436\u0435\u0432\u044B\u0439",
      me: "\u0416\u0451\u043B\u0442\u044B\u0439",
      mf: "\u0421\u0430\u043B\u0430\u0442\u043E\u0432\u044B\u0439",
      mg: "\u0417\u0435\u043B\u0451\u043D\u044B\u0439",
      mh: "\u0410\u043A\u0432\u0430\u043C\u0430\u0440\u0438\u043D\u043E\u0432\u044B\u0439",
      mi: "\u0411\u0438\u0440\u044E\u0437\u043E\u0432\u044B\u0439",
      mj: "\u0413\u043E\u043B\u0443\u0431\u043E\u0439",
      mk: "\u0421\u0438\u043D\u0438\u0439",
      ml: "\u0424\u0438\u043E\u043B\u0435\u0442\u043E\u0432\u044B\u0439",
      mm: "Open in a new tab",
      mn: "Downloadable",
      mo: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C",
      mp: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C",
      mq: "\u041D\u0435\u0442",
      mr: "\u0421\u043F\u043B\u043E\u0448\u043D\u0430\u044F",
      ms: "\u0422\u043E\u0447\u043A\u0438",
      mt: "\u041F\u0443\u043D\u043A\u0442\u0438\u0440",
      mu: "\u0414\u0432\u043E\u0439\u043D\u0430\u044F",
      mv: "Groove",
      mw: "Ridge",
      mx: "Inset",
      my: "Outset",
      mz: 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
      na: 'The value is invalid. Try "10px" or "2em" or simply "2".',
      nb: "\u0413\u0440\u0430\u043D\u0438\u0446\u0430",
      nc: "\u0421\u0442\u0438\u043B\u044C",
      nd: "\u0428\u0438\u0440\u0438\u043D\u0430",
      ne: "\u0426\u0432\u0435\u0442",
      nf: "\u0426\u0432\u0435\u0442 \u0444\u043E\u043D\u0430",
      ng: "\u0413\u0430\u0431\u0430\u0440\u0438\u0442\u044B",
      nh: "\u0412\u044B\u0441\u043E\u0442\u0430",
      ni: "\u041E\u0442\u0441\u0442\u0443\u043F\u044B",
      nj: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435 \u0432 \u044F\u0447\u0435\u0439\u043A\u0435",
      nk: "Horizontal text alignment toolbar",
      nl: "Vertical text alignment toolbar",
      nm: "Align cell text to the left",
      nn: "Align cell text to the center",
      no: "Align cell text to the right",
      np: "Justify cell text",
      nq: "Align cell text to the top",
      nr: "Align cell text to the middle",
      ns: "Align cell text to the bottom",
      nt: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435",
      nu: "\u0412\u044B\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u043D\u0438\u0435",
      nv: "\u041F\u043E \u043B\u0435\u0432\u043E\u043C\u0443 \u043A\u0440\u0430\u044E",
      nw: "\u041F\u043E \u0446\u0435\u043D\u0442\u0440\u0443",
      nx: "\u041F\u043E \u043F\u0440\u0430\u0432\u043E\u043C\u0443 \u043A\u0440\u0430\u044E",
      ny: "\u041F\u0430\u0440\u0430\u0433\u0440\u0430\u0444",
      nz: "\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A 1",
      oa: "\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A 2",
      ob: "\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A 3",
      oc: "\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A 4",
      od: "\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A 5",
      oe: "\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A 6",
      of: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440, %0"
    };
  });

  // dependencies/ckeditor/ckeditor-baloon/build/ckeditor.js
  var require_ckeditor = __commonJS((exports, module) => {
    /*!
     * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
     * For licensing, see LICENSE.md.
     */
    (function(t) {
      t["ru"] = Object.assign(t["ru"] || {}, require_ru());
    })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
    (function t(e, i) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = i();
      else if (typeof define === "function" && define.amd)
        define([], i);
      else if (typeof exports === "object")
        exports["BalloonEditor"] = i();
      else
        e["BalloonEditor"] = i();
    })(window, function() {
      return function(t) {
        var e = {};
        function i(n) {
          if (e[n]) {
            return e[n].exports;
          }
          var o = e[n] = {i: n, l: false, exports: {}};
          t[n].call(o.exports, o, o.exports, i);
          o.l = true;
          return o.exports;
        }
        i.m = t;
        i.c = e;
        i.d = function(t2, e2, n) {
          if (!i.o(t2, e2)) {
            Object.defineProperty(t2, e2, {enumerable: true, get: n});
          }
        };
        i.r = function(t2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(t2, Symbol.toStringTag, {value: "Module"});
          }
          Object.defineProperty(t2, "__esModule", {value: true});
        };
        i.t = function(t2, e2) {
          if (e2 & 1)
            t2 = i(t2);
          if (e2 & 8)
            return t2;
          if (e2 & 4 && typeof t2 === "object" && t2 && t2.__esModule)
            return t2;
          var n = Object.create(null);
          i.r(n);
          Object.defineProperty(n, "default", {enumerable: true, value: t2});
          if (e2 & 2 && typeof t2 != "string")
            for (var o in t2)
              i.d(n, o, function(e3) {
                return t2[e3];
              }.bind(null, o));
          return n;
        };
        i.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function e3() {
            return t2["default"];
          } : function e3() {
            return t2;
          };
          i.d(e2, "a", e2);
          return e2;
        };
        i.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        };
        i.p = "";
        return i(i.s = 114);
      }([function(t, e, i) {
        "use strict";
        i.d(e, "b", function() {
          return o;
        });
        i.d(e, "a", function() {
          return r;
        });
        const n = "https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html";
        class o extends Error {
          constructor(t2, e2, i2) {
            t2 = r(t2);
            if (i2) {
              t2 += " " + JSON.stringify(i2);
            }
            super(t2);
            this.name = "CKEditorError";
            this.context = e2;
            this.data = i2;
          }
          is(t2) {
            return t2 === "CKEditorError";
          }
          static rethrowUnexpectedError(t2, e2) {
            if (t2.is && t2.is("CKEditorError")) {
              throw t2;
            }
            const i2 = new o(t2.message, e2);
            i2.stack = t2.stack;
            throw i2;
          }
        }
        function r(t2) {
          const e2 = t2.match(/^([^:]+):/);
          if (!e2) {
            return t2;
          }
          return t2 + ` Read more: ${n}#error-${e2[1]}
`;
        }
      }, function(t, e, i) {
        "use strict";
        var n = function t2() {
          var e2;
          return function t3() {
            if (typeof e2 === "undefined") {
              e2 = Boolean(window && document && document.all && !window.atob);
            }
            return e2;
          };
        }();
        var o = function t2() {
          var e2 = {};
          return function t3(i2) {
            if (typeof e2[i2] === "undefined") {
              var n2 = document.querySelector(i2);
              if (window.HTMLIFrameElement && n2 instanceof window.HTMLIFrameElement) {
                try {
                  n2 = n2.contentDocument.head;
                } catch (t4) {
                  n2 = null;
                }
              }
              e2[i2] = n2;
            }
            return e2[i2];
          };
        }();
        var r = [];
        function s(t2) {
          var e2 = -1;
          for (var i2 = 0; i2 < r.length; i2++) {
            if (r[i2].identifier === t2) {
              e2 = i2;
              break;
            }
          }
          return e2;
        }
        function a(t2, e2) {
          var i2 = {};
          var n2 = [];
          for (var o2 = 0; o2 < t2.length; o2++) {
            var a2 = t2[o2];
            var c2 = e2.base ? a2[0] + e2.base : a2[0];
            var l2 = i2[c2] || 0;
            var d2 = "".concat(c2, " ").concat(l2);
            i2[c2] = l2 + 1;
            var u2 = s(d2);
            var h2 = {css: a2[1], media: a2[2], sourceMap: a2[3]};
            if (u2 !== -1) {
              r[u2].references++;
              r[u2].updater(h2);
            } else {
              r.push({identifier: d2, updater: m(h2, e2), references: 1});
            }
            n2.push(d2);
          }
          return n2;
        }
        function c(t2) {
          var e2 = document.createElement("style");
          var n2 = t2.attributes || {};
          if (typeof n2.nonce === "undefined") {
            var r2 = true ? i.nc : void 0;
            if (r2) {
              n2.nonce = r2;
            }
          }
          Object.keys(n2).forEach(function(t3) {
            e2.setAttribute(t3, n2[t3]);
          });
          if (typeof t2.insert === "function") {
            t2.insert(e2);
          } else {
            var s2 = o(t2.insert || "head");
            if (!s2) {
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
            }
            s2.appendChild(e2);
          }
          return e2;
        }
        function l(t2) {
          if (t2.parentNode === null) {
            return false;
          }
          t2.parentNode.removeChild(t2);
        }
        var d = function t2() {
          var e2 = [];
          return function t3(i2, n2) {
            e2[i2] = n2;
            return e2.filter(Boolean).join("\n");
          };
        }();
        function u(t2, e2, i2, n2) {
          var o2 = i2 ? "" : n2.media ? "@media ".concat(n2.media, " {").concat(n2.css, "}") : n2.css;
          if (t2.styleSheet) {
            t2.styleSheet.cssText = d(e2, o2);
          } else {
            var r2 = document.createTextNode(o2);
            var s2 = t2.childNodes;
            if (s2[e2]) {
              t2.removeChild(s2[e2]);
            }
            if (s2.length) {
              t2.insertBefore(r2, s2[e2]);
            } else {
              t2.appendChild(r2);
            }
          }
        }
        function h(t2, e2, i2) {
          var n2 = i2.css;
          var o2 = i2.media;
          var r2 = i2.sourceMap;
          if (o2) {
            t2.setAttribute("media", o2);
          } else {
            t2.removeAttribute("media");
          }
          if (r2 && btoa) {
            n2 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r2)))), " */");
          }
          if (t2.styleSheet) {
            t2.styleSheet.cssText = n2;
          } else {
            while (t2.firstChild) {
              t2.removeChild(t2.firstChild);
            }
            t2.appendChild(document.createTextNode(n2));
          }
        }
        var f = null;
        var g = 0;
        function m(t2, e2) {
          var i2;
          var n2;
          var o2;
          if (e2.singleton) {
            var r2 = g++;
            i2 = f || (f = c(e2));
            n2 = u.bind(null, i2, r2, false);
            o2 = u.bind(null, i2, r2, true);
          } else {
            i2 = c(e2);
            n2 = h.bind(null, i2, e2);
            o2 = function t3() {
              l(i2);
            };
          }
          n2(t2);
          return function e3(i3) {
            if (i3) {
              if (i3.css === t2.css && i3.media === t2.media && i3.sourceMap === t2.sourceMap) {
                return;
              }
              n2(t2 = i3);
            } else {
              o2();
            }
          };
        }
        t.exports = function(t2, e2) {
          e2 = e2 || {};
          if (!e2.singleton && typeof e2.singleton !== "boolean") {
            e2.singleton = n();
          }
          t2 = t2 || [];
          var i2 = a(t2, e2);
          return function t3(n2) {
            n2 = n2 || [];
            if (Object.prototype.toString.call(n2) !== "[object Array]") {
              return;
            }
            for (var o2 = 0; o2 < i2.length; o2++) {
              var c2 = i2[o2];
              var l2 = s(c2);
              r[l2].references--;
            }
            var d2 = a(n2, e2);
            for (var u2 = 0; u2 < i2.length; u2++) {
              var h2 = i2[u2];
              var f2 = s(h2);
              if (r[f2].references === 0) {
                r[f2].updater();
                r.splice(f2, 1);
              }
            }
            i2 = d2;
          };
        };
      }, , function(t, e, i) {
        "use strict";
        var n = i(7);
        var o = typeof self == "object" && self && self.Object === Object && self;
        var r = n["a"] || o || Function("return this")();
        e["a"] = r;
      }, function(t, e, i) {
        "use strict";
        (function(t2) {
          var n = i(3);
          var o = i(14);
          var r = typeof exports == "object" && exports && !exports.nodeType && exports;
          var s = r && typeof t2 == "object" && t2 && !t2.nodeType && t2;
          var a = s && s.exports === r;
          var c = a ? n["a"].Buffer : void 0;
          var l = c ? c.isBuffer : void 0;
          var d = l || o["a"];
          e["a"] = d;
        }).call(this, i(9)(t));
      }, function(t, e, i) {
        "use strict";
        (function(t2) {
          var n = i(7);
          var o = typeof exports == "object" && exports && !exports.nodeType && exports;
          var r = o && typeof t2 == "object" && t2 && !t2.nodeType && t2;
          var s = r && r.exports === o;
          var a = s && n["a"].process;
          var c = function() {
            try {
              var t3 = r && r.require && r.require("util").types;
              if (t3) {
                return t3;
              }
              return a && a.binding && a.binding("util");
            } catch (t4) {
            }
          }();
          e["a"] = c;
        }).call(this, i(9)(t));
      }, function(t, e, i) {
        "use strict";
        (function(t2) {
          var e2 = i(0);
          const n = "18.0.0";
          const o = typeof window === "object" ? window : t2;
          if (o.CKEDITOR_VERSION) {
            throw new e2["b"]("ckeditor-duplicated-modules: Some CKEditor 5 modules are duplicated.", null);
          } else {
            o.CKEDITOR_VERSION = n;
          }
        }).call(this, i(10));
      }, function(t, e, i) {
        "use strict";
        (function(t2) {
          var i2 = typeof t2 == "object" && t2 && t2.Object === Object && t2;
          e["a"] = i2;
        }).call(this, i(10));
      }, function(t, e, i) {
        "use strict";
        (function(t2) {
          var n = i(3);
          var o = typeof exports == "object" && exports && !exports.nodeType && exports;
          var r = o && typeof t2 == "object" && t2 && !t2.nodeType && t2;
          var s = r && r.exports === o;
          var a = s ? n["a"].Buffer : void 0, c = a ? a.allocUnsafe : void 0;
          function l(t3, e2) {
            if (e2) {
              return t3.slice();
            }
            var i2 = t3.length, n2 = c ? c(i2) : new t3.constructor(i2);
            t3.copy(n2);
            return n2;
          }
          e["a"] = l;
        }).call(this, i(9)(t));
      }, function(t, e) {
        t.exports = function(t2) {
          if (!t2.webpackPolyfill) {
            var e2 = Object.create(t2);
            if (!e2.children)
              e2.children = [];
            Object.defineProperty(e2, "loaded", {
              enumerable: true,
              get: function() {
                return e2.l;
              }
            });
            Object.defineProperty(e2, "id", {
              enumerable: true,
              get: function() {
                return e2.i;
              }
            });
            Object.defineProperty(e2, "exports", {enumerable: true});
            e2.webpackPolyfill = 1;
          }
          return e2;
        };
      }, function(t, e) {
        var i;
        i = function() {
          return this;
        }();
        try {
          i = i || new Function("return this")();
        } catch (t2) {
          if (typeof window === "object")
            i = window;
        }
        t.exports = i;
      }, function(t, e, i) {
        var n = i(1);
        var o = i(55);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e, i) {
        var n = i(1);
        var o = i(108);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e, i) {
        var n = i(1);
        var o = i(109);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e, i) {
        "use strict";
        function n() {
          return false;
        }
        e["a"] = n;
      }, function(t, e, i) {
        var n = i(1);
        var o = i(16);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999);--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border:#1f89e5;--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#5c5c5c;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(18);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(-1*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(-1*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}';
      }, function(t, e, i) {
        var n = i(1);
        var o = i(20);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(22);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s{bottom:calc(-1*var(--ck-tooltip-arrow-size));transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after{top:calc(-1*var(--ck-tooltip-arrow-size));transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_n{top:calc(-1*var(--ck-tooltip-arrow-size));transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(-1*var(--ck-tooltip-arrow-size));transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}';
      }, function(t, e, i) {
        var n = i(1);
        var o = i(24);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(-1*var(--ck-spacing-small));margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(-1*var(--ck-spacing-small));margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(26);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(28);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(30);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}:root{--ck-dropdown-arrow-size:calc(0.5*var(--ck-icon-size))}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(32);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(0.2*var(--ck-line-height-base)*var(--ck-font-size-base)) calc(0.4*var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(1.2*var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(34);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:1.3846153847em}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(2*var(--ck-spacing-large))}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(2*var(--ck-spacing-large))}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(0.5*var(--ck-border-radius))}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(-1*var(--ck-switch-button-translation)))}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(36);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-toolbar-dropdown .ck.ck-toolbar .ck.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar-dropdown .ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(38);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(40);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;margin-top:0;margin-bottom:0;background:var(--ck-color-toolbar-border)}.ck.ck-toolbar>.ck-toolbar__items>*{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>*,.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(42);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-placeholder:before,.ck .ck-placeholder:before{content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(44);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(46);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(48);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(50);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(52);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck .ck-button.ck-color-table__remove-color{display:flex;align-items:center;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(54);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".text-tiny{font-size:.7em}.text-small{font-size:.85em}.text-big{font-size:1.4em}.text-huge{font-size:1.8em}";
      }, function(t, e) {
        t.exports = ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(57);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck-editor__editable .ck-horizontal-line{overflow:hidden}.ck-content hr{border:solid #5e5e5e;border-width:1px 0 0;margin:0}.ck-editor__editable .ck-horizontal-line{padding:5px 0}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(59);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-resizer-size:10px;--ck-resizer-border-width:1px;--ck-resizer-border-radius:2px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-tooltip-offset:10px;--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2}.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness))}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle:hover,.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck-editor__editable.ck-read-only .ck-widget{--ck-widget-outline-thickness:0}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(61);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-labeled-input .ck-labeled-input__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-input .ck-labeled-input__status_error{color:var(--ck-color-base-error)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(63);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ":root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{box-shadow:var(--ck-inner-shadow),0 0;background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .2s ease-in-out,border .2s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),var(--ck-inner-shadow)}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(65);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-input{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-input{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}.ck.ck-text-alternative-form{padding:var(--ck-spacing-standard)}.ck.ck-text-alternative-form:focus{outline:none}[dir=ltr] .ck.ck-text-alternative-form>:not(:first-child),[dir=rtl] .ck.ck-text-alternative-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-text-alternative-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-text-alternative-form .ck-labeled-input{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-text-alternative-form .ck-labeled-input .ck-input-text{min-width:0;width:100%}.ck.ck-text-alternative-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-text-alternative-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-text-alternative-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-text-alternative-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-text-alternative-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(67);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck-content .image{display:table;clear:both;text-align:center;margin:1em auto}.ck-content .image>img{display:block;margin:0 auto;max-width:100%;min-width:50px}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(69);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ":root{--ck-image-style-spacing:1.5em}.ck-content .image-style-align-center,.ck-content .image-style-align-left,.ck-content .image-style-align-right,.ck-content .image-style-side{max-width:50%}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(71);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;position:absolute;pointer-events:none;left:0;top:0;outline:1px solid var(--ck-color-resizer)}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{position:absolute;pointer-events:all;width:var(--ck-resizer-size);height:var(--ck-resizer-size);background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{top:var(--ck-resizer-offset);left:var(--ck-resizer-offset);cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{top:var(--ck-resizer-offset);right:var(--ck-resizer-offset);cursor:nesw-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset);cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset);cursor:nesw-resize}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(73);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck-content .image.image_resized{max-width:100%;display:block;box-sizing:border-box}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(75);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-editor__editable .image{position:relative}.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(77);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = '.ck-image-upload-complete-icon{display:block;position:absolute;top:10px;right:10px;border-radius:50%}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20px;--ck-image-upload-icon-width:2px}.ck-image-upload-complete-icon{width:var(--ck-image-upload-icon-size);height:var(--ck-image-upload-icon-size);opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:var(--ck-image-upload-icon-size);animation-delay:0ms,3s}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}';
      }, function(t, e, i) {
        var n = i(1);
        var o = i(79);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}';
      }, function(t, e, i) {
        var n = i(1);
        var o = i(81);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(83);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-input{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form{padding:var(--ck-spacing-standard)}.ck.ck-link-form:focus{outline:none}[dir=ltr] .ck.ck-link-form>:not(:first-child),[dir=rtl] .ck.ck-link-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-link-form .ck-labeled-input{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-form .ck-labeled-input .ck-input-text{min-width:0;width:100%}.ck.ck-link-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-link-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-input{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-input .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin-left:0}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(85);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions{padding:var(--ck-spacing-standard)}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}.ck.ck-link-actions:focus{outline:none}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview):first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview):last-of-type{border-right:1px solid var(--ck-color-base-border)}}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(87);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-character-grid .ck-character-grid__tiles{display:grid;grid-template-columns:repeat(10,1fr)}:root{--ck-character-grid-tile-size:24px}.ck.ck-character-grid{overflow-y:auto;overflow-x:hidden;width:350px;max-height:200px}.ck.ck-character-grid .ck-character-grid__tiles{margin:var(--ck-spacing-standard);grid-gap:var(--ck-spacing-standard)}.ck.ck-character-grid .ck-character-grid__tile{width:var(--ck-character-grid-tile-size);height:var(--ck-character-grid-tile-size);min-width:var(--ck-character-grid-tile-size);min-height:var(--ck-character-grid-tile-size);font-size:1.2em;padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-character-grid .ck-character-grid__tile:focus:not(.ck-disabled),.ck.ck-character-grid .ck-character-grid__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-character-grid .ck-character-grid__tile .ck-button__label{line-height:var(--ck-character-grid-tile-size);width:100%;text-align:center}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(89);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-character-info{display:flex;justify-content:space-between;padding:var(--ck-spacing-small) var(--ck-spacing-standard);border-top:1px solid var(--ck-color-base-border)}.ck.ck-character-info>*{text-transform:uppercase;font-size:var(--ck-font-size-small)}.ck.ck-character-info .ck-character-info__name{max-width:280px;text-overflow:ellipsis;overflow:hidden}.ck.ck-character-info .ck-character-info__code{opacity:.6}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(91);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-special-characters-navigation{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;justify-content:space-between;border-bottom:1px solid var(--ck-color-base-border);padding:var(--ck-spacing-standard)}[dir=ltr] .ck.ck-special-characters-navigation{padding-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-special-characters-navigation{padding-right:var(--ck-spacing-large)}.ck.ck-special-characters-navigation>.ck-label{max-width:160px;text-overflow:ellipsis;overflow:hidden}.ck.ck-special-characters-navigation>.ck-dropdown .ck-dropdown__panel{max-height:250px;overflow-y:auto;overflow-x:hidden}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(93);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ":root{--ck-color-table-focused-cell-background:rgba(158,207,250,0.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(95);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2);padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{width:var(--ck-insert-table-dropdown-box-width);height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);border:1px solid var(--ck-color-base-border);border-radius:1px}.ck .ck-insert-table-dropdown-grid-box.ck-on{border-color:var(--ck-color-focus-border);background:var(--ck-color-focus-outer-shadow)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(97);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ":root{--ck-table-selected-cell-background:#cee5fd}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{background-color:var(--ck-table-selected-cell-background)!important;caret-color:transparent;outline:unset;box-shadow:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget_selected{outline:unset}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(99);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck-content .table{margin:1em auto;display:table}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b3b3b3}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border-color:#bfbfbf}.ck-content .table table th{font-weight:700;background:hsla(0,0%,0%,5%)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(101);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-labeled-view .ck-labeled-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-view .ck-labeled-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-view>.ck.ck-label{width:100%;text-overflow:ellipsis;overflow:hidden}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(103);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-input-color{width:100%;display:flex}.ck.ck-input-color>input.ck.ck-input-text{min-width:auto;flex-grow:1}.ck.ck-input-color>input.ck.ck-input-text:active,.ck.ck-input-color>input.ck.ck-input-text:focus{z-index:var(--ck-z-default)}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{position:relative;overflow:hidden}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{position:absolute;display:block}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{border-top-left-radius:0;border-bottom-left-radius:0;margin-left:-1px}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{border-top-right-radius:0;border-bottom-right-radius:0;margin-right:-1px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview{width:20px;height:20px;border:1px solid var(--ck-color-input-border)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{top:-30%;left:50%;height:150%;width:8%;background:red;border-radius:2px;transform:rotate(45deg);transform-origin:50%}.ck.ck-input-color .ck.ck-input-color__remove-color{width:100%;border-bottom:1px solid var(--ck-color-input-border);padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:0;margin-left:var(--ck-spacing-standard)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(105);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{width:100%;min-width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(107);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ":root{--ck-table-form-header-height:38px}.ck.ck-form__header{padding:0 var(--ck-spacing-large);height:var(--ck-table-form-header-height);line-height:var(--ck-table-form-header-height);border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-form__header .ck-form__header__label{font-weight:700}";
      }, function(t, e) {
        t.exports = ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}";
      }, function(t, e) {
        t.exports = '.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-view{display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{flex-grow:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{flex-wrap:wrap;align-items:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-view{display:flex;flex-direction:column-reverse;align-items:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-view{position:relative}.ck.ck-table-form .ck.ck-labeled-view .ck.ck-labeled-view__status{position:absolute;left:50%;bottom:calc(-1*var(--ck-table-properties-error-arrow-size));transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-view .ck.ck-labeled-view__status:after{content:"";position:absolute;top:calc(-1*var(--ck-table-properties-error-arrow-size));left:50%;transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style{width:80px;min-width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{width:50px;min-width:50px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-view>.ck-label{font-size:10px;text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:start;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-view .ck.ck-labeled-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-view .ck.ck-labeled-view__status,.ck.ck-table-form .ck.ck-labeled-view .ck.ck-labeled-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-view .ck.ck-labeled-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);padding:var(--ck-spacing-small) var(--ck-spacing-medium);min-width:var(--ck-table-properties-min-error-width);text-align:center}.ck.ck-table-form .ck.ck-labeled-view .ck.ck-labeled-view__status:after{border-left:var(--ck-table-properties-error-arrow-size) solid transparent;border-bottom:var(--ck-table-properties-error-arrow-size) solid var(--ck-color-base-error);border-right:var(--ck-table-properties-error-arrow-size) solid transparent;border-top:0 solid transparent}.ck.ck-table-form .ck.ck-labeled-view .ck.ck-labeled-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}';
      }, function(t, e, i) {
        var n = i(1);
        var o = i(111);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{flex-grow:0}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{padding:0;width:35%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none}";
      }, function(t, e, i) {
        var n = i(1);
        var o = i(113);
        o = o.__esModule ? o.default : o;
        if (typeof o === "string") {
          o = [[t.i, o, ""]];
        }
        var r = {injectType: "singletonStyleTag"};
        r.insert = "head";
        r.singleton = true;
        var s = n(o, r);
        var a = o.locals ? o.locals : {};
        t.exports = a;
      }, function(t, e) {
        t.exports = ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{flex-wrap:wrap;flex-basis:0;align-content:baseline}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}";
      }, function(t, e, i) {
        "use strict";
        i.r(e);
        i.d(e, "default", function() {
          return _I;
        });
        var n = i(3);
        var o = n["a"].Symbol;
        var r = o;
        var s = Object.prototype;
        var a = s.hasOwnProperty;
        var c = s.toString;
        var l = r ? r.toStringTag : void 0;
        function d(t2) {
          var e2 = a.call(t2, l), i2 = t2[l];
          try {
            t2[l] = void 0;
            var n2 = true;
          } catch (t3) {
          }
          var o2 = c.call(t2);
          if (n2) {
            if (e2) {
              t2[l] = i2;
            } else {
              delete t2[l];
            }
          }
          return o2;
        }
        var u = d;
        var h = Object.prototype;
        var f = h.toString;
        function g(t2) {
          return f.call(t2);
        }
        var m = g;
        var p = "[object Null]", b = "[object Undefined]";
        var w = r ? r.toStringTag : void 0;
        function k(t2) {
          if (t2 == null) {
            return t2 === void 0 ? b : p;
          }
          return w && w in Object(t2) ? u(t2) : m(t2);
        }
        var _ = k;
        function v(t2, e2) {
          return function(i2) {
            return t2(e2(i2));
          };
        }
        var y = v;
        var x = y(Object.getPrototypeOf, Object);
        var C = x;
        function A(t2) {
          return t2 != null && typeof t2 == "object";
        }
        var T = A;
        var P = "[object Object]";
        var S = Function.prototype, E = Object.prototype;
        var R = S.toString;
        var O = E.hasOwnProperty;
        var I = R.call(Object);
        function V(t2) {
          if (!T(t2) || _(t2) != P) {
            return false;
          }
          var e2 = C(t2);
          if (e2 === null) {
            return true;
          }
          var i2 = O.call(e2, "constructor") && e2.constructor;
          return typeof i2 == "function" && i2 instanceof i2 && R.call(i2) == I;
        }
        var N = V;
        function M() {
          this.__data__ = [];
          this.size = 0;
        }
        var B = M;
        function z(t2, e2) {
          return t2 === e2 || t2 !== t2 && e2 !== e2;
        }
        var L = z;
        function F(t2, e2) {
          var i2 = t2.length;
          while (i2--) {
            if (L(t2[i2][0], e2)) {
              return i2;
            }
          }
          return -1;
        }
        var D = F;
        var j = Array.prototype;
        var H = j.splice;
        function W(t2) {
          var e2 = this.__data__, i2 = D(e2, t2);
          if (i2 < 0) {
            return false;
          }
          var n2 = e2.length - 1;
          if (i2 == n2) {
            e2.pop();
          } else {
            H.call(e2, i2, 1);
          }
          --this.size;
          return true;
        }
        var q = W;
        function U(t2) {
          var e2 = this.__data__, i2 = D(e2, t2);
          return i2 < 0 ? void 0 : e2[i2][1];
        }
        var $ = U;
        function G(t2) {
          return D(this.__data__, t2) > -1;
        }
        var K = G;
        function J(t2, e2) {
          var i2 = this.__data__, n2 = D(i2, t2);
          if (n2 < 0) {
            ++this.size;
            i2.push([t2, e2]);
          } else {
            i2[n2][1] = e2;
          }
          return this;
        }
        var Y = J;
        function Q(t2) {
          var e2 = -1, i2 = t2 == null ? 0 : t2.length;
          this.clear();
          while (++e2 < i2) {
            var n2 = t2[e2];
            this.set(n2[0], n2[1]);
          }
        }
        Q.prototype.clear = B;
        Q.prototype["delete"] = q;
        Q.prototype.get = $;
        Q.prototype.has = K;
        Q.prototype.set = Y;
        var X = Q;
        function Z() {
          this.__data__ = new X();
          this.size = 0;
        }
        var tt = Z;
        function et(t2) {
          var e2 = this.__data__, i2 = e2["delete"](t2);
          this.size = e2.size;
          return i2;
        }
        var it = et;
        function nt(t2) {
          return this.__data__.get(t2);
        }
        var ot = nt;
        function rt(t2) {
          return this.__data__.has(t2);
        }
        var st = rt;
        function at(t2) {
          var e2 = typeof t2;
          return t2 != null && (e2 == "object" || e2 == "function");
        }
        var ct = at;
        var lt = "[object AsyncFunction]", dt = "[object Function]", ut = "[object GeneratorFunction]", ht = "[object Proxy]";
        function ft(t2) {
          if (!ct(t2)) {
            return false;
          }
          var e2 = _(t2);
          return e2 == dt || e2 == ut || e2 == lt || e2 == ht;
        }
        var gt = ft;
        var mt = n["a"]["__core-js_shared__"];
        var pt = mt;
        var bt = function() {
          var t2 = /[^.]+$/.exec(pt && pt.keys && pt.keys.IE_PROTO || "");
          return t2 ? "Symbol(src)_1." + t2 : "";
        }();
        function wt(t2) {
          return !!bt && bt in t2;
        }
        var kt = wt;
        var _t = Function.prototype;
        var vt = _t.toString;
        function yt(t2) {
          if (t2 != null) {
            try {
              return vt.call(t2);
            } catch (t3) {
            }
            try {
              return t2 + "";
            } catch (t3) {
            }
          }
          return "";
        }
        var xt = yt;
        var Ct = /[\\^$.*+?()[\]{}|]/g;
        var At = /^\[object .+?Constructor\]$/;
        var Tt = Function.prototype, Pt = Object.prototype;
        var St = Tt.toString;
        var Et = Pt.hasOwnProperty;
        var Rt = RegExp("^" + St.call(Et).replace(Ct, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        function Ot(t2) {
          if (!ct(t2) || kt(t2)) {
            return false;
          }
          var e2 = gt(t2) ? Rt : At;
          return e2.test(xt(t2));
        }
        var It = Ot;
        function Vt(t2, e2) {
          return t2 == null ? void 0 : t2[e2];
        }
        var Nt = Vt;
        function Mt(t2, e2) {
          var i2 = Nt(t2, e2);
          return It(i2) ? i2 : void 0;
        }
        var Bt = Mt;
        var zt = Bt(n["a"], "Map");
        var Lt = zt;
        var Ft = Bt(Object, "create");
        var Dt = Ft;
        function jt() {
          this.__data__ = Dt ? Dt(null) : {};
          this.size = 0;
        }
        var Ht = jt;
        function Wt(t2) {
          var e2 = this.has(t2) && delete this.__data__[t2];
          this.size -= e2 ? 1 : 0;
          return e2;
        }
        var qt = Wt;
        var Ut = "__lodash_hash_undefined__";
        var $t = Object.prototype;
        var Gt = $t.hasOwnProperty;
        function Kt(t2) {
          var e2 = this.__data__;
          if (Dt) {
            var i2 = e2[t2];
            return i2 === Ut ? void 0 : i2;
          }
          return Gt.call(e2, t2) ? e2[t2] : void 0;
        }
        var Jt = Kt;
        var Yt = Object.prototype;
        var Qt = Yt.hasOwnProperty;
        function Xt(t2) {
          var e2 = this.__data__;
          return Dt ? e2[t2] !== void 0 : Qt.call(e2, t2);
        }
        var Zt = Xt;
        var te = "__lodash_hash_undefined__";
        function ee(t2, e2) {
          var i2 = this.__data__;
          this.size += this.has(t2) ? 0 : 1;
          i2[t2] = Dt && e2 === void 0 ? te : e2;
          return this;
        }
        var ie = ee;
        function ne(t2) {
          var e2 = -1, i2 = t2 == null ? 0 : t2.length;
          this.clear();
          while (++e2 < i2) {
            var n2 = t2[e2];
            this.set(n2[0], n2[1]);
          }
        }
        ne.prototype.clear = Ht;
        ne.prototype["delete"] = qt;
        ne.prototype.get = Jt;
        ne.prototype.has = Zt;
        ne.prototype.set = ie;
        var oe = ne;
        function re() {
          this.size = 0;
          this.__data__ = {hash: new oe(), map: new (Lt || X)(), string: new oe()};
        }
        var se = re;
        function ae(t2) {
          var e2 = typeof t2;
          return e2 == "string" || e2 == "number" || e2 == "symbol" || e2 == "boolean" ? t2 !== "__proto__" : t2 === null;
        }
        var ce = ae;
        function le(t2, e2) {
          var i2 = t2.__data__;
          return ce(e2) ? i2[typeof e2 == "string" ? "string" : "hash"] : i2.map;
        }
        var de = le;
        function ue(t2) {
          var e2 = de(this, t2)["delete"](t2);
          this.size -= e2 ? 1 : 0;
          return e2;
        }
        var he = ue;
        function fe(t2) {
          return de(this, t2).get(t2);
        }
        var ge = fe;
        function me(t2) {
          return de(this, t2).has(t2);
        }
        var pe = me;
        function be(t2, e2) {
          var i2 = de(this, t2), n2 = i2.size;
          i2.set(t2, e2);
          this.size += i2.size == n2 ? 0 : 1;
          return this;
        }
        var we = be;
        function ke(t2) {
          var e2 = -1, i2 = t2 == null ? 0 : t2.length;
          this.clear();
          while (++e2 < i2) {
            var n2 = t2[e2];
            this.set(n2[0], n2[1]);
          }
        }
        ke.prototype.clear = se;
        ke.prototype["delete"] = he;
        ke.prototype.get = ge;
        ke.prototype.has = pe;
        ke.prototype.set = we;
        var _e = ke;
        var ve = 200;
        function ye(t2, e2) {
          var i2 = this.__data__;
          if (i2 instanceof X) {
            var n2 = i2.__data__;
            if (!Lt || n2.length < ve - 1) {
              n2.push([t2, e2]);
              this.size = ++i2.size;
              return this;
            }
            i2 = this.__data__ = new _e(n2);
          }
          i2.set(t2, e2);
          this.size = i2.size;
          return this;
        }
        var xe = ye;
        function Ce(t2) {
          var e2 = this.__data__ = new X(t2);
          this.size = e2.size;
        }
        Ce.prototype.clear = tt;
        Ce.prototype["delete"] = it;
        Ce.prototype.get = ot;
        Ce.prototype.has = st;
        Ce.prototype.set = xe;
        var Ae = Ce;
        function Te(t2, e2) {
          var i2 = -1, n2 = t2 == null ? 0 : t2.length;
          while (++i2 < n2) {
            if (e2(t2[i2], i2, t2) === false) {
              break;
            }
          }
          return t2;
        }
        var Pe = Te;
        var Se = function() {
          try {
            var t2 = Bt(Object, "defineProperty");
            t2({}, "", {});
            return t2;
          } catch (t3) {
          }
        }();
        var Ee = Se;
        function Re(t2, e2, i2) {
          if (e2 == "__proto__" && Ee) {
            Ee(t2, e2, {configurable: true, enumerable: true, value: i2, writable: true});
          } else {
            t2[e2] = i2;
          }
        }
        var Oe = Re;
        var Ie = Object.prototype;
        var Ve = Ie.hasOwnProperty;
        function Ne(t2, e2, i2) {
          var n2 = t2[e2];
          if (!(Ve.call(t2, e2) && L(n2, i2)) || i2 === void 0 && !(e2 in t2)) {
            Oe(t2, e2, i2);
          }
        }
        var Me = Ne;
        function Be(t2, e2, i2, n2) {
          var o2 = !i2;
          i2 || (i2 = {});
          var r2 = -1, s2 = e2.length;
          while (++r2 < s2) {
            var a2 = e2[r2];
            var c2 = n2 ? n2(i2[a2], t2[a2], a2, i2, t2) : void 0;
            if (c2 === void 0) {
              c2 = t2[a2];
            }
            if (o2) {
              Oe(i2, a2, c2);
            } else {
              Me(i2, a2, c2);
            }
          }
          return i2;
        }
        var ze = Be;
        function Le(t2, e2) {
          var i2 = -1, n2 = Array(t2);
          while (++i2 < t2) {
            n2[i2] = e2(i2);
          }
          return n2;
        }
        var Fe = Le;
        var De = "[object Arguments]";
        function je(t2) {
          return T(t2) && _(t2) == De;
        }
        var He = je;
        var We = Object.prototype;
        var qe = We.hasOwnProperty;
        var Ue = We.propertyIsEnumerable;
        var $e = He(function() {
          return arguments;
        }()) ? He : function(t2) {
          return T(t2) && qe.call(t2, "callee") && !Ue.call(t2, "callee");
        };
        var Ge = $e;
        var Ke = Array.isArray;
        var Je = Ke;
        var Ye = i(4);
        var Qe = 9007199254740991;
        var Xe = /^(?:0|[1-9]\d*)$/;
        function Ze(t2, e2) {
          var i2 = typeof t2;
          e2 = e2 == null ? Qe : e2;
          return !!e2 && (i2 == "number" || i2 != "symbol" && Xe.test(t2)) && (t2 > -1 && t2 % 1 == 0 && t2 < e2);
        }
        var ti = Ze;
        var ei = 9007199254740991;
        function ii(t2) {
          return typeof t2 == "number" && t2 > -1 && t2 % 1 == 0 && t2 <= ei;
        }
        var ni = ii;
        var oi = "[object Arguments]", ri = "[object Array]", si = "[object Boolean]", ai = "[object Date]", ci = "[object Error]", li = "[object Function]", di = "[object Map]", ui = "[object Number]", hi = "[object Object]", fi = "[object RegExp]", gi = "[object Set]", mi = "[object String]", pi = "[object WeakMap]";
        var bi = "[object ArrayBuffer]", wi = "[object DataView]", ki = "[object Float32Array]", _i = "[object Float64Array]", vi = "[object Int8Array]", yi = "[object Int16Array]", xi = "[object Int32Array]", Ci = "[object Uint8Array]", Ai = "[object Uint8ClampedArray]", Ti = "[object Uint16Array]", Pi = "[object Uint32Array]";
        var Si = {};
        Si[ki] = Si[_i] = Si[vi] = Si[yi] = Si[xi] = Si[Ci] = Si[Ai] = Si[Ti] = Si[Pi] = true;
        Si[oi] = Si[ri] = Si[bi] = Si[si] = Si[wi] = Si[ai] = Si[ci] = Si[li] = Si[di] = Si[ui] = Si[hi] = Si[fi] = Si[gi] = Si[mi] = Si[pi] = false;
        function Ei(t2) {
          return T(t2) && ni(t2.length) && !!Si[_(t2)];
        }
        var Ri = Ei;
        function Oi(t2) {
          return function(e2) {
            return t2(e2);
          };
        }
        var Ii = Oi;
        var Vi = i(5);
        var Ni = Vi["a"] && Vi["a"].isTypedArray;
        var Mi = Ni ? Ii(Ni) : Ri;
        var Bi = Mi;
        var zi = Object.prototype;
        var Li = zi.hasOwnProperty;
        function Fi(t2, e2) {
          var i2 = Je(t2), n2 = !i2 && Ge(t2), o2 = !i2 && !n2 && Object(Ye["a"])(t2), r2 = !i2 && !n2 && !o2 && Bi(t2), s2 = i2 || n2 || o2 || r2, a2 = s2 ? Fe(t2.length, String) : [], c2 = a2.length;
          for (var l2 in t2) {
            if ((e2 || Li.call(t2, l2)) && !(s2 && (l2 == "length" || o2 && (l2 == "offset" || l2 == "parent") || r2 && (l2 == "buffer" || l2 == "byteLength" || l2 == "byteOffset") || ti(l2, c2)))) {
              a2.push(l2);
            }
          }
          return a2;
        }
        var Di = Fi;
        var ji = Object.prototype;
        function Hi(t2) {
          var e2 = t2 && t2.constructor, i2 = typeof e2 == "function" && e2.prototype || ji;
          return t2 === i2;
        }
        var Wi = Hi;
        var qi = y(Object.keys, Object);
        var Ui = qi;
        var $i = Object.prototype;
        var Gi = $i.hasOwnProperty;
        function Ki(t2) {
          if (!Wi(t2)) {
            return Ui(t2);
          }
          var e2 = [];
          for (var i2 in Object(t2)) {
            if (Gi.call(t2, i2) && i2 != "constructor") {
              e2.push(i2);
            }
          }
          return e2;
        }
        var Ji = Ki;
        function Yi(t2) {
          return t2 != null && ni(t2.length) && !gt(t2);
        }
        var Qi = Yi;
        function Xi(t2) {
          return Qi(t2) ? Di(t2) : Ji(t2);
        }
        var Zi = Xi;
        function tn(t2, e2) {
          return t2 && ze(e2, Zi(e2), t2);
        }
        var en = tn;
        function nn(t2) {
          var e2 = [];
          if (t2 != null) {
            for (var i2 in Object(t2)) {
              e2.push(i2);
            }
          }
          return e2;
        }
        var on = nn;
        var rn = Object.prototype;
        var sn = rn.hasOwnProperty;
        function an(t2) {
          if (!ct(t2)) {
            return on(t2);
          }
          var e2 = Wi(t2), i2 = [];
          for (var n2 in t2) {
            if (!(n2 == "constructor" && (e2 || !sn.call(t2, n2)))) {
              i2.push(n2);
            }
          }
          return i2;
        }
        var cn = an;
        function ln(t2) {
          return Qi(t2) ? Di(t2, true) : cn(t2);
        }
        var dn = ln;
        function un(t2, e2) {
          return t2 && ze(e2, dn(e2), t2);
        }
        var hn = un;
        var fn = i(8);
        function gn(t2, e2) {
          var i2 = -1, n2 = t2.length;
          e2 || (e2 = Array(n2));
          while (++i2 < n2) {
            e2[i2] = t2[i2];
          }
          return e2;
        }
        var mn = gn;
        function pn(t2, e2) {
          var i2 = -1, n2 = t2 == null ? 0 : t2.length, o2 = 0, r2 = [];
          while (++i2 < n2) {
            var s2 = t2[i2];
            if (e2(s2, i2, t2)) {
              r2[o2++] = s2;
            }
          }
          return r2;
        }
        var bn = pn;
        function wn() {
          return [];
        }
        var kn = wn;
        var _n = Object.prototype;
        var vn = _n.propertyIsEnumerable;
        var yn = Object.getOwnPropertySymbols;
        var xn = !yn ? kn : function(t2) {
          if (t2 == null) {
            return [];
          }
          t2 = Object(t2);
          return bn(yn(t2), function(e2) {
            return vn.call(t2, e2);
          });
        };
        var Cn = xn;
        function An(t2, e2) {
          return ze(t2, Cn(t2), e2);
        }
        var Tn = An;
        function Pn(t2, e2) {
          var i2 = -1, n2 = e2.length, o2 = t2.length;
          while (++i2 < n2) {
            t2[o2 + i2] = e2[i2];
          }
          return t2;
        }
        var Sn = Pn;
        var En = Object.getOwnPropertySymbols;
        var Rn = !En ? kn : function(t2) {
          var e2 = [];
          while (t2) {
            Sn(e2, Cn(t2));
            t2 = C(t2);
          }
          return e2;
        };
        var On = Rn;
        function In(t2, e2) {
          return ze(t2, On(t2), e2);
        }
        var Vn = In;
        function Nn(t2, e2, i2) {
          var n2 = e2(t2);
          return Je(t2) ? n2 : Sn(n2, i2(t2));
        }
        var Mn = Nn;
        function Bn(t2) {
          return Mn(t2, Zi, Cn);
        }
        var zn = Bn;
        function Ln(t2) {
          return Mn(t2, dn, On);
        }
        var Fn = Ln;
        var Dn = Bt(n["a"], "DataView");
        var jn = Dn;
        var Hn = Bt(n["a"], "Promise");
        var Wn = Hn;
        var qn = Bt(n["a"], "Set");
        var Un = qn;
        var $n = Bt(n["a"], "WeakMap");
        var Gn = $n;
        var Kn = "[object Map]", Jn = "[object Object]", Yn = "[object Promise]", Qn = "[object Set]", Xn = "[object WeakMap]";
        var Zn = "[object DataView]";
        var to = xt(jn), eo = xt(Lt), io = xt(Wn), no = xt(Un), oo = xt(Gn);
        var ro = _;
        if (jn && ro(new jn(new ArrayBuffer(1))) != Zn || Lt && ro(new Lt()) != Kn || Wn && ro(Wn.resolve()) != Yn || Un && ro(new Un()) != Qn || Gn && ro(new Gn()) != Xn) {
          ro = function(t2) {
            var e2 = _(t2), i2 = e2 == Jn ? t2.constructor : void 0, n2 = i2 ? xt(i2) : "";
            if (n2) {
              switch (n2) {
                case to:
                  return Zn;
                case eo:
                  return Kn;
                case io:
                  return Yn;
                case no:
                  return Qn;
                case oo:
                  return Xn;
              }
            }
            return e2;
          };
        }
        var so = ro;
        var ao = Object.prototype;
        var co = ao.hasOwnProperty;
        function lo(t2) {
          var e2 = t2.length, i2 = new t2.constructor(e2);
          if (e2 && typeof t2[0] == "string" && co.call(t2, "index")) {
            i2.index = t2.index;
            i2.input = t2.input;
          }
          return i2;
        }
        var uo = lo;
        var ho = n["a"].Uint8Array;
        var fo = ho;
        function go(t2) {
          var e2 = new t2.constructor(t2.byteLength);
          new fo(e2).set(new fo(t2));
          return e2;
        }
        var mo = go;
        function po(t2, e2) {
          var i2 = e2 ? mo(t2.buffer) : t2.buffer;
          return new t2.constructor(i2, t2.byteOffset, t2.byteLength);
        }
        var bo = po;
        var wo = /\w*$/;
        function ko(t2) {
          var e2 = new t2.constructor(t2.source, wo.exec(t2));
          e2.lastIndex = t2.lastIndex;
          return e2;
        }
        var _o = ko;
        var vo = r ? r.prototype : void 0, yo = vo ? vo.valueOf : void 0;
        function xo(t2) {
          return yo ? Object(yo.call(t2)) : {};
        }
        var Co = xo;
        function Ao(t2, e2) {
          var i2 = e2 ? mo(t2.buffer) : t2.buffer;
          return new t2.constructor(i2, t2.byteOffset, t2.length);
        }
        var To = Ao;
        var Po = "[object Boolean]", So = "[object Date]", Eo = "[object Map]", Ro = "[object Number]", Oo = "[object RegExp]", Io = "[object Set]", Vo = "[object String]", No = "[object Symbol]";
        var Mo = "[object ArrayBuffer]", Bo = "[object DataView]", zo = "[object Float32Array]", Lo = "[object Float64Array]", Fo = "[object Int8Array]", Do = "[object Int16Array]", jo = "[object Int32Array]", Ho = "[object Uint8Array]", Wo = "[object Uint8ClampedArray]", qo = "[object Uint16Array]", Uo = "[object Uint32Array]";
        function $o(t2, e2, i2) {
          var n2 = t2.constructor;
          switch (e2) {
            case Mo:
              return mo(t2);
            case Po:
            case So:
              return new n2(+t2);
            case Bo:
              return bo(t2, i2);
            case zo:
            case Lo:
            case Fo:
            case Do:
            case jo:
            case Ho:
            case Wo:
            case qo:
            case Uo:
              return To(t2, i2);
            case Eo:
              return new n2();
            case Ro:
            case Vo:
              return new n2(t2);
            case Oo:
              return _o(t2);
            case Io:
              return new n2();
            case No:
              return Co(t2);
          }
        }
        var Go = $o;
        var Ko = Object.create;
        var Jo = function() {
          function t2() {
          }
          return function(e2) {
            if (!ct(e2)) {
              return {};
            }
            if (Ko) {
              return Ko(e2);
            }
            t2.prototype = e2;
            var i2 = new t2();
            t2.prototype = void 0;
            return i2;
          };
        }();
        var Yo = Jo;
        function Qo(t2) {
          return typeof t2.constructor == "function" && !Wi(t2) ? Yo(C(t2)) : {};
        }
        var Xo = Qo;
        var Zo = "[object Map]";
        function tr(t2) {
          return T(t2) && so(t2) == Zo;
        }
        var er = tr;
        var ir = Vi["a"] && Vi["a"].isMap;
        var nr = ir ? Ii(ir) : er;
        var or = nr;
        var rr = "[object Set]";
        function sr(t2) {
          return T(t2) && so(t2) == rr;
        }
        var ar = sr;
        var cr = Vi["a"] && Vi["a"].isSet;
        var lr = cr ? Ii(cr) : ar;
        var dr = lr;
        var ur = 1, hr = 2, fr = 4;
        var gr = "[object Arguments]", mr = "[object Array]", pr = "[object Boolean]", br = "[object Date]", wr = "[object Error]", kr = "[object Function]", _r = "[object GeneratorFunction]", vr = "[object Map]", yr = "[object Number]", xr = "[object Object]", Cr = "[object RegExp]", Ar = "[object Set]", Tr = "[object String]", Pr = "[object Symbol]", Sr = "[object WeakMap]";
        var Er = "[object ArrayBuffer]", Rr = "[object DataView]", Or = "[object Float32Array]", Ir = "[object Float64Array]", Vr = "[object Int8Array]", Nr = "[object Int16Array]", Mr = "[object Int32Array]", Br = "[object Uint8Array]", zr = "[object Uint8ClampedArray]", Lr = "[object Uint16Array]", Fr = "[object Uint32Array]";
        var Dr = {};
        Dr[gr] = Dr[mr] = Dr[Er] = Dr[Rr] = Dr[pr] = Dr[br] = Dr[Or] = Dr[Ir] = Dr[Vr] = Dr[Nr] = Dr[Mr] = Dr[vr] = Dr[yr] = Dr[xr] = Dr[Cr] = Dr[Ar] = Dr[Tr] = Dr[Pr] = Dr[Br] = Dr[zr] = Dr[Lr] = Dr[Fr] = true;
        Dr[wr] = Dr[kr] = Dr[Sr] = false;
        function jr(t2, e2, i2, n2, o2, r2) {
          var s2, a2 = e2 & ur, c2 = e2 & hr, l2 = e2 & fr;
          if (i2) {
            s2 = o2 ? i2(t2, n2, o2, r2) : i2(t2);
          }
          if (s2 !== void 0) {
            return s2;
          }
          if (!ct(t2)) {
            return t2;
          }
          var d2 = Je(t2);
          if (d2) {
            s2 = uo(t2);
            if (!a2) {
              return mn(t2, s2);
            }
          } else {
            var u2 = so(t2), h2 = u2 == kr || u2 == _r;
            if (Object(Ye["a"])(t2)) {
              return Object(fn["a"])(t2, a2);
            }
            if (u2 == xr || u2 == gr || h2 && !o2) {
              s2 = c2 || h2 ? {} : Xo(t2);
              if (!a2) {
                return c2 ? Vn(t2, hn(s2, t2)) : Tn(t2, en(s2, t2));
              }
            } else {
              if (!Dr[u2]) {
                return o2 ? t2 : {};
              }
              s2 = Go(t2, u2, a2);
            }
          }
          r2 || (r2 = new Ae());
          var f2 = r2.get(t2);
          if (f2) {
            return f2;
          }
          r2.set(t2, s2);
          if (dr(t2)) {
            t2.forEach(function(n3) {
              s2.add(jr(n3, e2, i2, n3, t2, r2));
            });
          } else if (or(t2)) {
            t2.forEach(function(n3, o3) {
              s2.set(o3, jr(n3, e2, i2, o3, t2, r2));
            });
          }
          var g2 = l2 ? c2 ? Fn : zn : c2 ? keysIn : Zi;
          var m2 = d2 ? void 0 : g2(t2);
          Pe(m2 || t2, function(n3, o3) {
            if (m2) {
              o3 = n3;
              n3 = t2[o3];
            }
            Me(s2, o3, jr(n3, e2, i2, o3, t2, r2));
          });
          return s2;
        }
        var Hr = jr;
        var Wr = 1, qr = 4;
        function Ur(t2, e2) {
          e2 = typeof e2 == "function" ? e2 : void 0;
          return Hr(t2, Wr | qr, e2);
        }
        var $r = Ur;
        function Gr(t2) {
          return T(t2) && t2.nodeType === 1 && !N(t2);
        }
        var Kr = Gr;
        class Jr {
          constructor(t2, e2) {
            this._config = {};
            if (e2) {
              this.define(Yr(e2));
            }
            if (t2) {
              this._setObjectToTarget(this._config, t2);
            }
          }
          set(t2, e2) {
            this._setToTarget(this._config, t2, e2);
          }
          define(t2, e2) {
            const i2 = true;
            this._setToTarget(this._config, t2, e2, i2);
          }
          get(t2) {
            return this._getFromSource(this._config, t2);
          }
          *names() {
            for (const t2 of Object.keys(this._config)) {
              yield t2;
            }
          }
          _setToTarget(t2, e2, i2, n2 = false) {
            if (N(e2)) {
              this._setObjectToTarget(t2, e2, n2);
              return;
            }
            const o2 = e2.split(".");
            e2 = o2.pop();
            for (const e3 of o2) {
              if (!N(t2[e3])) {
                t2[e3] = {};
              }
              t2 = t2[e3];
            }
            if (N(i2)) {
              if (!N(t2[e2])) {
                t2[e2] = {};
              }
              t2 = t2[e2];
              this._setObjectToTarget(t2, i2, n2);
              return;
            }
            if (n2 && typeof t2[e2] != "undefined") {
              return;
            }
            t2[e2] = i2;
          }
          _getFromSource(t2, e2) {
            const i2 = e2.split(".");
            e2 = i2.pop();
            for (const e3 of i2) {
              if (!N(t2[e3])) {
                t2 = null;
                break;
              }
              t2 = t2[e3];
            }
            return t2 ? Yr(t2[e2]) : void 0;
          }
          _setObjectToTarget(t2, e2, i2) {
            Object.keys(e2).forEach((n2) => {
              this._setToTarget(t2, n2, e2[n2], i2);
            });
          }
        }
        function Yr(t2) {
          return $r(t2, Qr);
        }
        function Qr(t2) {
          return Kr(t2) ? t2 : void 0;
        }
        function Xr() {
          return function t2() {
            t2.called = true;
          };
        }
        var Zr = Xr;
        class ts {
          constructor(t2, e2) {
            this.source = t2;
            this.name = e2;
            this.path = [];
            this.stop = Zr();
            this.off = Zr();
          }
        }
        const es = new Array(256).fill().map((t2, e2) => ("0" + e2.toString(16)).slice(-2));
        function is() {
          const t2 = Math.random() * 4294967296 >>> 0;
          const e2 = Math.random() * 4294967296 >>> 0;
          const i2 = Math.random() * 4294967296 >>> 0;
          const n2 = Math.random() * 4294967296 >>> 0;
          return "e" + es[t2 >> 0 & 255] + es[t2 >> 8 & 255] + es[t2 >> 16 & 255] + es[t2 >> 24 & 255] + es[e2 >> 0 & 255] + es[e2 >> 8 & 255] + es[e2 >> 16 & 255] + es[e2 >> 24 & 255] + es[i2 >> 0 & 255] + es[i2 >> 8 & 255] + es[i2 >> 16 & 255] + es[i2 >> 24 & 255] + es[n2 >> 0 & 255] + es[n2 >> 8 & 255] + es[n2 >> 16 & 255] + es[n2 >> 24 & 255];
        }
        const ns = {
          get(t2) {
            if (typeof t2 != "number") {
              return this[t2] || this.normal;
            } else {
              return t2;
            }
          },
          highest: 1e5,
          high: 1e3,
          normal: 0,
          low: -1e3,
          lowest: -1e5
        };
        var os = ns;
        var rs = i(6);
        var ss = i(0);
        const as = Symbol("listeningTo");
        const cs = Symbol("emitterId");
        const ls = {
          on(t2, e2, i2 = {}) {
            this.listenTo(this, t2, e2, i2);
          },
          once(t2, e2, i2) {
            let n2 = false;
            const o2 = function(t3, ...i3) {
              if (!n2) {
                n2 = true;
                t3.off();
                e2.call(this, t3, ...i3);
              }
            };
            this.listenTo(this, t2, o2, i2);
          },
          off(t2, e2) {
            this.stopListening(this, t2, e2);
          },
          listenTo(t2, e2, i2, n2 = {}) {
            let o2, r2;
            if (!this[as]) {
              this[as] = {};
            }
            const s2 = this[as];
            if (!fs(t2)) {
              hs(t2);
            }
            const a2 = fs(t2);
            if (!(o2 = s2[a2])) {
              o2 = s2[a2] = {emitter: t2, callbacks: {}};
            }
            if (!(r2 = o2.callbacks[e2])) {
              r2 = o2.callbacks[e2] = [];
            }
            r2.push(i2);
            ps(t2, e2);
            const c2 = bs(t2, e2);
            const l2 = os.get(n2.priority);
            const d2 = {callback: i2, priority: l2};
            for (const t3 of c2) {
              let e3 = false;
              for (let i3 = 0; i3 < t3.length; i3++) {
                if (t3[i3].priority < l2) {
                  t3.splice(i3, 0, d2);
                  e3 = true;
                  break;
                }
              }
              if (!e3) {
                t3.push(d2);
              }
            }
          },
          stopListening(t2, e2, i2) {
            const n2 = this[as];
            let o2 = t2 && fs(t2);
            const r2 = n2 && o2 && n2[o2];
            const s2 = r2 && e2 && r2.callbacks[e2];
            if (!n2 || t2 && !r2 || e2 && !s2) {
              return;
            }
            if (i2) {
              _s(t2, e2, i2);
            } else if (s2) {
              while (i2 = s2.pop()) {
                _s(t2, e2, i2);
              }
              delete r2.callbacks[e2];
            } else if (r2) {
              for (e2 in r2.callbacks) {
                this.stopListening(t2, e2);
              }
              delete n2[o2];
            } else {
              for (o2 in n2) {
                this.stopListening(n2[o2].emitter);
              }
              delete this[as];
            }
          },
          fire(t2, ...e2) {
            try {
              const i2 = t2 instanceof ts ? t2 : new ts(this, t2);
              const n2 = i2.name;
              let o2 = ws(this, n2);
              i2.path.push(this);
              if (o2) {
                const t3 = [i2, ...e2];
                o2 = Array.from(o2);
                for (let e3 = 0; e3 < o2.length; e3++) {
                  o2[e3].callback.apply(this, t3);
                  if (i2.off.called) {
                    delete i2.off.called;
                    _s(this, n2, o2[e3].callback);
                  }
                  if (i2.stop.called) {
                    break;
                  }
                }
              }
              if (this._delegations) {
                const t3 = this._delegations.get(n2);
                const o3 = this._delegations.get("*");
                if (t3) {
                  ks(t3, i2, e2);
                }
                if (o3) {
                  ks(o3, i2, e2);
                }
              }
              return i2.return;
            } catch (t3) {
              ss["b"].rethrowUnexpectedError(t3, this);
            }
          },
          delegate(...t2) {
            return {
              to: (e2, i2) => {
                if (!this._delegations) {
                  this._delegations = new Map();
                }
                t2.forEach((t3) => {
                  const n2 = this._delegations.get(t3);
                  if (!n2) {
                    this._delegations.set(t3, new Map([[e2, i2]]));
                  } else {
                    n2.set(e2, i2);
                  }
                });
              }
            };
          },
          stopDelegating(t2, e2) {
            if (!this._delegations) {
              return;
            }
            if (!t2) {
              this._delegations.clear();
            } else if (!e2) {
              this._delegations.delete(t2);
            } else {
              const i2 = this._delegations.get(t2);
              if (i2) {
                i2.delete(e2);
              }
            }
          }
        };
        var ds = ls;
        function us(t2, e2) {
          if (t2[as] && t2[as][e2]) {
            return t2[as][e2].emitter;
          }
          return null;
        }
        function hs(t2, e2) {
          if (!t2[cs]) {
            t2[cs] = e2 || is();
          }
        }
        function fs(t2) {
          return t2[cs];
        }
        function gs(t2) {
          if (!t2._events) {
            Object.defineProperty(t2, "_events", {value: {}});
          }
          return t2._events;
        }
        function ms() {
          return {callbacks: [], childEvents: []};
        }
        function ps(t2, e2) {
          const i2 = gs(t2);
          if (i2[e2]) {
            return;
          }
          let n2 = e2;
          let o2 = null;
          const r2 = [];
          while (n2 !== "") {
            if (i2[n2]) {
              break;
            }
            i2[n2] = ms();
            r2.push(i2[n2]);
            if (o2) {
              i2[n2].childEvents.push(o2);
            }
            o2 = n2;
            n2 = n2.substr(0, n2.lastIndexOf(":"));
          }
          if (n2 !== "") {
            for (const t3 of r2) {
              t3.callbacks = i2[n2].callbacks.slice();
            }
            i2[n2].childEvents.push(o2);
          }
        }
        function bs(t2, e2) {
          const i2 = gs(t2)[e2];
          if (!i2) {
            return [];
          }
          let n2 = [i2.callbacks];
          for (let e3 = 0; e3 < i2.childEvents.length; e3++) {
            const o2 = bs(t2, i2.childEvents[e3]);
            n2 = n2.concat(o2);
          }
          return n2;
        }
        function ws(t2, e2) {
          let i2;
          if (!t2._events || !(i2 = t2._events[e2]) || !i2.callbacks.length) {
            if (e2.indexOf(":") > -1) {
              return ws(t2, e2.substr(0, e2.lastIndexOf(":")));
            } else {
              return null;
            }
          }
          return i2.callbacks;
        }
        function ks(t2, e2, i2) {
          for (let [n2, o2] of t2) {
            if (!o2) {
              o2 = e2.name;
            } else if (typeof o2 == "function") {
              o2 = o2(e2.name);
            }
            const t3 = new ts(e2.source, o2);
            t3.path = [...e2.path];
            n2.fire(t3, ...i2);
          }
        }
        function _s(t2, e2, i2) {
          const n2 = bs(t2, e2);
          for (const t3 of n2) {
            for (let e3 = 0; e3 < t3.length; e3++) {
              if (t3[e3].callback == i2) {
                t3.splice(e3, 1);
                e3--;
              }
            }
          }
        }
        function vs(t2, ...e2) {
          e2.forEach((e3) => {
            Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3)).forEach((i2) => {
              if (i2 in t2.prototype) {
                return;
              }
              const n2 = Object.getOwnPropertyDescriptor(e3, i2);
              n2.enumerable = false;
              Object.defineProperty(t2.prototype, i2, n2);
            });
          });
        }
        class ys {
          constructor(t2 = {}) {
            this._items = [];
            this._itemMap = new Map();
            this._idProperty = t2.idProperty || "id";
            this._bindToExternalToInternalMap = new WeakMap();
            this._bindToInternalToExternalMap = new WeakMap();
            this._skippedIndexesFromExternal = [];
          }
          get length() {
            return this._items.length;
          }
          get first() {
            return this._items[0] || null;
          }
          get last() {
            return this._items[this.length - 1] || null;
          }
          add(t2, e2) {
            let i2;
            const n2 = this._idProperty;
            if (n2 in t2) {
              i2 = t2[n2];
              if (typeof i2 != "string") {
                throw new ss["b"]("collection-add-invalid-id", this);
              }
              if (this.get(i2)) {
                throw new ss["b"]("collection-add-item-already-exists", this);
              }
            } else {
              t2[n2] = i2 = is();
            }
            if (e2 === void 0) {
              e2 = this._items.length;
            } else if (e2 > this._items.length || e2 < 0) {
              throw new ss["b"]("collection-add-item-invalid-index", this);
            }
            this._items.splice(e2, 0, t2);
            this._itemMap.set(i2, t2);
            this.fire("add", t2, e2);
            return this;
          }
          get(t2) {
            let e2;
            if (typeof t2 == "string") {
              e2 = this._itemMap.get(t2);
            } else if (typeof t2 == "number") {
              e2 = this._items[t2];
            } else {
              throw new ss["b"]("collection-get-invalid-arg: Index or id must be given.", this);
            }
            return e2 || null;
          }
          has(t2) {
            if (typeof t2 == "string") {
              return this._itemMap.has(t2);
            } else {
              const e2 = this._idProperty;
              const i2 = t2[e2];
              return this._itemMap.has(i2);
            }
          }
          getIndex(t2) {
            let e2;
            if (typeof t2 == "string") {
              e2 = this._itemMap.get(t2);
            } else {
              e2 = t2;
            }
            return this._items.indexOf(e2);
          }
          remove(t2) {
            let e2, i2, n2;
            let o2 = false;
            const r2 = this._idProperty;
            if (typeof t2 == "string") {
              i2 = t2;
              n2 = this._itemMap.get(i2);
              o2 = !n2;
              if (n2) {
                e2 = this._items.indexOf(n2);
              }
            } else if (typeof t2 == "number") {
              e2 = t2;
              n2 = this._items[e2];
              o2 = !n2;
              if (n2) {
                i2 = n2[r2];
              }
            } else {
              n2 = t2;
              i2 = n2[r2];
              e2 = this._items.indexOf(n2);
              o2 = e2 == -1 || !this._itemMap.get(i2);
            }
            if (o2) {
              throw new ss["b"]("collection-remove-404: Item not found.", this);
            }
            this._items.splice(e2, 1);
            this._itemMap.delete(i2);
            const s2 = this._bindToInternalToExternalMap.get(n2);
            this._bindToInternalToExternalMap.delete(n2);
            this._bindToExternalToInternalMap.delete(s2);
            this.fire("remove", n2, e2);
            return n2;
          }
          map(t2, e2) {
            return this._items.map(t2, e2);
          }
          find(t2, e2) {
            return this._items.find(t2, e2);
          }
          filter(t2, e2) {
            return this._items.filter(t2, e2);
          }
          clear() {
            if (this._bindToCollection) {
              this.stopListening(this._bindToCollection);
              this._bindToCollection = null;
            }
            while (this.length) {
              this.remove(0);
            }
          }
          bindTo(t2) {
            if (this._bindToCollection) {
              throw new ss["b"]("collection-bind-to-rebind: The collection cannot be bound more than once.", this);
            }
            this._bindToCollection = t2;
            return {
              as: (t3) => {
                this._setUpBindToBinding((e2) => new t3(e2));
              },
              using: (t3) => {
                if (typeof t3 == "function") {
                  this._setUpBindToBinding((e2) => t3(e2));
                } else {
                  this._setUpBindToBinding((e2) => e2[t3]);
                }
              }
            };
          }
          _setUpBindToBinding(t2) {
            const e2 = this._bindToCollection;
            const i2 = (i3, n2, o2) => {
              const r2 = e2._bindToCollection == this;
              const s2 = e2._bindToInternalToExternalMap.get(n2);
              if (r2 && s2) {
                this._bindToExternalToInternalMap.set(n2, s2);
                this._bindToInternalToExternalMap.set(s2, n2);
              } else {
                const i4 = t2(n2);
                if (!i4) {
                  this._skippedIndexesFromExternal.push(o2);
                  return;
                }
                let r3 = o2;
                for (const t3 of this._skippedIndexesFromExternal) {
                  if (o2 > t3) {
                    r3--;
                  }
                }
                for (const t3 of e2._skippedIndexesFromExternal) {
                  if (r3 >= t3) {
                    r3++;
                  }
                }
                this._bindToExternalToInternalMap.set(n2, i4);
                this._bindToInternalToExternalMap.set(i4, n2);
                this.add(i4, r3);
                for (let t3 = 0; t3 < e2._skippedIndexesFromExternal.length; t3++) {
                  if (r3 <= e2._skippedIndexesFromExternal[t3]) {
                    e2._skippedIndexesFromExternal[t3]++;
                  }
                }
              }
            };
            for (const t3 of e2) {
              i2(null, t3, e2.getIndex(t3));
            }
            this.listenTo(e2, "add", i2);
            this.listenTo(e2, "remove", (t3, e3, i3) => {
              const n2 = this._bindToExternalToInternalMap.get(e3);
              if (n2) {
                this.remove(n2);
              }
              this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t4, e4) => {
                if (i3 < e4) {
                  t4.push(e4 - 1);
                }
                if (i3 > e4) {
                  t4.push(e4);
                }
                return t4;
              }, []);
            });
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
        }
        vs(ys, ds);
        class xs {
          constructor(t2, e2 = [], i2 = []) {
            this._context = t2;
            this._plugins = new Map();
            this._availablePlugins = new Map();
            for (const t3 of e2) {
              if (t3.pluginName) {
                this._availablePlugins.set(t3.pluginName, t3);
              }
            }
            this._contextPlugins = new Map();
            for (const [t3, e3] of i2) {
              this._contextPlugins.set(t3, e3);
              this._contextPlugins.set(e3, t3);
              if (t3.pluginName) {
                this._availablePlugins.set(t3.pluginName, t3);
              }
            }
          }
          *[Symbol.iterator]() {
            for (const t2 of this._plugins) {
              if (typeof t2[0] == "function") {
                yield t2;
              }
            }
          }
          get(t2) {
            const e2 = this._plugins.get(t2);
            if (!e2) {
              const e3 = "plugincollection-plugin-not-loaded: The requested plugin is not loaded.";
              let i2 = t2;
              if (typeof t2 == "function") {
                i2 = t2.pluginName || t2.name;
              }
              throw new ss["b"](e3, this._context, {plugin: i2});
            }
            return e2;
          }
          has(t2) {
            return this._plugins.has(t2);
          }
          init(t2, e2 = []) {
            const i2 = this;
            const n2 = this._context;
            const o2 = new Set();
            const r2 = [];
            const s2 = g2(t2);
            const a2 = g2(e2);
            const c2 = f2(t2);
            if (c2) {
              const t3 = "plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.";
              console.error(Object(ss["a"])(t3), {plugins: c2});
              return Promise.reject(new ss["b"](t3, n2, {plugins: c2}));
            }
            return Promise.all(s2.map(l2)).then(() => d2(r2, "init")).then(() => d2(r2, "afterInit")).then(() => r2);
            function l2(t3) {
              if (a2.includes(t3)) {
                return;
              }
              if (i2._plugins.has(t3) || o2.has(t3)) {
                return;
              }
              return u2(t3).catch((e3) => {
                console.error(Object(ss["a"])("plugincollection-load: It was not possible to load the plugin."), {plugin: t3});
                throw e3;
              });
            }
            function d2(t3, e3) {
              return t3.reduce((t4, n3) => {
                if (!n3[e3]) {
                  return t4;
                }
                if (i2._contextPlugins.has(n3)) {
                  return t4;
                }
                return t4.then(n3[e3].bind(n3));
              }, Promise.resolve());
            }
            function u2(t3) {
              return new Promise((s3) => {
                o2.add(t3);
                if (t3.requires) {
                  t3.requires.forEach((i3) => {
                    const o3 = h2(i3);
                    if (t3.isContextPlugin && !o3.isContextPlugin) {
                      throw new ss["b"]("plugincollection-context-required: Context plugin can not require plugin which is not a context plugin", null, {
                        plugin: o3.name,
                        requiredBy: t3.name
                      });
                    }
                    if (e2.includes(o3)) {
                      throw new ss["b"]("plugincollection-required: Cannot load a plugin because one of its dependencies is listed inthe `removePlugins` option.", n2, {
                        plugin: o3.name,
                        requiredBy: t3.name
                      });
                    }
                    l2(o3);
                  });
                }
                const a3 = i2._contextPlugins.get(t3) || new t3(n2);
                i2._add(t3, a3);
                r2.push(a3);
                s3();
              });
            }
            function h2(t3) {
              if (typeof t3 == "function") {
                return t3;
              }
              return i2._availablePlugins.get(t3);
            }
            function f2(t3) {
              const e3 = [];
              for (const i3 of t3) {
                if (!h2(i3)) {
                  e3.push(i3);
                }
              }
              return e3.length ? e3 : null;
            }
            function g2(t3) {
              return t3.map((t4) => h2(t4)).filter((t4) => !!t4);
            }
          }
          destroy() {
            const t2 = [];
            for (const [, e2] of this) {
              if (typeof e2.destroy == "function" && !this._contextPlugins.has(e2)) {
                t2.push(e2.destroy());
              }
            }
            return Promise.all(t2);
          }
          _add(t2, e2) {
            this._plugins.set(t2, e2);
            const i2 = t2.pluginName;
            if (!i2) {
              return;
            }
            if (this._plugins.has(i2)) {
              throw new ss["b"]("plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.", null, {
                pluginName: i2,
                plugin1: this._plugins.get(i2).constructor,
                plugin2: t2
              });
            }
            this._plugins.set(i2, e2);
          }
        }
        vs(xs, ds);
        if (!window.CKEDITOR_TRANSLATIONS) {
          window.CKEDITOR_TRANSLATIONS = {};
        }
        function Cs(t2, e2) {
          const i2 = window.CKEDITOR_TRANSLATIONS[t2] || (window.CKEDITOR_TRANSLATIONS[t2] = {});
          Object.assign(i2, e2);
        }
        function As(t2, e2) {
          const i2 = Ss();
          if (i2 === 1) {
            t2 = Object.keys(window.CKEDITOR_TRANSLATIONS)[0];
          }
          if (i2 === 0 || !Ps(t2, e2)) {
            return e2.replace(/ \[context: [^\]]+\]$/, "");
          }
          const n2 = window.CKEDITOR_TRANSLATIONS[t2];
          return n2[e2].replace(/ \[context: [^\]]+\]$/, "");
        }
        function Ts() {
          window.CKEDITOR_TRANSLATIONS = {};
        }
        function Ps(t2, e2) {
          return t2 in window.CKEDITOR_TRANSLATIONS && e2 in window.CKEDITOR_TRANSLATIONS[t2];
        }
        function Ss() {
          return Object.keys(window.CKEDITOR_TRANSLATIONS).length;
        }
        const Es = ["ar", "fa", "he", "ku", "ug"];
        class Rs {
          constructor(t2 = {}) {
            this.uiLanguage = t2.uiLanguage || "en";
            this.contentLanguage = t2.contentLanguage || this.uiLanguage;
            this.uiLanguageDirection = Os(this.uiLanguage);
            this.contentLanguageDirection = Os(this.contentLanguage);
            this.t = (...t3) => this._t(...t3);
          }
          get language() {
            console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead.");
            return this.uiLanguage;
          }
          _t(t2, e2) {
            let i2 = As(this.uiLanguage, t2);
            if (e2) {
              i2 = i2.replace(/%(\d+)/g, (t3, i3) => i3 < e2.length ? e2[i3] : t3);
            }
            return i2;
          }
        }
        function Os(t2) {
          return Es.includes(t2) ? "rtl" : "ltr";
        }
        class Is {
          constructor(t2) {
            this.config = new Jr(t2, this.constructor.defaultConfig);
            const e2 = this.constructor.builtinPlugins;
            this.config.define("plugins", e2);
            this.plugins = new xs(this, e2);
            const i2 = this.config.get("language") || {};
            this.locale = new Rs({
              uiLanguage: typeof i2 === "string" ? i2 : i2.ui,
              contentLanguage: this.config.get("language.content")
            });
            this.t = this.locale.t;
            this.editors = new ys();
            this._contextOwner = null;
          }
          initPlugins() {
            const t2 = this.config.get("plugins") || [];
            for (const e2 of t2) {
              if (typeof e2 != "function") {
                throw new ss["b"]("context-initplugins-constructor-only: Only a constructor function is allowed as a context plugin.", null, {Plugin: e2});
              }
              if (e2.isContextPlugin !== true) {
                throw new ss["b"]("context-initplugins-invalid-plugin: Only a plugin marked as a context plugin is allowed to be used with a context.", null, {Plugin: e2});
              }
            }
            return this.plugins.init(t2);
          }
          destroy() {
            return Promise.all(Array.from(this.editors, (t2) => t2.destroy())).then(() => this.plugins.destroy());
          }
          _addEditor(t2, e2) {
            if (this._contextOwner) {
              throw new ss["b"]("context-addEditor-private-context: Cannot add multiple editors to the context which is created by the editor.");
            }
            this.editors.add(t2);
            if (e2) {
              this._contextOwner = t2;
            }
          }
          _removeEditor(t2) {
            if (this.editors.has(t2)) {
              this.editors.remove(t2);
            }
            if (this._contextOwner === t2) {
              return this.destroy();
            }
            return Promise.resolve();
          }
          _getEditorConfig() {
            const t2 = {};
            for (const e2 of this.config.names()) {
              if (!["plugins", "removePlugins", "extraPlugins"].includes(e2)) {
                t2[e2] = this.config.get(e2);
              }
            }
            return t2;
          }
          static create(t2) {
            return new Promise((e2) => {
              const i2 = new this(t2);
              e2(i2.initPlugins().then(() => i2));
            });
          }
        }
        function Vs(t2, e2) {
          const i2 = Math.min(t2.length, e2.length);
          for (let n2 = 0; n2 < i2; n2++) {
            if (t2[n2] != e2[n2]) {
              return n2;
            }
          }
          if (t2.length == e2.length) {
            return "same";
          } else if (t2.length < e2.length) {
            return "prefix";
          } else {
            return "extension";
          }
        }
        var Ns = 4;
        function Ms(t2) {
          return Hr(t2, Ns);
        }
        var Bs = Ms;
        class zs {
          constructor(t2) {
            this.document = t2;
            this.parent = null;
          }
          get index() {
            let t2;
            if (!this.parent) {
              return null;
            }
            if ((t2 = this.parent.getChildIndex(this)) == -1) {
              throw new ss["b"]("view-node-not-found-in-parent: The node's parent does not contain this node.", this);
            }
            return t2;
          }
          get nextSibling() {
            const t2 = this.index;
            return t2 !== null && this.parent.getChild(t2 + 1) || null;
          }
          get previousSibling() {
            const t2 = this.index;
            return t2 !== null && this.parent.getChild(t2 - 1) || null;
          }
          get root() {
            let t2 = this;
            while (t2.parent) {
              t2 = t2.parent;
            }
            return t2;
          }
          isAttached() {
            return this.root.is("rootElement");
          }
          getPath() {
            const t2 = [];
            let e2 = this;
            while (e2.parent) {
              t2.unshift(e2.index);
              e2 = e2.parent;
            }
            return t2;
          }
          getAncestors(t2 = {includeSelf: false, parentFirst: false}) {
            const e2 = [];
            let i2 = t2.includeSelf ? this : this.parent;
            while (i2) {
              e2[t2.parentFirst ? "push" : "unshift"](i2);
              i2 = i2.parent;
            }
            return e2;
          }
          getCommonAncestor(t2, e2 = {}) {
            const i2 = this.getAncestors(e2);
            const n2 = t2.getAncestors(e2);
            let o2 = 0;
            while (i2[o2] == n2[o2] && i2[o2]) {
              o2++;
            }
            return o2 === 0 ? null : i2[o2 - 1];
          }
          isBefore(t2) {
            if (this == t2) {
              return false;
            }
            if (this.root !== t2.root) {
              return false;
            }
            const e2 = this.getPath();
            const i2 = t2.getPath();
            const n2 = Vs(e2, i2);
            switch (n2) {
              case "prefix":
                return true;
              case "extension":
                return false;
              default:
                return e2[n2] < i2[n2];
            }
          }
          isAfter(t2) {
            if (this == t2) {
              return false;
            }
            if (this.root !== t2.root) {
              return false;
            }
            return !this.isBefore(t2);
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _fireChange(t2, e2) {
            this.fire("change:" + t2, e2);
            if (this.parent) {
              this.parent._fireChange(t2, e2);
            }
          }
          toJSON() {
            const t2 = Bs(this);
            delete t2.parent;
            return t2;
          }
          is(t2) {
            return t2 == "node" || t2 == "view:node";
          }
        }
        vs(zs, ds);
        class Ls extends zs {
          constructor(t2, e2) {
            super(t2);
            this._textData = e2;
          }
          is(t2) {
            return t2 == "text" || t2 == "view:text" || super.is(t2);
          }
          get data() {
            return this._textData;
          }
          get _data() {
            return this.data;
          }
          set _data(t2) {
            this._fireChange("text", this);
            this._textData = t2;
          }
          isSimilar(t2) {
            if (!(t2 instanceof Ls)) {
              return false;
            }
            return this === t2 || this.data === t2.data;
          }
          _clone() {
            return new Ls(this.document, this.data);
          }
        }
        class Fs {
          constructor(t2, e2, i2) {
            this.textNode = t2;
            if (e2 < 0 || e2 > t2.data.length) {
              throw new ss["b"]("view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.", this);
            }
            if (i2 < 0 || e2 + i2 > t2.data.length) {
              throw new ss["b"]("view-textproxy-wrong-length: Given length value is incorrect.", this);
            }
            this.data = t2.data.substring(e2, e2 + i2);
            this.offsetInText = e2;
          }
          get offsetSize() {
            return this.data.length;
          }
          get isPartial() {
            return this.data.length !== this.textNode.data.length;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          get document() {
            return this.textNode.document;
          }
          is(t2) {
            return t2 == "textProxy" || t2 == "view:textProxy";
          }
          getAncestors(t2 = {includeSelf: false, parentFirst: false}) {
            const e2 = [];
            let i2 = t2.includeSelf ? this.textNode : this.parent;
            while (i2 !== null) {
              e2[t2.parentFirst ? "push" : "unshift"](i2);
              i2 = i2.parent;
            }
            return e2;
          }
        }
        function Ds(t2) {
          const e2 = new Map();
          for (const i2 in t2) {
            e2.set(i2, t2[i2]);
          }
          return e2;
        }
        function js(t2) {
          return !!(t2 && t2[Symbol.iterator]);
        }
        function Hs(t2) {
          if (js(t2)) {
            return new Map(t2);
          } else {
            return Ds(t2);
          }
        }
        class Ws {
          constructor(...t2) {
            this._patterns = [];
            this.add(...t2);
          }
          add(...t2) {
            for (let e2 of t2) {
              if (typeof e2 == "string" || e2 instanceof RegExp) {
                e2 = {name: e2};
              }
              if (e2.classes && (typeof e2.classes == "string" || e2.classes instanceof RegExp)) {
                e2.classes = [e2.classes];
              }
              this._patterns.push(e2);
            }
          }
          match(...t2) {
            for (const e2 of t2) {
              for (const t3 of this._patterns) {
                const i2 = qs(e2, t3);
                if (i2) {
                  return {element: e2, pattern: t3, match: i2};
                }
              }
            }
            return null;
          }
          matchAll(...t2) {
            const e2 = [];
            for (const i2 of t2) {
              for (const t3 of this._patterns) {
                const n2 = qs(i2, t3);
                if (n2) {
                  e2.push({element: i2, pattern: t3, match: n2});
                }
              }
            }
            return e2.length > 0 ? e2 : null;
          }
          getElementName() {
            if (this._patterns.length !== 1) {
              return null;
            }
            const t2 = this._patterns[0];
            const e2 = t2.name;
            return typeof t2 != "function" && e2 && !(e2 instanceof RegExp) ? e2 : null;
          }
        }
        function qs(t2, e2) {
          if (typeof e2 == "function") {
            return e2(t2);
          }
          const i2 = {};
          if (e2.name) {
            i2.name = Us(e2.name, t2.name);
            if (!i2.name) {
              return null;
            }
          }
          if (e2.attributes) {
            i2.attributes = $s(e2.attributes, t2);
            if (!i2.attributes) {
              return null;
            }
          }
          if (e2.classes) {
            i2.classes = Gs(e2.classes, t2);
            if (!i2.classes) {
              return false;
            }
          }
          if (e2.styles) {
            i2.styles = Ks(e2.styles, t2);
            if (!i2.styles) {
              return false;
            }
          }
          return i2;
        }
        function Us(t2, e2) {
          if (t2 instanceof RegExp) {
            return t2.test(e2);
          }
          return t2 === e2;
        }
        function $s(t2, e2) {
          const i2 = [];
          for (const n2 in t2) {
            const o2 = t2[n2];
            if (e2.hasAttribute(n2)) {
              const t3 = e2.getAttribute(n2);
              if (o2 === true) {
                i2.push(n2);
              } else if (o2 instanceof RegExp) {
                if (o2.test(t3)) {
                  i2.push(n2);
                } else {
                  return null;
                }
              } else if (t3 === o2) {
                i2.push(n2);
              } else {
                return null;
              }
            } else {
              return null;
            }
          }
          return i2;
        }
        function Gs(t2, e2) {
          const i2 = [];
          for (const n2 of t2) {
            if (n2 instanceof RegExp) {
              const t3 = e2.getClassNames();
              for (const e3 of t3) {
                if (n2.test(e3)) {
                  i2.push(e3);
                }
              }
              if (i2.length === 0) {
                return null;
              }
            } else if (e2.hasClass(n2)) {
              i2.push(n2);
            } else {
              return null;
            }
          }
          return i2;
        }
        function Ks(t2, e2) {
          const i2 = [];
          for (const n2 in t2) {
            const o2 = t2[n2];
            if (e2.hasStyle(n2)) {
              const t3 = e2.getStyle(n2);
              if (o2 instanceof RegExp) {
                if (o2.test(t3)) {
                  i2.push(n2);
                } else {
                  return null;
                }
              } else if (t3 === o2) {
                i2.push(n2);
              } else {
                return null;
              }
            } else {
              return null;
            }
          }
          return i2;
        }
        var Js = "[object Symbol]";
        function Ys(t2) {
          return typeof t2 == "symbol" || T(t2) && _(t2) == Js;
        }
        var Qs = Ys;
        var Xs = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Zs = /^\w*$/;
        function ta(t2, e2) {
          if (Je(t2)) {
            return false;
          }
          var i2 = typeof t2;
          if (i2 == "number" || i2 == "symbol" || i2 == "boolean" || t2 == null || Qs(t2)) {
            return true;
          }
          return Zs.test(t2) || !Xs.test(t2) || e2 != null && t2 in Object(e2);
        }
        var ea = ta;
        var ia = "Expected a function";
        function na(t2, e2) {
          if (typeof t2 != "function" || e2 != null && typeof e2 != "function") {
            throw new TypeError(ia);
          }
          var i2 = function() {
            var n2 = arguments, o2 = e2 ? e2.apply(this, n2) : n2[0], r2 = i2.cache;
            if (r2.has(o2)) {
              return r2.get(o2);
            }
            var s2 = t2.apply(this, n2);
            i2.cache = r2.set(o2, s2) || r2;
            return s2;
          };
          i2.cache = new (na.Cache || _e)();
          return i2;
        }
        na.Cache = _e;
        var oa = na;
        var ra = 500;
        function sa(t2) {
          var e2 = oa(t2, function(t3) {
            if (i2.size === ra) {
              i2.clear();
            }
            return t3;
          });
          var i2 = e2.cache;
          return e2;
        }
        var aa = sa;
        var ca = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var la = /\\(\\)?/g;
        var da = aa(function(t2) {
          var e2 = [];
          if (t2.charCodeAt(0) === 46) {
            e2.push("");
          }
          t2.replace(ca, function(t3, i2, n2, o2) {
            e2.push(n2 ? o2.replace(la, "$1") : i2 || t3);
          });
          return e2;
        });
        var ua = da;
        function ha(t2, e2) {
          var i2 = -1, n2 = t2 == null ? 0 : t2.length, o2 = Array(n2);
          while (++i2 < n2) {
            o2[i2] = e2(t2[i2], i2, t2);
          }
          return o2;
        }
        var fa = ha;
        var ga = 1 / 0;
        var ma = r ? r.prototype : void 0, pa = ma ? ma.toString : void 0;
        function ba(t2) {
          if (typeof t2 == "string") {
            return t2;
          }
          if (Je(t2)) {
            return fa(t2, ba) + "";
          }
          if (Qs(t2)) {
            return pa ? pa.call(t2) : "";
          }
          var e2 = t2 + "";
          return e2 == "0" && 1 / t2 == -ga ? "-0" : e2;
        }
        var wa = ba;
        function ka(t2) {
          return t2 == null ? "" : wa(t2);
        }
        var _a = ka;
        function va(t2, e2) {
          if (Je(t2)) {
            return t2;
          }
          return ea(t2, e2) ? [t2] : ua(_a(t2));
        }
        var ya = va;
        function xa(t2) {
          var e2 = t2 == null ? 0 : t2.length;
          return e2 ? t2[e2 - 1] : void 0;
        }
        var Ca = xa;
        var Aa = 1 / 0;
        function Ta(t2) {
          if (typeof t2 == "string" || Qs(t2)) {
            return t2;
          }
          var e2 = t2 + "";
          return e2 == "0" && 1 / t2 == -Aa ? "-0" : e2;
        }
        var Pa = Ta;
        function Sa(t2, e2) {
          e2 = ya(e2, t2);
          var i2 = 0, n2 = e2.length;
          while (t2 != null && i2 < n2) {
            t2 = t2[Pa(e2[i2++])];
          }
          return i2 && i2 == n2 ? t2 : void 0;
        }
        var Ea = Sa;
        function Ra(t2, e2, i2) {
          var n2 = -1, o2 = t2.length;
          if (e2 < 0) {
            e2 = -e2 > o2 ? 0 : o2 + e2;
          }
          i2 = i2 > o2 ? o2 : i2;
          if (i2 < 0) {
            i2 += o2;
          }
          o2 = e2 > i2 ? 0 : i2 - e2 >>> 0;
          e2 >>>= 0;
          var r2 = Array(o2);
          while (++n2 < o2) {
            r2[n2] = t2[n2 + e2];
          }
          return r2;
        }
        var Oa = Ra;
        function Ia(t2, e2) {
          return e2.length < 2 ? t2 : Ea(t2, Oa(e2, 0, -1));
        }
        var Va = Ia;
        function Na(t2, e2) {
          e2 = ya(e2, t2);
          t2 = Va(t2, e2);
          return t2 == null || delete t2[Pa(Ca(e2))];
        }
        var Ma = Na;
        function Ba(t2, e2) {
          return t2 == null ? true : Ma(t2, e2);
        }
        var za = Ba;
        function La(t2, e2, i2) {
          var n2 = t2 == null ? void 0 : Ea(t2, e2);
          return n2 === void 0 ? i2 : n2;
        }
        var Fa = La;
        function Da(t2, e2, i2) {
          if (i2 !== void 0 && !L(t2[e2], i2) || i2 === void 0 && !(e2 in t2)) {
            Oe(t2, e2, i2);
          }
        }
        var ja = Da;
        function Ha(t2) {
          return function(e2, i2, n2) {
            var o2 = -1, r2 = Object(e2), s2 = n2(e2), a2 = s2.length;
            while (a2--) {
              var c2 = s2[t2 ? a2 : ++o2];
              if (i2(r2[c2], c2, r2) === false) {
                break;
              }
            }
            return e2;
          };
        }
        var Wa = Ha;
        var qa = Wa();
        var Ua = qa;
        function $a(t2) {
          return T(t2) && Qi(t2);
        }
        var Ga = $a;
        function Ka(t2, e2) {
          if (e2 === "constructor" && typeof t2[e2] === "function") {
            return;
          }
          if (e2 == "__proto__") {
            return;
          }
          return t2[e2];
        }
        var Ja = Ka;
        function Ya(t2) {
          return ze(t2, dn(t2));
        }
        var Qa = Ya;
        function Xa(t2, e2, i2, n2, o2, r2, s2) {
          var a2 = Ja(t2, i2), c2 = Ja(e2, i2), l2 = s2.get(c2);
          if (l2) {
            ja(t2, i2, l2);
            return;
          }
          var d2 = r2 ? r2(a2, c2, i2 + "", t2, e2, s2) : void 0;
          var u2 = d2 === void 0;
          if (u2) {
            var h2 = Je(c2), f2 = !h2 && Object(Ye["a"])(c2), g2 = !h2 && !f2 && Bi(c2);
            d2 = c2;
            if (h2 || f2 || g2) {
              if (Je(a2)) {
                d2 = a2;
              } else if (Ga(a2)) {
                d2 = mn(a2);
              } else if (f2) {
                u2 = false;
                d2 = Object(fn["a"])(c2, true);
              } else if (g2) {
                u2 = false;
                d2 = To(c2, true);
              } else {
                d2 = [];
              }
            } else if (N(c2) || Ge(c2)) {
              d2 = a2;
              if (Ge(a2)) {
                d2 = Qa(a2);
              } else if (!ct(a2) || gt(a2)) {
                d2 = Xo(c2);
              }
            } else {
              u2 = false;
            }
          }
          if (u2) {
            s2.set(c2, d2);
            o2(d2, c2, n2, r2, s2);
            s2["delete"](c2);
          }
          ja(t2, i2, d2);
        }
        var Za = Xa;
        function tc(t2, e2, i2, n2, o2) {
          if (t2 === e2) {
            return;
          }
          Ua(e2, function(r2, s2) {
            o2 || (o2 = new Ae());
            if (ct(r2)) {
              Za(t2, e2, s2, i2, tc, n2, o2);
            } else {
              var a2 = n2 ? n2(Ja(t2, s2), r2, s2 + "", t2, e2, o2) : void 0;
              if (a2 === void 0) {
                a2 = r2;
              }
              ja(t2, s2, a2);
            }
          }, dn);
        }
        var ec = tc;
        function ic(t2) {
          return t2;
        }
        var nc = ic;
        function oc(t2, e2, i2) {
          switch (i2.length) {
            case 0:
              return t2.call(e2);
            case 1:
              return t2.call(e2, i2[0]);
            case 2:
              return t2.call(e2, i2[0], i2[1]);
            case 3:
              return t2.call(e2, i2[0], i2[1], i2[2]);
          }
          return t2.apply(e2, i2);
        }
        var rc = oc;
        var sc = Math.max;
        function ac(t2, e2, i2) {
          e2 = sc(e2 === void 0 ? t2.length - 1 : e2, 0);
          return function() {
            var n2 = arguments, o2 = -1, r2 = sc(n2.length - e2, 0), s2 = Array(r2);
            while (++o2 < r2) {
              s2[o2] = n2[e2 + o2];
            }
            o2 = -1;
            var a2 = Array(e2 + 1);
            while (++o2 < e2) {
              a2[o2] = n2[o2];
            }
            a2[e2] = i2(s2);
            return rc(t2, this, a2);
          };
        }
        var cc = ac;
        function lc(t2) {
          return function() {
            return t2;
          };
        }
        var dc = lc;
        var uc = !Ee ? nc : function(t2, e2) {
          return Ee(t2, "toString", {configurable: true, enumerable: false, value: dc(e2), writable: true});
        };
        var hc = uc;
        var fc = 800, gc = 16;
        var mc = Date.now;
        function pc(t2) {
          var e2 = 0, i2 = 0;
          return function() {
            var n2 = mc(), o2 = gc - (n2 - i2);
            i2 = n2;
            if (o2 > 0) {
              if (++e2 >= fc) {
                return arguments[0];
              }
            } else {
              e2 = 0;
            }
            return t2.apply(void 0, arguments);
          };
        }
        var bc = pc;
        var wc = bc(hc);
        var kc = wc;
        function _c(t2, e2) {
          return kc(cc(t2, e2, nc), t2 + "");
        }
        var vc = _c;
        function yc(t2, e2, i2) {
          if (!ct(i2)) {
            return false;
          }
          var n2 = typeof e2;
          if (n2 == "number" ? Qi(i2) && ti(e2, i2.length) : n2 == "string" && e2 in i2) {
            return L(i2[e2], t2);
          }
          return false;
        }
        var xc = yc;
        function Cc(t2) {
          return vc(function(e2, i2) {
            var n2 = -1, o2 = i2.length, r2 = o2 > 1 ? i2[o2 - 1] : void 0, s2 = o2 > 2 ? i2[2] : void 0;
            r2 = t2.length > 3 && typeof r2 == "function" ? (o2--, r2) : void 0;
            if (s2 && xc(i2[0], i2[1], s2)) {
              r2 = o2 < 3 ? void 0 : r2;
              o2 = 1;
            }
            e2 = Object(e2);
            while (++n2 < o2) {
              var a2 = i2[n2];
              if (a2) {
                t2(e2, a2, n2, r2);
              }
            }
            return e2;
          });
        }
        var Ac = Cc;
        var Tc = Ac(function(t2, e2, i2) {
          ec(t2, e2, i2);
        });
        var Pc = Tc;
        function Sc(t2, e2, i2, n2) {
          if (!ct(t2)) {
            return t2;
          }
          e2 = ya(e2, t2);
          var o2 = -1, r2 = e2.length, s2 = r2 - 1, a2 = t2;
          while (a2 != null && ++o2 < r2) {
            var c2 = Pa(e2[o2]), l2 = i2;
            if (o2 != s2) {
              var d2 = a2[c2];
              l2 = n2 ? n2(d2, c2, a2) : void 0;
              if (l2 === void 0) {
                l2 = ct(d2) ? d2 : ti(e2[o2 + 1]) ? [] : {};
              }
            }
            Me(a2, c2, l2);
            a2 = a2[c2];
          }
          return t2;
        }
        var Ec = Sc;
        function Rc(t2, e2, i2) {
          return t2 == null ? t2 : Ec(t2, e2, i2);
        }
        var Oc = Rc;
        class Ic {
          constructor(t2) {
            this._styles = {};
            this._styleProcessor = t2;
          }
          get isEmpty() {
            const t2 = Object.entries(this._styles);
            const e2 = Array.from(t2);
            return !e2.length;
          }
          get size() {
            if (this.isEmpty) {
              return 0;
            }
            return this.getStyleNames().length;
          }
          setTo(t2) {
            this.clear();
            const e2 = Array.from(Nc(t2).entries());
            for (const [t3, i2] of e2) {
              this._styleProcessor.toNormalizedForm(t3, i2, this._styles);
            }
          }
          has(t2) {
            if (this.isEmpty) {
              return false;
            }
            const e2 = this._styleProcessor.getReducedForm(t2, this._styles);
            const i2 = e2.find(([e3]) => e3 === t2);
            return Array.isArray(i2);
          }
          set(t2, e2) {
            if (ct(t2)) {
              for (const [e3, i2] of Object.entries(t2)) {
                this._styleProcessor.toNormalizedForm(e3, i2, this._styles);
              }
            } else {
              this._styleProcessor.toNormalizedForm(t2, e2, this._styles);
            }
          }
          remove(t2) {
            const e2 = Mc(t2);
            za(this._styles, e2);
            delete this._styles[t2];
            this._cleanEmptyObjectsOnPath(e2);
          }
          getNormalized(t2) {
            return this._styleProcessor.getNormalized(t2, this._styles);
          }
          toString() {
            if (this.isEmpty) {
              return "";
            }
            return this._getStylesEntries().map((t2) => t2.join(":")).sort().join(";") + ";";
          }
          getAsString(t2) {
            if (this.isEmpty) {
              return;
            }
            if (this._styles[t2] && !ct(this._styles[t2])) {
              return this._styles[t2];
            }
            const e2 = this._styleProcessor.getReducedForm(t2, this._styles);
            const i2 = e2.find(([e3]) => e3 === t2);
            if (Array.isArray(i2)) {
              return i2[1];
            }
          }
          getStyleNames() {
            if (this.isEmpty) {
              return [];
            }
            const t2 = this._getStylesEntries();
            return t2.map(([t3]) => t3);
          }
          clear() {
            this._styles = {};
          }
          _getStylesEntries() {
            const t2 = [];
            const e2 = Object.keys(this._styles);
            for (const i2 of e2) {
              t2.push(...this._styleProcessor.getReducedForm(i2, this._styles));
            }
            return t2;
          }
          _cleanEmptyObjectsOnPath(t2) {
            const e2 = t2.split(".");
            const i2 = e2.length > 1;
            if (!i2) {
              return;
            }
            const n2 = e2.splice(0, e2.length - 1).join(".");
            const o2 = Fa(this._styles, n2);
            if (!o2) {
              return;
            }
            const r2 = !Array.from(Object.keys(o2)).length;
            if (r2) {
              this.remove(n2);
            }
          }
        }
        class Vc {
          constructor() {
            this._normalizers = new Map();
            this._extractors = new Map();
            this._reducers = new Map();
            this._consumables = new Map();
          }
          toNormalizedForm(t2, e2, i2) {
            if (ct(e2)) {
              Bc(i2, Mc(t2), e2);
              return;
            }
            if (this._normalizers.has(t2)) {
              const n2 = this._normalizers.get(t2);
              const {path: o2, value: r2} = n2(e2);
              Bc(i2, o2, r2);
            } else {
              Bc(i2, t2, e2);
            }
          }
          getNormalized(t2, e2) {
            if (!t2) {
              return Pc({}, e2);
            }
            if (e2[t2] !== void 0) {
              return e2[t2];
            }
            if (this._extractors.has(t2)) {
              const i2 = this._extractors.get(t2);
              if (typeof i2 === "string") {
                return Fa(e2, i2);
              }
              const n2 = i2(t2, e2);
              if (n2) {
                return n2;
              }
            }
            return Fa(e2, Mc(t2));
          }
          getReducedForm(t2, e2) {
            const i2 = this.getNormalized(t2, e2);
            if (i2 === void 0) {
              return [];
            }
            if (this._reducers.has(t2)) {
              const e3 = this._reducers.get(t2);
              return e3(i2);
            }
            return [[t2, i2]];
          }
          getRelatedStyles(t2) {
            return this._consumables.get(t2) || [];
          }
          setNormalizer(t2, e2) {
            this._normalizers.set(t2, e2);
          }
          setExtractor(t2, e2) {
            this._extractors.set(t2, e2);
          }
          setReducer(t2, e2) {
            this._reducers.set(t2, e2);
          }
          setStyleRelation(t2, e2) {
            this._mapStyleNames(t2, e2);
            for (const i2 of e2) {
              this._mapStyleNames(i2, [t2]);
            }
          }
          _mapStyleNames(t2, e2) {
            if (!this._consumables.has(t2)) {
              this._consumables.set(t2, []);
            }
            this._consumables.get(t2).push(...e2);
          }
        }
        function Nc(t2) {
          let e2 = null;
          let i2 = 0;
          let n2 = 0;
          let o2 = null;
          const r2 = new Map();
          if (t2 === "") {
            return r2;
          }
          if (t2.charAt(t2.length - 1) != ";") {
            t2 = t2 + ";";
          }
          for (let s2 = 0; s2 < t2.length; s2++) {
            const a2 = t2.charAt(s2);
            if (e2 === null) {
              switch (a2) {
                case ":":
                  if (!o2) {
                    o2 = t2.substr(i2, s2 - i2);
                    n2 = s2 + 1;
                  }
                  break;
                case '"':
                case "'":
                  e2 = a2;
                  break;
                case ";": {
                  const e3 = t2.substr(n2, s2 - n2);
                  if (o2) {
                    r2.set(o2.trim(), e3.trim());
                  }
                  o2 = null;
                  i2 = s2 + 1;
                  break;
                }
              }
            } else if (a2 === e2) {
              e2 = null;
            }
          }
          return r2;
        }
        function Mc(t2) {
          return t2.replace("-", ".");
        }
        function Bc(t2, e2, i2) {
          let n2 = i2;
          if (ct(i2)) {
            n2 = Pc({}, Fa(t2, e2), i2);
          }
          Oc(t2, e2, n2);
        }
        class zc extends zs {
          constructor(t2, e2, i2, n2) {
            super(t2);
            this.name = e2;
            this._attrs = Lc(i2);
            this._children = [];
            if (n2) {
              this._insertChild(0, n2);
            }
            this._classes = new Set();
            if (this._attrs.has("class")) {
              const t3 = this._attrs.get("class");
              Fc(this._classes, t3);
              this._attrs.delete("class");
            }
            this._styles = new Ic(this.document.stylesProcessor);
            if (this._attrs.has("style")) {
              this._styles.setTo(this._attrs.get("style"));
              this._attrs.delete("style");
            }
            this._customProperties = new Map();
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return this._children.length === 0;
          }
          is(t2, e2 = null) {
            const i2 = t2.replace(/^view:/, "");
            if (!e2) {
              return i2 == "element" || i2 == this.name || super.is(t2);
            } else {
              return i2 == "element" && e2 == this.name;
            }
          }
          getChild(t2) {
            return this._children[t2];
          }
          getChildIndex(t2) {
            return this._children.indexOf(t2);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          *getAttributeKeys() {
            if (this._classes.size > 0) {
              yield "class";
            }
            if (!this._styles.isEmpty) {
              yield "style";
            }
            yield* this._attrs.keys();
          }
          *getAttributes() {
            yield* this._attrs.entries();
            if (this._classes.size > 0) {
              yield ["class", this.getAttribute("class")];
            }
            if (!this._styles.isEmpty) {
              yield ["style", this.getAttribute("style")];
            }
          }
          getAttribute(t2) {
            if (t2 == "class") {
              if (this._classes.size > 0) {
                return [...this._classes].join(" ");
              }
              return void 0;
            }
            if (t2 == "style") {
              const t3 = this._styles.toString();
              return t3 == "" ? void 0 : t3;
            }
            return this._attrs.get(t2);
          }
          hasAttribute(t2) {
            if (t2 == "class") {
              return this._classes.size > 0;
            }
            if (t2 == "style") {
              return !this._styles.isEmpty;
            }
            return this._attrs.has(t2);
          }
          isSimilar(t2) {
            if (!(t2 instanceof zc)) {
              return false;
            }
            if (this === t2) {
              return true;
            }
            if (this.name != t2.name) {
              return false;
            }
            if (this._attrs.size !== t2._attrs.size || this._classes.size !== t2._classes.size || this._styles.size !== t2._styles.size) {
              return false;
            }
            for (const [e2, i2] of this._attrs) {
              if (!t2._attrs.has(e2) || t2._attrs.get(e2) !== i2) {
                return false;
              }
            }
            for (const e2 of this._classes) {
              if (!t2._classes.has(e2)) {
                return false;
              }
            }
            for (const e2 of this._styles.getStyleNames()) {
              if (!t2._styles.has(e2) || t2._styles.getAsString(e2) !== this._styles.getAsString(e2)) {
                return false;
              }
            }
            return true;
          }
          hasClass(...t2) {
            for (const e2 of t2) {
              if (!this._classes.has(e2)) {
                return false;
              }
            }
            return true;
          }
          getClassNames() {
            return this._classes.keys();
          }
          getStyle(t2) {
            return this._styles.getAsString(t2);
          }
          getNormalizedStyle(t2) {
            return this._styles.getNormalized(t2);
          }
          getStyleNames() {
            return this._styles.getStyleNames();
          }
          hasStyle(...t2) {
            for (const e2 of t2) {
              if (!this._styles.has(e2)) {
                return false;
              }
            }
            return true;
          }
          findAncestor(...t2) {
            const e2 = new Ws(...t2);
            let i2 = this.parent;
            while (i2) {
              if (e2.match(i2)) {
                return i2;
              }
              i2 = i2.parent;
            }
            return null;
          }
          getCustomProperty(t2) {
            return this._customProperties.get(t2);
          }
          *getCustomProperties() {
            yield* this._customProperties.entries();
          }
          getIdentity() {
            const t2 = Array.from(this._classes).sort().join(",");
            const e2 = this._styles.toString();
            const i2 = Array.from(this._attrs).map((t3) => `${t3[0]}="${t3[1]}"`).sort().join(" ");
            return this.name + (t2 == "" ? "" : ` class="${t2}"`) + (!e2 ? "" : ` style="${e2}"`) + (i2 == "" ? "" : ` ${i2}`);
          }
          _clone(t2 = false) {
            const e2 = [];
            if (t2) {
              for (const i3 of this.getChildren()) {
                e2.push(i3._clone(t2));
              }
            }
            const i2 = new this.constructor(this.document, this.name, this._attrs, e2);
            i2._classes = new Set(this._classes);
            i2._styles.set(this._styles.getNormalized());
            i2._customProperties = new Map(this._customProperties);
            i2.getFillerOffset = this.getFillerOffset;
            return i2;
          }
          _appendChild(t2) {
            return this._insertChild(this.childCount, t2);
          }
          _insertChild(t2, e2) {
            this._fireChange("children", this);
            let i2 = 0;
            const n2 = Dc(this.document, e2);
            for (const e3 of n2) {
              if (e3.parent !== null) {
                e3._remove();
              }
              e3.parent = this;
              e3.document = this.document;
              this._children.splice(t2, 0, e3);
              t2++;
              i2++;
            }
            return i2;
          }
          _removeChildren(t2, e2 = 1) {
            this._fireChange("children", this);
            for (let i2 = t2; i2 < t2 + e2; i2++) {
              this._children[i2].parent = null;
            }
            return this._children.splice(t2, e2);
          }
          _setAttribute(t2, e2) {
            e2 = String(e2);
            this._fireChange("attributes", this);
            if (t2 == "class") {
              Fc(this._classes, e2);
            } else if (t2 == "style") {
              this._styles.setTo(e2);
            } else {
              this._attrs.set(t2, e2);
            }
          }
          _removeAttribute(t2) {
            this._fireChange("attributes", this);
            if (t2 == "class") {
              if (this._classes.size > 0) {
                this._classes.clear();
                return true;
              }
              return false;
            }
            if (t2 == "style") {
              if (!this._styles.isEmpty) {
                this._styles.clear();
                return true;
              }
              return false;
            }
            return this._attrs.delete(t2);
          }
          _addClass(t2) {
            this._fireChange("attributes", this);
            t2 = Array.isArray(t2) ? t2 : [t2];
            t2.forEach((t3) => this._classes.add(t3));
          }
          _removeClass(t2) {
            this._fireChange("attributes", this);
            t2 = Array.isArray(t2) ? t2 : [t2];
            t2.forEach((t3) => this._classes.delete(t3));
          }
          _setStyle(t2, e2) {
            this._fireChange("attributes", this);
            this._styles.set(t2, e2);
          }
          _removeStyle(t2) {
            this._fireChange("attributes", this);
            t2 = Array.isArray(t2) ? t2 : [t2];
            t2.forEach((t3) => this._styles.remove(t3));
          }
          _setCustomProperty(t2, e2) {
            this._customProperties.set(t2, e2);
          }
          _removeCustomProperty(t2) {
            return this._customProperties.delete(t2);
          }
        }
        function Lc(t2) {
          t2 = Hs(t2);
          for (const [e2, i2] of t2) {
            if (i2 === null) {
              t2.delete(e2);
            } else if (typeof i2 != "string") {
              t2.set(e2, String(i2));
            }
          }
          return t2;
        }
        function Fc(t2, e2) {
          const i2 = e2.split(/\s+/);
          t2.clear();
          i2.forEach((e3) => t2.add(e3));
        }
        function Dc(t2, e2) {
          if (typeof e2 == "string") {
            return [new Ls(t2, e2)];
          }
          if (!js(e2)) {
            e2 = [e2];
          }
          return Array.from(e2).map((e3) => {
            if (typeof e3 == "string") {
              return new Ls(t2, e3);
            }
            if (e3 instanceof Fs) {
              return new Ls(t2, e3.data);
            }
            return e3;
          });
        }
        class jc extends zc {
          constructor(t2, e2, i2, n2) {
            super(t2, e2, i2, n2);
            this.getFillerOffset = Hc;
          }
          is(t2, e2 = null) {
            const i2 = t2 && t2.replace(/^view:/, "");
            if (!e2) {
              return i2 == "containerElement" || super.is(t2);
            } else {
              return i2 == "containerElement" && e2 == this.name || super.is(t2, e2);
            }
          }
        }
        function Hc() {
          const t2 = [...this.getChildren()];
          const e2 = t2[this.childCount - 1];
          if (e2 && e2.is("element", "br")) {
            return this.childCount;
          }
          for (const e3 of t2) {
            if (!e3.is("uiElement")) {
              return null;
            }
          }
          return this.childCount;
        }
        var Wc = Ac(function(t2, e2) {
          ze(e2, dn(e2), t2);
        });
        var qc = Wc;
        const Uc = Symbol("observableProperties");
        const $c = Symbol("boundObservables");
        const Gc = Symbol("boundProperties");
        const Kc = {
          set(t2, e2) {
            if (ct(t2)) {
              Object.keys(t2).forEach((e3) => {
                this.set(e3, t2[e3]);
              }, this);
              return;
            }
            Yc(this);
            const i2 = this[Uc];
            if (t2 in this && !i2.has(t2)) {
              throw new ss["b"]("observable-set-cannot-override: Cannot override an existing property.", this);
            }
            Object.defineProperty(this, t2, {
              enumerable: true,
              configurable: true,
              get() {
                return i2.get(t2);
              },
              set(e3) {
                const n2 = i2.get(t2);
                let o2 = this.fire("set:" + t2, t2, e3, n2);
                if (o2 === void 0) {
                  o2 = e3;
                }
                if (n2 !== o2 || !i2.has(t2)) {
                  i2.set(t2, o2);
                  this.fire("change:" + t2, t2, o2, n2);
                }
              }
            });
            this[t2] = e2;
          },
          bind(...t2) {
            if (!t2.length || !tl(t2)) {
              throw new ss["b"]("observable-bind-wrong-properties: All properties must be strings.", this);
            }
            if (new Set(t2).size !== t2.length) {
              throw new ss["b"]("observable-bind-duplicate-properties: Properties must be unique.", this);
            }
            Yc(this);
            const e2 = this[Gc];
            t2.forEach((t3) => {
              if (e2.has(t3)) {
                throw new ss["b"]("observable-bind-rebind: Cannot bind the same property more than once.", this);
              }
            });
            const i2 = new Map();
            t2.forEach((t3) => {
              const n2 = {property: t3, to: []};
              e2.set(t3, n2);
              i2.set(t3, n2);
            });
            return {to: Qc, toMany: Xc, _observable: this, _bindProperties: t2, _to: [], _bindings: i2};
          },
          unbind(...t2) {
            if (!(Uc in this)) {
              return;
            }
            const e2 = this[Gc];
            const i2 = this[$c];
            if (t2.length) {
              if (!tl(t2)) {
                throw new ss["b"]("observable-unbind-wrong-properties: Properties must be strings.", this);
              }
              t2.forEach((t3) => {
                const n2 = e2.get(t3);
                if (!n2) {
                  return;
                }
                let o2, r2, s2, a2;
                n2.to.forEach((t4) => {
                  o2 = t4[0];
                  r2 = t4[1];
                  s2 = i2.get(o2);
                  a2 = s2[r2];
                  a2.delete(n2);
                  if (!a2.size) {
                    delete s2[r2];
                  }
                  if (!Object.keys(s2).length) {
                    i2.delete(o2);
                    this.stopListening(o2, "change");
                  }
                });
                e2.delete(t3);
              });
            } else {
              i2.forEach((t3, e3) => {
                this.stopListening(e3, "change");
              });
              i2.clear();
              e2.clear();
            }
          },
          decorate(t2) {
            const e2 = this[t2];
            if (!e2) {
              throw new ss["b"]("observablemixin-cannot-decorate-undefined: Cannot decorate an undefined method.", this, {
                object: this,
                methodName: t2
              });
            }
            this.on(t2, (t3, i2) => {
              t3.return = e2.apply(this, i2);
            });
            this[t2] = function(...e3) {
              return this.fire(t2, e3);
            };
          }
        };
        qc(Kc, ds);
        var Jc = Kc;
        function Yc(t2) {
          if (Uc in t2) {
            return;
          }
          Object.defineProperty(t2, Uc, {value: new Map()});
          Object.defineProperty(t2, $c, {value: new Map()});
          Object.defineProperty(t2, Gc, {value: new Map()});
        }
        function Qc(...t2) {
          const e2 = el(...t2);
          const i2 = Array.from(this._bindings.keys());
          const n2 = i2.length;
          if (!e2.callback && e2.to.length > 1) {
            throw new ss["b"]("observable-bind-to-no-callback: Binding multiple observables only possible with callback.", this);
          }
          if (n2 > 1 && e2.callback) {
            throw new ss["b"]("observable-bind-to-extra-callback: Cannot bind multiple properties and use a callback in one binding.", this);
          }
          e2.to.forEach((t3) => {
            if (t3.properties.length && t3.properties.length !== n2) {
              throw new ss["b"]("observable-bind-to-properties-length: The number of properties must match.", this);
            }
            if (!t3.properties.length) {
              t3.properties = this._bindProperties;
            }
          });
          this._to = e2.to;
          if (e2.callback) {
            this._bindings.get(i2[0]).callback = e2.callback;
          }
          rl(this._observable, this._to);
          nl(this);
          this._bindProperties.forEach((t3) => {
            ol(this._observable, t3);
          });
        }
        function Xc(t2, e2, i2) {
          if (this._bindings.size > 1) {
            throw new ss["b"]("observable-bind-to-many-not-one-binding: Cannot bind multiple properties with toMany().", this);
          }
          this.to(...Zc(t2, e2), i2);
        }
        function Zc(t2, e2) {
          const i2 = t2.map((t3) => [t3, e2]);
          return Array.prototype.concat.apply([], i2);
        }
        function tl(t2) {
          return t2.every((t3) => typeof t3 == "string");
        }
        function el(...t2) {
          if (!t2.length) {
            throw new ss["b"]("observable-bind-to-parse-error: Invalid argument syntax in `to()`.", null);
          }
          const e2 = {to: []};
          let i2;
          if (typeof t2[t2.length - 1] == "function") {
            e2.callback = t2.pop();
          }
          t2.forEach((t3) => {
            if (typeof t3 == "string") {
              i2.properties.push(t3);
            } else if (typeof t3 == "object") {
              i2 = {observable: t3, properties: []};
              e2.to.push(i2);
            } else {
              throw new ss["b"]("observable-bind-to-parse-error: Invalid argument syntax in `to()`.", null);
            }
          });
          return e2;
        }
        function il(t2, e2, i2, n2) {
          const o2 = t2[$c];
          const r2 = o2.get(i2);
          const s2 = r2 || {};
          if (!s2[n2]) {
            s2[n2] = new Set();
          }
          s2[n2].add(e2);
          if (!r2) {
            o2.set(i2, s2);
          }
        }
        function nl(t2) {
          let e2;
          t2._bindings.forEach((i2, n2) => {
            t2._to.forEach((o2) => {
              e2 = o2.properties[i2.callback ? 0 : t2._bindProperties.indexOf(n2)];
              i2.to.push([o2.observable, e2]);
              il(t2._observable, i2, o2.observable, e2);
            });
          });
        }
        function ol(t2, e2) {
          const i2 = t2[Gc];
          const n2 = i2.get(e2);
          let o2;
          if (n2.callback) {
            o2 = n2.callback.apply(t2, n2.to.map((t3) => t3[0][t3[1]]));
          } else {
            o2 = n2.to[0];
            o2 = o2[0][o2[1]];
          }
          if (t2.hasOwnProperty(e2)) {
            t2[e2] = o2;
          } else {
            t2.set(e2, o2);
          }
        }
        function rl(t2, e2) {
          e2.forEach((e3) => {
            const i2 = t2[$c];
            let n2;
            if (!i2.get(e3.observable)) {
              t2.listenTo(e3.observable, "change", (o2, r2) => {
                n2 = i2.get(e3.observable)[r2];
                if (n2) {
                  n2.forEach((e4) => {
                    ol(t2, e4.property);
                  });
                }
              });
            }
          });
        }
        class sl extends jc {
          constructor(t2, e2, i2, n2) {
            super(t2, e2, i2, n2);
            this.set("isReadOnly", false);
            this.set("isFocused", false);
            this.bind("isReadOnly").to(t2);
            this.bind("isFocused").to(t2, "isFocused", (e3) => e3 && t2.selection.editableElement == this);
            this.listenTo(t2.selection, "change", () => {
              this.isFocused = t2.isFocused && t2.selection.editableElement == this;
            });
          }
          is(t2, e2 = null) {
            const i2 = t2 && t2.replace(/^view:/, "");
            if (!e2) {
              return i2 == "editableElement" || super.is(t2);
            } else {
              return i2 == "editableElement" && e2 == this.name || super.is(t2, e2);
            }
          }
          destroy() {
            this.stopListening();
          }
        }
        vs(sl, Jc);
        const al = Symbol("rootName");
        class cl extends sl {
          constructor(t2, e2) {
            super(t2, e2);
            this.rootName = "main";
          }
          is(t2, e2 = null) {
            const i2 = t2.replace(/^view:/, "");
            if (!e2) {
              return i2 == "rootElement" || super.is(t2);
            } else {
              return i2 == "rootElement" && e2 == this.name || super.is(t2, e2);
            }
          }
          get rootName() {
            return this.getCustomProperty(al);
          }
          set rootName(t2) {
            this._setCustomProperty(al, t2);
          }
          set _name(t2) {
            this.name = t2;
          }
        }
        class ll {
          constructor(t2 = {}) {
            if (!t2.boundaries && !t2.startPosition) {
              throw new ss["b"]("view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.", null);
            }
            if (t2.direction && t2.direction != "forward" && t2.direction != "backward") {
              throw new ss["b"]("view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.", t2.startPosition, {direction: t2.direction});
            }
            this.boundaries = t2.boundaries || null;
            if (t2.startPosition) {
              this.position = dl._createAt(t2.startPosition);
            } else {
              this.position = dl._createAt(t2.boundaries[t2.direction == "backward" ? "end" : "start"]);
            }
            this.direction = t2.direction || "forward";
            this.singleCharacters = !!t2.singleCharacters;
            this.shallow = !!t2.shallow;
            this.ignoreElementEnd = !!t2.ignoreElementEnd;
            this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
            this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
          }
          [Symbol.iterator]() {
            return this;
          }
          skip(t2) {
            let e2, i2, n2;
            do {
              n2 = this.position;
              ({done: e2, value: i2} = this.next());
            } while (!e2 && t2(i2));
            if (!e2) {
              this.position = n2;
            }
          }
          next() {
            if (this.direction == "forward") {
              return this._next();
            } else {
              return this._previous();
            }
          }
          _next() {
            let t2 = this.position.clone();
            const e2 = this.position;
            const i2 = t2.parent;
            if (i2.parent === null && t2.offset === i2.childCount) {
              return {done: true};
            }
            if (i2 === this._boundaryEndParent && t2.offset == this.boundaries.end.offset) {
              return {done: true};
            }
            let n2;
            if (i2 instanceof Ls) {
              if (t2.isAtEnd) {
                this.position = dl._createAfter(i2);
                return this._next();
              }
              n2 = i2.data[t2.offset];
            } else {
              n2 = i2.getChild(t2.offset);
            }
            if (n2 instanceof zc) {
              if (!this.shallow) {
                t2 = new dl(n2, 0);
              } else {
                t2.offset++;
              }
              this.position = t2;
              return this._formatReturnValue("elementStart", n2, e2, t2, 1);
            } else if (n2 instanceof Ls) {
              if (this.singleCharacters) {
                t2 = new dl(n2, 0);
                this.position = t2;
                return this._next();
              } else {
                let i3 = n2.data.length;
                let o2;
                if (n2 == this._boundaryEndParent) {
                  i3 = this.boundaries.end.offset;
                  o2 = new Fs(n2, 0, i3);
                  t2 = dl._createAfter(o2);
                } else {
                  o2 = new Fs(n2, 0, n2.data.length);
                  t2.offset++;
                }
                this.position = t2;
                return this._formatReturnValue("text", o2, e2, t2, i3);
              }
            } else if (typeof n2 == "string") {
              let n3;
              if (this.singleCharacters) {
                n3 = 1;
              } else {
                const e3 = i2 === this._boundaryEndParent ? this.boundaries.end.offset : i2.data.length;
                n3 = e3 - t2.offset;
              }
              const o2 = new Fs(i2, t2.offset, n3);
              t2.offset += n3;
              this.position = t2;
              return this._formatReturnValue("text", o2, e2, t2, n3);
            } else {
              t2 = dl._createAfter(i2);
              this.position = t2;
              if (this.ignoreElementEnd) {
                return this._next();
              } else {
                return this._formatReturnValue("elementEnd", i2, e2, t2);
              }
            }
          }
          _previous() {
            let t2 = this.position.clone();
            const e2 = this.position;
            const i2 = t2.parent;
            if (i2.parent === null && t2.offset === 0) {
              return {done: true};
            }
            if (i2 == this._boundaryStartParent && t2.offset == this.boundaries.start.offset) {
              return {done: true};
            }
            let n2;
            if (i2 instanceof Ls) {
              if (t2.isAtStart) {
                this.position = dl._createBefore(i2);
                return this._previous();
              }
              n2 = i2.data[t2.offset - 1];
            } else {
              n2 = i2.getChild(t2.offset - 1);
            }
            if (n2 instanceof zc) {
              if (!this.shallow) {
                t2 = new dl(n2, n2.childCount);
                this.position = t2;
                if (this.ignoreElementEnd) {
                  return this._previous();
                } else {
                  return this._formatReturnValue("elementEnd", n2, e2, t2);
                }
              } else {
                t2.offset--;
                this.position = t2;
                return this._formatReturnValue("elementStart", n2, e2, t2, 1);
              }
            } else if (n2 instanceof Ls) {
              if (this.singleCharacters) {
                t2 = new dl(n2, n2.data.length);
                this.position = t2;
                return this._previous();
              } else {
                let i3 = n2.data.length;
                let o2;
                if (n2 == this._boundaryStartParent) {
                  const e3 = this.boundaries.start.offset;
                  o2 = new Fs(n2, e3, n2.data.length - e3);
                  i3 = o2.data.length;
                  t2 = dl._createBefore(o2);
                } else {
                  o2 = new Fs(n2, 0, n2.data.length);
                  t2.offset--;
                }
                this.position = t2;
                return this._formatReturnValue("text", o2, e2, t2, i3);
              }
            } else if (typeof n2 == "string") {
              let n3;
              if (!this.singleCharacters) {
                const e3 = i2 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                n3 = t2.offset - e3;
              } else {
                n3 = 1;
              }
              t2.offset -= n3;
              const o2 = new Fs(i2, t2.offset, n3);
              this.position = t2;
              return this._formatReturnValue("text", o2, e2, t2, n3);
            } else {
              t2 = dl._createBefore(i2);
              this.position = t2;
              return this._formatReturnValue("elementStart", i2, e2, t2, 1);
            }
          }
          _formatReturnValue(t2, e2, i2, n2, o2) {
            if (e2 instanceof Fs) {
              if (e2.offsetInText + e2.data.length == e2.textNode.data.length) {
                if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
                  n2 = dl._createAfter(e2.textNode);
                  this.position = n2;
                } else {
                  i2 = dl._createAfter(e2.textNode);
                }
              }
              if (e2.offsetInText === 0) {
                if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
                  n2 = dl._createBefore(e2.textNode);
                  this.position = n2;
                } else {
                  i2 = dl._createBefore(e2.textNode);
                }
              }
            }
            return {done: false, value: {type: t2, item: e2, previousPosition: i2, nextPosition: n2, length: o2}};
          }
        }
        class dl {
          constructor(t2, e2) {
            this.parent = t2;
            this.offset = e2;
          }
          get nodeAfter() {
            if (this.parent.is("text")) {
              return null;
            }
            return this.parent.getChild(this.offset) || null;
          }
          get nodeBefore() {
            if (this.parent.is("text")) {
              return null;
            }
            return this.parent.getChild(this.offset - 1) || null;
          }
          get isAtStart() {
            return this.offset === 0;
          }
          get isAtEnd() {
            const t2 = this.parent.is("text") ? this.parent.data.length : this.parent.childCount;
            return this.offset === t2;
          }
          get root() {
            return this.parent.root;
          }
          get editableElement() {
            let t2 = this.parent;
            while (!(t2 instanceof sl)) {
              if (t2.parent) {
                t2 = t2.parent;
              } else {
                return null;
              }
            }
            return t2;
          }
          getShiftedBy(t2) {
            const e2 = dl._createAt(this);
            const i2 = e2.offset + t2;
            e2.offset = i2 < 0 ? 0 : i2;
            return e2;
          }
          getLastMatchingPosition(t2, e2 = {}) {
            e2.startPosition = this;
            const i2 = new ll(e2);
            i2.skip(t2);
            return i2.position;
          }
          getAncestors() {
            if (this.parent.is("documentFragment")) {
              return [this.parent];
            } else {
              return this.parent.getAncestors({includeSelf: true});
            }
          }
          getCommonAncestor(t2) {
            const e2 = this.getAncestors();
            const i2 = t2.getAncestors();
            let n2 = 0;
            while (e2[n2] == i2[n2] && e2[n2]) {
              n2++;
            }
            return n2 === 0 ? null : e2[n2 - 1];
          }
          is(t2) {
            return t2 == "position" || t2 == "view:position";
          }
          isEqual(t2) {
            return this.parent == t2.parent && this.offset == t2.offset;
          }
          isBefore(t2) {
            return this.compareWith(t2) == "before";
          }
          isAfter(t2) {
            return this.compareWith(t2) == "after";
          }
          compareWith(t2) {
            if (this.root !== t2.root) {
              return "different";
            }
            if (this.isEqual(t2)) {
              return "same";
            }
            const e2 = this.parent.is("node") ? this.parent.getPath() : [];
            const i2 = t2.parent.is("node") ? t2.parent.getPath() : [];
            e2.push(this.offset);
            i2.push(t2.offset);
            const n2 = Vs(e2, i2);
            switch (n2) {
              case "prefix":
                return "before";
              case "extension":
                return "after";
              default:
                return e2[n2] < i2[n2] ? "before" : "after";
            }
          }
          getWalker(t2 = {}) {
            t2.startPosition = this;
            return new ll(t2);
          }
          clone() {
            return new dl(this.parent, this.offset);
          }
          static _createAt(t2, e2) {
            if (t2 instanceof dl) {
              return new this(t2.parent, t2.offset);
            } else {
              const i2 = t2;
              if (e2 == "end") {
                e2 = i2.is("text") ? i2.data.length : i2.childCount;
              } else if (e2 == "before") {
                return this._createBefore(i2);
              } else if (e2 == "after") {
                return this._createAfter(i2);
              } else if (e2 !== 0 && !e2) {
                throw new ss["b"]("view-createPositionAt-offset-required: View#createPositionAt() requires the offset when the first parameter is a view item.", i2);
              }
              return new dl(i2, e2);
            }
          }
          static _createAfter(t2) {
            if (t2.is("textProxy")) {
              return new dl(t2.textNode, t2.offsetInText + t2.data.length);
            }
            if (!t2.parent) {
              throw new ss["b"]("view-position-after-root: You can not make position after root.", t2, {root: t2});
            }
            return new dl(t2.parent, t2.index + 1);
          }
          static _createBefore(t2) {
            if (t2.is("textProxy")) {
              return new dl(t2.textNode, t2.offsetInText);
            }
            if (!t2.parent) {
              throw new ss["b"]("view-position-before-root: You can not make position before root.", t2, {root: t2});
            }
            return new dl(t2.parent, t2.index);
          }
        }
        class ul {
          constructor(t2, e2 = null) {
            this.start = t2.clone();
            this.end = e2 ? e2.clone() : t2.clone();
          }
          *[Symbol.iterator]() {
            yield* new ll({boundaries: this, ignoreElementEnd: true});
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return this.start.parent === this.end.parent;
          }
          get root() {
            return this.start.root;
          }
          getEnlarged() {
            let t2 = this.start.getLastMatchingPosition(hl, {direction: "backward"});
            let e2 = this.end.getLastMatchingPosition(hl);
            if (t2.parent.is("text") && t2.isAtStart) {
              t2 = dl._createBefore(t2.parent);
            }
            if (e2.parent.is("text") && e2.isAtEnd) {
              e2 = dl._createAfter(e2.parent);
            }
            return new ul(t2, e2);
          }
          getTrimmed() {
            let t2 = this.start.getLastMatchingPosition(hl);
            if (t2.isAfter(this.end) || t2.isEqual(this.end)) {
              return new ul(t2, t2);
            }
            let e2 = this.end.getLastMatchingPosition(hl, {direction: "backward"});
            const i2 = t2.nodeAfter;
            const n2 = e2.nodeBefore;
            if (i2 && i2.is("text")) {
              t2 = new dl(i2, 0);
            }
            if (n2 && n2.is("text")) {
              e2 = new dl(n2, n2.data.length);
            }
            return new ul(t2, e2);
          }
          isEqual(t2) {
            return this == t2 || this.start.isEqual(t2.start) && this.end.isEqual(t2.end);
          }
          containsPosition(t2) {
            return t2.isAfter(this.start) && t2.isBefore(this.end);
          }
          containsRange(t2, e2 = false) {
            if (t2.isCollapsed) {
              e2 = false;
            }
            const i2 = this.containsPosition(t2.start) || e2 && this.start.isEqual(t2.start);
            const n2 = this.containsPosition(t2.end) || e2 && this.end.isEqual(t2.end);
            return i2 && n2;
          }
          getDifference(t2) {
            const e2 = [];
            if (this.isIntersecting(t2)) {
              if (this.containsPosition(t2.start)) {
                e2.push(new ul(this.start, t2.start));
              }
              if (this.containsPosition(t2.end)) {
                e2.push(new ul(t2.end, this.end));
              }
            } else {
              e2.push(this.clone());
            }
            return e2;
          }
          getIntersection(t2) {
            if (this.isIntersecting(t2)) {
              let e2 = this.start;
              let i2 = this.end;
              if (this.containsPosition(t2.start)) {
                e2 = t2.start;
              }
              if (this.containsPosition(t2.end)) {
                i2 = t2.end;
              }
              return new ul(e2, i2);
            }
            return null;
          }
          getWalker(t2 = {}) {
            t2.boundaries = this;
            return new ll(t2);
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed) {
              return null;
            }
            let t2 = this.start.nodeAfter;
            let e2 = this.end.nodeBefore;
            if (this.start.parent.is("text") && this.start.isAtEnd && this.start.parent.nextSibling) {
              t2 = this.start.parent.nextSibling;
            }
            if (this.end.parent.is("text") && this.end.isAtStart && this.end.parent.previousSibling) {
              e2 = this.end.parent.previousSibling;
            }
            if (t2 && t2.is("element") && t2 === e2) {
              return t2;
            }
            return null;
          }
          clone() {
            return new ul(this.start, this.end);
          }
          *getItems(t2 = {}) {
            t2.boundaries = this;
            t2.ignoreElementEnd = true;
            const e2 = new ll(t2);
            for (const t3 of e2) {
              yield t3.item;
            }
          }
          *getPositions(t2 = {}) {
            t2.boundaries = this;
            const e2 = new ll(t2);
            yield e2.position;
            for (const t3 of e2) {
              yield t3.nextPosition;
            }
          }
          is(t2) {
            return t2 == "range" || t2 == "view:range";
          }
          isIntersecting(t2) {
            return this.start.isBefore(t2.end) && this.end.isAfter(t2.start);
          }
          static _createFromParentsAndOffsets(t2, e2, i2, n2) {
            return new this(new dl(t2, e2), new dl(i2, n2));
          }
          static _createFromPositionAndShift(t2, e2) {
            const i2 = t2;
            const n2 = t2.getShiftedBy(e2);
            return e2 > 0 ? new this(i2, n2) : new this(n2, i2);
          }
          static _createIn(t2) {
            return this._createFromParentsAndOffsets(t2, 0, t2, t2.childCount);
          }
          static _createOn(t2) {
            const e2 = t2.is("textProxy") ? t2.offsetSize : 1;
            return this._createFromPositionAndShift(dl._createBefore(t2), e2);
          }
        }
        function hl(t2) {
          if (t2.item.is("attributeElement") || t2.item.is("uiElement")) {
            return true;
          }
          return false;
        }
        function fl(t2) {
          let e2 = 0;
          for (const i2 of t2) {
            e2++;
          }
          return e2;
        }
        class gl {
          constructor(t2 = null, e2, i2) {
            this._ranges = [];
            this._lastRangeBackward = false;
            this._isFake = false;
            this._fakeSelectionLabel = "";
            this.setTo(t2, e2, i2);
          }
          get isFake() {
            return this._isFake;
          }
          get fakeSelectionLabel() {
            return this._fakeSelectionLabel;
          }
          get anchor() {
            if (!this._ranges.length) {
              return null;
            }
            const t2 = this._ranges[this._ranges.length - 1];
            const e2 = this._lastRangeBackward ? t2.end : t2.start;
            return e2.clone();
          }
          get focus() {
            if (!this._ranges.length) {
              return null;
            }
            const t2 = this._ranges[this._ranges.length - 1];
            const e2 = this._lastRangeBackward ? t2.start : t2.end;
            return e2.clone();
          }
          get isCollapsed() {
            return this.rangeCount === 1 && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          get editableElement() {
            if (this.anchor) {
              return this.anchor.editableElement;
            }
            return null;
          }
          *getRanges() {
            for (const t2 of this._ranges) {
              yield t2.clone();
            }
          }
          getFirstRange() {
            let t2 = null;
            for (const e2 of this._ranges) {
              if (!t2 || e2.start.isBefore(t2.start)) {
                t2 = e2;
              }
            }
            return t2 ? t2.clone() : null;
          }
          getLastRange() {
            let t2 = null;
            for (const e2 of this._ranges) {
              if (!t2 || e2.end.isAfter(t2.end)) {
                t2 = e2;
              }
            }
            return t2 ? t2.clone() : null;
          }
          getFirstPosition() {
            const t2 = this.getFirstRange();
            return t2 ? t2.start.clone() : null;
          }
          getLastPosition() {
            const t2 = this.getLastRange();
            return t2 ? t2.end.clone() : null;
          }
          isEqual(t2) {
            if (this.isFake != t2.isFake) {
              return false;
            }
            if (this.isFake && this.fakeSelectionLabel != t2.fakeSelectionLabel) {
              return false;
            }
            if (this.rangeCount != t2.rangeCount) {
              return false;
            } else if (this.rangeCount === 0) {
              return true;
            }
            if (!this.anchor.isEqual(t2.anchor) || !this.focus.isEqual(t2.focus)) {
              return false;
            }
            for (const e2 of this._ranges) {
              let i2 = false;
              for (const n2 of t2._ranges) {
                if (e2.isEqual(n2)) {
                  i2 = true;
                  break;
                }
              }
              if (!i2) {
                return false;
              }
            }
            return true;
          }
          isSimilar(t2) {
            if (this.isBackward != t2.isBackward) {
              return false;
            }
            const e2 = fl(this.getRanges());
            const i2 = fl(t2.getRanges());
            if (e2 != i2) {
              return false;
            }
            if (e2 == 0) {
              return true;
            }
            for (let e3 of this.getRanges()) {
              e3 = e3.getTrimmed();
              let i3 = false;
              for (let n2 of t2.getRanges()) {
                n2 = n2.getTrimmed();
                if (e3.start.isEqual(n2.start) && e3.end.isEqual(n2.end)) {
                  i3 = true;
                  break;
                }
              }
              if (!i3) {
                return false;
              }
            }
            return true;
          }
          getSelectedElement() {
            if (this.rangeCount !== 1) {
              return null;
            }
            return this.getFirstRange().getContainedElement();
          }
          setTo(t2, e2, i2) {
            if (t2 === null) {
              this._setRanges([]);
              this._setFakeOptions(e2);
            } else if (t2 instanceof gl || t2 instanceof ml) {
              this._setRanges(t2.getRanges(), t2.isBackward);
              this._setFakeOptions({fake: t2.isFake, label: t2.fakeSelectionLabel});
            } else if (t2 instanceof ul) {
              this._setRanges([t2], e2 && e2.backward);
              this._setFakeOptions(e2);
            } else if (t2 instanceof dl) {
              this._setRanges([new ul(t2)]);
              this._setFakeOptions(e2);
            } else if (t2 instanceof zs) {
              const n2 = !!i2 && !!i2.backward;
              let o2;
              if (e2 === void 0) {
                throw new ss["b"]("view-selection-setTo-required-second-parameter: selection.setTo requires the second parameter when the first parameter is a node.", this);
              } else if (e2 == "in") {
                o2 = ul._createIn(t2);
              } else if (e2 == "on") {
                o2 = ul._createOn(t2);
              } else {
                o2 = new ul(dl._createAt(t2, e2));
              }
              this._setRanges([o2], n2);
              this._setFakeOptions(i2);
            } else if (js(t2)) {
              this._setRanges(t2, e2 && e2.backward);
              this._setFakeOptions(e2);
            } else {
              throw new ss["b"]("view-selection-setTo-not-selectable: Cannot set selection to given place.", this);
            }
            this.fire("change");
          }
          setFocus(t2, e2) {
            if (this.anchor === null) {
              throw new ss["b"]("view-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.", this);
            }
            const i2 = dl._createAt(t2, e2);
            if (i2.compareWith(this.focus) == "same") {
              return;
            }
            const n2 = this.anchor;
            this._ranges.pop();
            if (i2.compareWith(n2) == "before") {
              this._addRange(new ul(i2, n2), true);
            } else {
              this._addRange(new ul(n2, i2));
            }
            this.fire("change");
          }
          is(t2) {
            return t2 == "selection" || t2 == "view:selection";
          }
          _setRanges(t2, e2 = false) {
            t2 = Array.from(t2);
            this._ranges = [];
            for (const e3 of t2) {
              this._addRange(e3);
            }
            this._lastRangeBackward = !!e2;
          }
          _setFakeOptions(t2 = {}) {
            this._isFake = !!t2.fake;
            this._fakeSelectionLabel = t2.fake ? t2.label || "" : "";
          }
          _addRange(t2, e2 = false) {
            if (!(t2 instanceof ul)) {
              throw new ss["b"]("view-selection-add-range-not-range: Selection range set to an object that is not an instance of view.Range", this);
            }
            this._pushRange(t2);
            this._lastRangeBackward = !!e2;
          }
          _pushRange(t2) {
            for (const e2 of this._ranges) {
              if (t2.isIntersecting(e2)) {
                throw new ss["b"]("view-selection-range-intersects: Trying to add a range that intersects with another range from selection.", this, {
                  addedRange: t2,
                  intersectingRange: e2
                });
              }
            }
            this._ranges.push(new ul(t2.start, t2.end));
          }
        }
        vs(gl, ds);
        class ml {
          constructor(t2 = null, e2, i2) {
            this._selection = new gl();
            this._selection.delegate("change").to(this);
            this._selection.setTo(t2, e2, i2);
          }
          get isFake() {
            return this._selection.isFake;
          }
          get fakeSelectionLabel() {
            return this._selection.fakeSelectionLabel;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get editableElement() {
            return this._selection.editableElement;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          *getRanges() {
            yield* this._selection.getRanges();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          isEqual(t2) {
            return this._selection.isEqual(t2);
          }
          isSimilar(t2) {
            return this._selection.isSimilar(t2);
          }
          is(t2) {
            return t2 == "selection" || t2 == "documentSelection" || t2 == "view:selection" || t2 == "view:documentSelection";
          }
          _setTo(t2, e2, i2) {
            this._selection.setTo(t2, e2, i2);
          }
          _setFocus(t2, e2) {
            this._selection.setFocus(t2, e2);
          }
        }
        vs(ml, ds);
        class pl {
          constructor(t2) {
            this.selection = new ml();
            this.roots = new ys({idProperty: "rootName"});
            this.stylesProcessor = t2;
            this.set("isReadOnly", false);
            this.set("isFocused", false);
            this.set("isComposing", false);
            this._postFixers = new Set();
          }
          getRoot(t2 = "main") {
            return this.roots.get(t2);
          }
          registerPostFixer(t2) {
            this._postFixers.add(t2);
          }
          destroy() {
            this.roots.map((t2) => t2.destroy());
            this.stopListening();
          }
          _callPostFixers(t2) {
            let e2 = false;
            do {
              for (const i2 of this._postFixers) {
                e2 = i2(t2);
                if (e2) {
                  break;
                }
              }
            } while (e2);
          }
        }
        vs(pl, Jc);
        const bl = 10;
        class wl extends zc {
          constructor(t2, e2, i2, n2) {
            super(t2, e2, i2, n2);
            this.getFillerOffset = kl;
            this._priority = bl;
            this._id = null;
            this._clonesGroup = null;
          }
          get priority() {
            return this._priority;
          }
          get id() {
            return this._id;
          }
          getElementsWithSameId() {
            if (this.id === null) {
              throw new ss["b"]("attribute-element-get-elements-with-same-id-no-id: Cannot get elements with the same id for an attribute element without id.", this);
            }
            return new Set(this._clonesGroup);
          }
          is(t2, e2 = null) {
            const i2 = t2 && t2.replace(/^view:/, "");
            if (!e2) {
              return i2 == "attributeElement" || super.is(t2);
            } else {
              return i2 == "attributeElement" && e2 == this.name || super.is(t2, e2);
            }
          }
          isSimilar(t2) {
            if (this.id !== null || t2.id !== null) {
              return this.id === t2.id;
            }
            return super.isSimilar(t2) && this.priority == t2.priority;
          }
          _clone(t2) {
            const e2 = super._clone(t2);
            e2._priority = this._priority;
            e2._id = this._id;
            return e2;
          }
        }
        wl.DEFAULT_PRIORITY = bl;
        function kl() {
          if (_l(this)) {
            return null;
          }
          let t2 = this.parent;
          while (t2 && t2.is("attributeElement")) {
            if (_l(t2) > 1) {
              return null;
            }
            t2 = t2.parent;
          }
          if (!t2 || _l(t2) > 1) {
            return null;
          }
          return this.childCount;
        }
        function _l(t2) {
          return Array.from(t2.getChildren()).filter((t3) => !t3.is("uiElement")).length;
        }
        class vl extends zc {
          constructor(t2, e2, i2, n2) {
            super(t2, e2, i2, n2);
            this.getFillerOffset = yl;
          }
          is(t2, e2 = null) {
            const i2 = t2.replace(/^view:/, "");
            if (!e2) {
              return i2 == "emptyElement" || super.is(t2);
            } else {
              return i2 == "emptyElement" && e2 == this.name || super.is(t2, e2);
            }
          }
          _insertChild(t2, e2) {
            if (e2 && (e2 instanceof zs || Array.from(e2).length > 0)) {
              throw new ss["b"]("view-emptyelement-cannot-add: Cannot add child nodes to EmptyElement instance.", [this, e2]);
            }
          }
        }
        function yl() {
          return null;
        }
        const xl = navigator.userAgent.toLowerCase();
        const Cl = {
          isMac: Tl(xl),
          isEdge: Pl(xl),
          isGecko: Sl(xl),
          isSafari: El(xl),
          isAndroid: Rl(xl),
          features: {isRegExpUnicodePropertySupported: Ol()}
        };
        var Al = Cl;
        function Tl(t2) {
          return t2.indexOf("macintosh") > -1;
        }
        function Pl(t2) {
          return !!t2.match(/edge\/(\d+.?\d*)/);
        }
        function Sl(t2) {
          return !!t2.match(/gecko\/\d+/);
        }
        function El(t2) {
          return t2.indexOf(" applewebkit/") > -1 && t2.indexOf("chrome") === -1;
        }
        function Rl(t2) {
          return t2.indexOf("android") > -1;
        }
        function Ol() {
          let t2 = false;
          try {
            t2 = "\u0107".search(new RegExp("[\\p{L}]", "u")) === 0;
          } catch (t3) {
          }
          return t2;
        }
        const Il = {"\u2318": "ctrl", "\u21E7": "shift", "\u2325": "alt"};
        const Vl = {ctrl: "\u2318", shift: "\u21E7", alt: "\u2325"};
        const Nl = Ll();
        function Ml(t2) {
          let e2;
          if (typeof t2 == "string") {
            e2 = Nl[t2.toLowerCase()];
            if (!e2) {
              throw new ss["b"]("keyboard-unknown-key: Unknown key name.", null, {key: t2});
            }
          } else {
            e2 = t2.keyCode + (t2.altKey ? Nl.alt : 0) + (t2.ctrlKey ? Nl.ctrl : 0) + (t2.shiftKey ? Nl.shift : 0);
          }
          return e2;
        }
        function Bl(t2) {
          if (typeof t2 == "string") {
            t2 = Fl(t2);
          }
          return t2.map((t3) => typeof t3 == "string" ? Ml(t3) : t3).reduce((t3, e2) => e2 + t3, 0);
        }
        function zl(t2) {
          if (!Al.isMac) {
            return t2;
          }
          return Fl(t2).map((t3) => Vl[t3.toLowerCase()] || t3).reduce((t3, e2) => {
            if (t3.slice(-1) in Il) {
              return t3 + e2;
            } else {
              return t3 + "+" + e2;
            }
          });
        }
        function Ll() {
          const t2 = {
            arrowleft: 37,
            arrowup: 38,
            arrowright: 39,
            arrowdown: 40,
            backspace: 8,
            delete: 46,
            enter: 13,
            space: 32,
            esc: 27,
            tab: 9,
            ctrl: 1114112,
            cmd: 1114112,
            shift: 2228224,
            alt: 4456448
          };
          for (let e2 = 65; e2 <= 90; e2++) {
            const i2 = String.fromCharCode(e2);
            t2[i2.toLowerCase()] = e2;
          }
          for (let e2 = 48; e2 <= 57; e2++) {
            t2[e2 - 48] = e2;
          }
          for (let e2 = 112; e2 <= 123; e2++) {
            t2["f" + (e2 - 111)] = e2;
          }
          return t2;
        }
        function Fl(t2) {
          return t2.split(/\s*\+\s*/);
        }
        class Dl extends zc {
          constructor(t2, e2, i2, n2) {
            super(t2, e2, i2, n2);
            this.getFillerOffset = Hl;
          }
          is(t2, e2 = null) {
            const i2 = t2.replace(/^view:/, "");
            if (!e2) {
              return i2 == "uiElement" || super.is(t2);
            } else {
              return i2 == "uiElement" && e2 == this.name || super.is(t2, e2);
            }
          }
          _insertChild(t2, e2) {
            if (e2 && (e2 instanceof zs || Array.from(e2).length > 0)) {
              throw new ss["b"]("view-uielement-cannot-add: Cannot add child nodes to UIElement instance.", this);
            }
          }
          render(t2) {
            return this.toDomElement(t2);
          }
          toDomElement(t2) {
            const e2 = t2.createElement(this.name);
            for (const t3 of this.getAttributeKeys()) {
              e2.setAttribute(t3, this.getAttribute(t3));
            }
            return e2;
          }
        }
        function jl(t2) {
          t2.document.on("keydown", (e2, i2) => Wl(e2, i2, t2.domConverter));
        }
        function Hl() {
          return null;
        }
        function Wl(t2, e2, i2) {
          if (e2.keyCode == Nl.arrowright) {
            const t3 = e2.domTarget.ownerDocument.defaultView.getSelection();
            const n2 = t3.rangeCount == 1 && t3.getRangeAt(0).collapsed;
            if (n2 || e2.shiftKey) {
              const e3 = t3.focusNode;
              const o2 = t3.focusOffset;
              const r2 = i2.domPositionToView(e3, o2);
              if (r2 === null) {
                return;
              }
              let s2 = false;
              const a2 = r2.getLastMatchingPosition((t4) => {
                if (t4.item.is("uiElement")) {
                  s2 = true;
                }
                if (t4.item.is("uiElement") || t4.item.is("attributeElement")) {
                  return true;
                }
                return false;
              });
              if (s2) {
                const e4 = i2.viewPositionToDom(a2);
                if (n2) {
                  t3.collapse(e4.parent, e4.offset);
                } else {
                  t3.extend(e4.parent, e4.offset);
                }
              }
            }
          }
        }
        class ql {
          constructor(t2, e2) {
            this.document = t2;
            this._children = [];
            if (e2) {
              this._insertChild(0, e2);
            }
          }
          [Symbol.iterator]() {
            return this._children[Symbol.iterator]();
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return this.childCount === 0;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          is(t2) {
            return t2 == "documentFragment" || t2 == "view:documentFragment";
          }
          _appendChild(t2) {
            return this._insertChild(this.childCount, t2);
          }
          getChild(t2) {
            return this._children[t2];
          }
          getChildIndex(t2) {
            return this._children.indexOf(t2);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          _insertChild(t2, e2) {
            this._fireChange("children", this);
            let i2 = 0;
            const n2 = Ul(this.document, e2);
            for (const e3 of n2) {
              if (e3.parent !== null) {
                e3._remove();
              }
              e3.parent = this;
              this._children.splice(t2, 0, e3);
              t2++;
              i2++;
            }
            return i2;
          }
          _removeChildren(t2, e2 = 1) {
            this._fireChange("children", this);
            for (let i2 = t2; i2 < t2 + e2; i2++) {
              this._children[i2].parent = null;
            }
            return this._children.splice(t2, e2);
          }
          _fireChange(t2, e2) {
            this.fire("change:" + t2, e2);
          }
        }
        vs(ql, ds);
        function Ul(t2, e2) {
          if (typeof e2 == "string") {
            return [new Ls(t2, e2)];
          }
          if (!js(e2)) {
            e2 = [e2];
          }
          return Array.from(e2).map((e3) => {
            if (typeof e3 == "string") {
              return new Ls(t2, e3);
            }
            if (e3 instanceof Fs) {
              return new Ls(t2, e3.data);
            }
            return e3;
          });
        }
        class $l {
          constructor(t2) {
            this.document = t2;
            this._cloneGroups = new Map();
          }
          setSelection(t2, e2, i2) {
            this.document.selection._setTo(t2, e2, i2);
          }
          setSelectionFocus(t2, e2) {
            this.document.selection._setFocus(t2, e2);
          }
          createText(t2) {
            return new Ls(this.document, t2);
          }
          createAttributeElement(t2, e2, i2 = {}) {
            const n2 = new wl(this.document, t2, e2);
            if (i2.priority) {
              n2._priority = i2.priority;
            }
            if (i2.id) {
              n2._id = i2.id;
            }
            return n2;
          }
          createContainerElement(t2, e2) {
            return new jc(this.document, t2, e2);
          }
          createEditableElement(t2, e2) {
            const i2 = new sl(this.document, t2, e2);
            i2._document = this.document;
            return i2;
          }
          createEmptyElement(t2, e2) {
            return new vl(this.document, t2, e2);
          }
          createUIElement(t2, e2, i2) {
            const n2 = new Dl(this.document, t2, e2);
            if (i2) {
              n2.render = i2;
            }
            return n2;
          }
          setAttribute(t2, e2, i2) {
            i2._setAttribute(t2, e2);
          }
          removeAttribute(t2, e2) {
            e2._removeAttribute(t2);
          }
          addClass(t2, e2) {
            e2._addClass(t2);
          }
          removeClass(t2, e2) {
            e2._removeClass(t2);
          }
          setStyle(t2, e2, i2) {
            if (N(t2) && i2 === void 0) {
              i2 = e2;
            }
            i2._setStyle(t2, e2);
          }
          removeStyle(t2, e2) {
            e2._removeStyle(t2);
          }
          setCustomProperty(t2, e2, i2) {
            i2._setCustomProperty(t2, e2);
          }
          removeCustomProperty(t2, e2) {
            return e2._removeCustomProperty(t2);
          }
          breakAttributes(t2) {
            if (t2 instanceof dl) {
              return this._breakAttributes(t2);
            } else {
              return this._breakAttributesRange(t2);
            }
          }
          breakContainer(t2) {
            const e2 = t2.parent;
            if (!e2.is("containerElement")) {
              throw new ss["b"]("view-writer-break-non-container-element: Trying to break an element which is not a container element.", this.document);
            }
            if (!e2.parent) {
              throw new ss["b"]("view-writer-break-root: Trying to break root element.", this.document);
            }
            if (t2.isAtStart) {
              return dl._createBefore(e2);
            } else if (!t2.isAtEnd) {
              const i2 = e2._clone(false);
              this.insert(dl._createAfter(e2), i2);
              const n2 = new ul(t2, dl._createAt(e2, "end"));
              const o2 = new dl(i2, 0);
              this.move(n2, o2);
            }
            return dl._createAfter(e2);
          }
          mergeAttributes(t2) {
            const e2 = t2.offset;
            const i2 = t2.parent;
            if (i2.is("text")) {
              return t2;
            }
            if (i2.is("attributeElement") && i2.childCount === 0) {
              const t3 = i2.parent;
              const e3 = i2.index;
              i2._remove();
              this._removeFromClonedElementsGroup(i2);
              return this.mergeAttributes(new dl(t3, e3));
            }
            const n2 = i2.getChild(e2 - 1);
            const o2 = i2.getChild(e2);
            if (!n2 || !o2) {
              return t2;
            }
            if (n2.is("text") && o2.is("text")) {
              return Xl(n2, o2);
            } else if (n2.is("attributeElement") && o2.is("attributeElement") && n2.isSimilar(o2)) {
              const t3 = n2.childCount;
              n2._appendChild(o2.getChildren());
              o2._remove();
              this._removeFromClonedElementsGroup(o2);
              return this.mergeAttributes(new dl(n2, t3));
            }
            return t2;
          }
          mergeContainers(t2) {
            const e2 = t2.nodeBefore;
            const i2 = t2.nodeAfter;
            if (!e2 || !i2 || !e2.is("containerElement") || !i2.is("containerElement")) {
              throw new ss["b"]("view-writer-merge-containers-invalid-position: Element before and after given position cannot be merged.", this.document);
            }
            const n2 = e2.getChild(e2.childCount - 1);
            const o2 = n2 instanceof Ls ? dl._createAt(n2, "end") : dl._createAt(e2, "end");
            this.move(ul._createIn(i2), dl._createAt(e2, "end"));
            this.remove(ul._createOn(i2));
            return o2;
          }
          insert(t2, e2) {
            e2 = js(e2) ? [...e2] : [e2];
            Zl(e2, this.document);
            const i2 = Kl(t2);
            if (!i2) {
              throw new ss["b"]("view-writer-invalid-position-container", this.document);
            }
            const n2 = this._breakAttributes(t2, true);
            const o2 = i2._insertChild(n2.offset, e2);
            for (const t3 of e2) {
              this._addToClonedElementsGroup(t3);
            }
            const r2 = n2.getShiftedBy(o2);
            const s2 = this.mergeAttributes(n2);
            if (o2 === 0) {
              return new ul(s2, s2);
            } else {
              if (!s2.isEqual(n2)) {
                r2.offset--;
              }
              const t3 = this.mergeAttributes(r2);
              return new ul(s2, t3);
            }
          }
          remove(t2) {
            const e2 = t2 instanceof ul ? t2 : ul._createOn(t2);
            id(e2, this.document);
            if (e2.isCollapsed) {
              return new ql(this.document);
            }
            const {start: i2, end: n2} = this._breakAttributesRange(e2, true);
            const o2 = i2.parent;
            const r2 = n2.offset - i2.offset;
            const s2 = o2._removeChildren(i2.offset, r2);
            for (const t3 of s2) {
              this._removeFromClonedElementsGroup(t3);
            }
            const a2 = this.mergeAttributes(i2);
            e2.start = a2;
            e2.end = a2.clone();
            return new ql(this.document, s2);
          }
          clear(t2, e2) {
            id(t2, this.document);
            const i2 = t2.getWalker({direction: "backward", ignoreElementEnd: true});
            for (const n2 of i2) {
              const i3 = n2.item;
              let o2;
              if (i3.is("element") && e2.isSimilar(i3)) {
                o2 = ul._createOn(i3);
              } else if (!n2.nextPosition.isAfter(t2.start) && i3.is("textProxy")) {
                const t3 = i3.getAncestors().find((t4) => t4.is("element") && e2.isSimilar(t4));
                if (t3) {
                  o2 = ul._createIn(t3);
                }
              }
              if (o2) {
                if (o2.end.isAfter(t2.end)) {
                  o2.end = t2.end;
                }
                if (o2.start.isBefore(t2.start)) {
                  o2.start = t2.start;
                }
                this.remove(o2);
              }
            }
          }
          move(t2, e2) {
            let i2;
            if (e2.isAfter(t2.end)) {
              e2 = this._breakAttributes(e2, true);
              const n2 = e2.parent;
              const o2 = n2.childCount;
              t2 = this._breakAttributesRange(t2, true);
              i2 = this.remove(t2);
              e2.offset += n2.childCount - o2;
            } else {
              i2 = this.remove(t2);
            }
            return this.insert(e2, i2);
          }
          wrap(t2, e2) {
            if (!(e2 instanceof wl)) {
              throw new ss["b"]("view-writer-wrap-invalid-attribute", this.document);
            }
            id(t2, this.document);
            if (!t2.isCollapsed) {
              return this._wrapRange(t2, e2);
            } else {
              let i2 = t2.start;
              if (i2.parent.is("element") && !Gl(i2.parent)) {
                i2 = i2.getLastMatchingPosition((t3) => t3.item.is("uiElement"));
              }
              i2 = this._wrapPosition(i2, e2);
              const n2 = this.document.selection;
              if (n2.isCollapsed && n2.getFirstPosition().isEqual(t2.start)) {
                this.setSelection(i2);
              }
              return new ul(i2);
            }
          }
          unwrap(t2, e2) {
            if (!(e2 instanceof wl)) {
              throw new ss["b"]("view-writer-unwrap-invalid-attribute", this.document);
            }
            id(t2, this.document);
            if (t2.isCollapsed) {
              return t2;
            }
            const {start: i2, end: n2} = this._breakAttributesRange(t2, true);
            const o2 = i2.parent;
            const r2 = this._unwrapChildren(o2, i2.offset, n2.offset, e2);
            const s2 = this.mergeAttributes(r2.start);
            if (!s2.isEqual(r2.start)) {
              r2.end.offset--;
            }
            const a2 = this.mergeAttributes(r2.end);
            return new ul(s2, a2);
          }
          rename(t2, e2) {
            const i2 = new jc(this.document, t2, e2.getAttributes());
            this.insert(dl._createAfter(e2), i2);
            this.move(ul._createIn(e2), dl._createAt(i2, 0));
            this.remove(ul._createOn(e2));
            return i2;
          }
          clearClonedElementsGroup(t2) {
            this._cloneGroups.delete(t2);
          }
          createPositionAt(t2, e2) {
            return dl._createAt(t2, e2);
          }
          createPositionAfter(t2) {
            return dl._createAfter(t2);
          }
          createPositionBefore(t2) {
            return dl._createBefore(t2);
          }
          createRange(t2, e2) {
            return new ul(t2, e2);
          }
          createRangeOn(t2) {
            return ul._createOn(t2);
          }
          createRangeIn(t2) {
            return ul._createIn(t2);
          }
          createSelection(t2, e2, i2) {
            return new gl(t2, e2, i2);
          }
          _wrapChildren(t2, e2, i2, n2) {
            let o2 = e2;
            const r2 = [];
            while (o2 < i2) {
              const e3 = t2.getChild(o2);
              const i3 = e3.is("text");
              const s3 = e3.is("attributeElement");
              const a2 = e3.is("emptyElement");
              const c2 = e3.is("uiElement");
              if (s3 && this._wrapAttributeElement(n2, e3)) {
                r2.push(new dl(t2, o2));
              } else if (i3 || a2 || c2 || s3 && Jl(n2, e3)) {
                const i4 = n2._clone();
                e3._remove();
                i4._appendChild(e3);
                t2._insertChild(o2, i4);
                this._addToClonedElementsGroup(i4);
                r2.push(new dl(t2, o2));
              } else if (s3) {
                this._wrapChildren(e3, 0, e3.childCount, n2);
              }
              o2++;
            }
            let s2 = 0;
            for (const t3 of r2) {
              t3.offset -= s2;
              if (t3.offset == e2) {
                continue;
              }
              const n3 = this.mergeAttributes(t3);
              if (!n3.isEqual(t3)) {
                s2++;
                i2--;
              }
            }
            return ul._createFromParentsAndOffsets(t2, e2, t2, i2);
          }
          _unwrapChildren(t2, e2, i2, n2) {
            let o2 = e2;
            const r2 = [];
            while (o2 < i2) {
              const e3 = t2.getChild(o2);
              if (!e3.is("attributeElement")) {
                o2++;
                continue;
              }
              if (e3.isSimilar(n2)) {
                const n3 = e3.getChildren();
                const s3 = e3.childCount;
                e3._remove();
                t2._insertChild(o2, n3);
                this._removeFromClonedElementsGroup(e3);
                r2.push(new dl(t2, o2), new dl(t2, o2 + s3));
                o2 += s3;
                i2 += s3 - 1;
                continue;
              }
              if (this._unwrapAttributeElement(n2, e3)) {
                r2.push(new dl(t2, o2), new dl(t2, o2 + 1));
                o2++;
                continue;
              }
              this._unwrapChildren(e3, 0, e3.childCount, n2);
              o2++;
            }
            let s2 = 0;
            for (const t3 of r2) {
              t3.offset -= s2;
              if (t3.offset == e2 || t3.offset == i2) {
                continue;
              }
              const n3 = this.mergeAttributes(t3);
              if (!n3.isEqual(t3)) {
                s2++;
                i2--;
              }
            }
            return ul._createFromParentsAndOffsets(t2, e2, t2, i2);
          }
          _wrapRange(t2, e2) {
            const {start: i2, end: n2} = this._breakAttributesRange(t2, true);
            const o2 = i2.parent;
            const r2 = this._wrapChildren(o2, i2.offset, n2.offset, e2);
            const s2 = this.mergeAttributes(r2.start);
            if (!s2.isEqual(r2.start)) {
              r2.end.offset--;
            }
            const a2 = this.mergeAttributes(r2.end);
            return new ul(s2, a2);
          }
          _wrapPosition(t2, e2) {
            if (e2.isSimilar(t2.parent)) {
              return Yl(t2.clone());
            }
            if (t2.parent.is("text")) {
              t2 = Ql(t2);
            }
            const i2 = this.createAttributeElement();
            i2._priority = Number.POSITIVE_INFINITY;
            i2.isSimilar = () => false;
            t2.parent._insertChild(t2.offset, i2);
            const n2 = new ul(t2, t2.getShiftedBy(1));
            this.wrap(n2, e2);
            const o2 = new dl(i2.parent, i2.index);
            i2._remove();
            const r2 = o2.nodeBefore;
            const s2 = o2.nodeAfter;
            if (r2 instanceof Ls && s2 instanceof Ls) {
              return Xl(r2, s2);
            }
            return Yl(o2);
          }
          _wrapAttributeElement(t2, e2) {
            if (!nd(t2, e2)) {
              return false;
            }
            if (t2.name !== e2.name || t2.priority !== e2.priority) {
              return false;
            }
            for (const i2 of t2.getAttributeKeys()) {
              if (i2 === "class" || i2 === "style") {
                continue;
              }
              if (e2.hasAttribute(i2) && e2.getAttribute(i2) !== t2.getAttribute(i2)) {
                return false;
              }
            }
            for (const i2 of t2.getStyleNames()) {
              if (e2.hasStyle(i2) && e2.getStyle(i2) !== t2.getStyle(i2)) {
                return false;
              }
            }
            for (const i2 of t2.getAttributeKeys()) {
              if (i2 === "class" || i2 === "style") {
                continue;
              }
              if (!e2.hasAttribute(i2)) {
                this.setAttribute(i2, t2.getAttribute(i2), e2);
              }
            }
            for (const i2 of t2.getStyleNames()) {
              if (!e2.hasStyle(i2)) {
                this.setStyle(i2, t2.getStyle(i2), e2);
              }
            }
            for (const i2 of t2.getClassNames()) {
              if (!e2.hasClass(i2)) {
                this.addClass(i2, e2);
              }
            }
            return true;
          }
          _unwrapAttributeElement(t2, e2) {
            if (!nd(t2, e2)) {
              return false;
            }
            if (t2.name !== e2.name || t2.priority !== e2.priority) {
              return false;
            }
            for (const i2 of t2.getAttributeKeys()) {
              if (i2 === "class" || i2 === "style") {
                continue;
              }
              if (!e2.hasAttribute(i2) || e2.getAttribute(i2) !== t2.getAttribute(i2)) {
                return false;
              }
            }
            if (!e2.hasClass(...t2.getClassNames())) {
              return false;
            }
            for (const i2 of t2.getStyleNames()) {
              if (!e2.hasStyle(i2) || e2.getStyle(i2) !== t2.getStyle(i2)) {
                return false;
              }
            }
            for (const i2 of t2.getAttributeKeys()) {
              if (i2 === "class" || i2 === "style") {
                continue;
              }
              this.removeAttribute(i2, e2);
            }
            this.removeClass(Array.from(t2.getClassNames()), e2);
            this.removeStyle(Array.from(t2.getStyleNames()), e2);
            return true;
          }
          _breakAttributesRange(t2, e2 = false) {
            const i2 = t2.start;
            const n2 = t2.end;
            id(t2, this.document);
            if (t2.isCollapsed) {
              const i3 = this._breakAttributes(t2.start, e2);
              return new ul(i3, i3);
            }
            const o2 = this._breakAttributes(n2, e2);
            const r2 = o2.parent.childCount;
            const s2 = this._breakAttributes(i2, e2);
            o2.offset += o2.parent.childCount - r2;
            return new ul(s2, o2);
          }
          _breakAttributes(t2, e2 = false) {
            const i2 = t2.offset;
            const n2 = t2.parent;
            if (t2.parent.is("emptyElement")) {
              throw new ss["b"]("view-writer-cannot-break-empty-element", this.document);
            }
            if (t2.parent.is("uiElement")) {
              throw new ss["b"]("view-writer-cannot-break-ui-element", this.document);
            }
            if (!e2 && n2.is("text") && ed(n2.parent)) {
              return t2.clone();
            }
            if (ed(n2)) {
              return t2.clone();
            }
            if (n2.is("text")) {
              return this._breakAttributes(Ql(t2), e2);
            }
            const o2 = n2.childCount;
            if (i2 == o2) {
              const t3 = new dl(n2.parent, n2.index + 1);
              return this._breakAttributes(t3, e2);
            } else {
              if (i2 === 0) {
                const t3 = new dl(n2.parent, n2.index);
                return this._breakAttributes(t3, e2);
              } else {
                const t3 = n2.index + 1;
                const o3 = n2._clone();
                n2.parent._insertChild(t3, o3);
                this._addToClonedElementsGroup(o3);
                const r2 = n2.childCount - i2;
                const s2 = n2._removeChildren(i2, r2);
                o3._appendChild(s2);
                const a2 = new dl(n2.parent, t3);
                return this._breakAttributes(a2, e2);
              }
            }
          }
          _addToClonedElementsGroup(t2) {
            if (!t2.root.is("rootElement")) {
              return;
            }
            if (t2.is("element")) {
              for (const e3 of t2.getChildren()) {
                this._addToClonedElementsGroup(e3);
              }
            }
            const e2 = t2.id;
            if (!e2) {
              return;
            }
            let i2 = this._cloneGroups.get(e2);
            if (!i2) {
              i2 = new Set();
              this._cloneGroups.set(e2, i2);
            }
            i2.add(t2);
            t2._clonesGroup = i2;
          }
          _removeFromClonedElementsGroup(t2) {
            if (t2.is("element")) {
              for (const e3 of t2.getChildren()) {
                this._removeFromClonedElementsGroup(e3);
              }
            }
            const e2 = t2.id;
            if (!e2) {
              return;
            }
            const i2 = this._cloneGroups.get(e2);
            if (!i2) {
              return;
            }
            i2.delete(t2);
          }
        }
        function Gl(t2) {
          return Array.from(t2.getChildren()).some((t3) => !t3.is("uiElement"));
        }
        function Kl(t2) {
          let e2 = t2.parent;
          while (!ed(e2)) {
            if (!e2) {
              return void 0;
            }
            e2 = e2.parent;
          }
          return e2;
        }
        function Jl(t2, e2) {
          if (t2.priority < e2.priority) {
            return true;
          } else if (t2.priority > e2.priority) {
            return false;
          }
          return t2.getIdentity() < e2.getIdentity();
        }
        function Yl(t2) {
          const e2 = t2.nodeBefore;
          if (e2 && e2.is("text")) {
            return new dl(e2, e2.data.length);
          }
          const i2 = t2.nodeAfter;
          if (i2 && i2.is("text")) {
            return new dl(i2, 0);
          }
          return t2;
        }
        function Ql(t2) {
          if (t2.offset == t2.parent.data.length) {
            return new dl(t2.parent.parent, t2.parent.index + 1);
          }
          if (t2.offset === 0) {
            return new dl(t2.parent.parent, t2.parent.index);
          }
          const e2 = t2.parent.data.slice(t2.offset);
          t2.parent._data = t2.parent.data.slice(0, t2.offset);
          t2.parent.parent._insertChild(t2.parent.index + 1, new Ls(t2.root.document, e2));
          return new dl(t2.parent.parent, t2.parent.index + 1);
        }
        function Xl(t2, e2) {
          const i2 = t2.data.length;
          t2._data += e2.data;
          e2._remove();
          return new dl(t2, i2);
        }
        function Zl(t2, e2) {
          for (const i2 of t2) {
            if (!td.some((t3) => i2 instanceof t3)) {
              throw new ss["b"]("view-writer-insert-invalid-node", e2);
            }
            if (!i2.is("text")) {
              Zl(i2.getChildren(), e2);
            }
          }
        }
        const td = [Ls, wl, jc, vl, Dl];
        function ed(t2) {
          return t2 && (t2.is("containerElement") || t2.is("documentFragment"));
        }
        function id(t2, e2) {
          const i2 = Kl(t2.start);
          const n2 = Kl(t2.end);
          if (!i2 || !n2 || i2 !== n2) {
            throw new ss["b"]("view-writer-invalid-range-container", e2);
          }
        }
        function nd(t2, e2) {
          return t2.id === null && e2.id === null;
        }
        function od(t2) {
          return Object.prototype.toString.call(t2) == "[object Text]";
        }
        const rd = (t2) => t2.createTextNode("\xA0");
        const sd = (t2) => {
          const e2 = t2.createElement("br");
          e2.dataset.ckeFiller = true;
          return e2;
        };
        const ad = 7;
        const cd = (() => {
          let t2 = "";
          for (let e2 = 0; e2 < ad; e2++) {
            t2 += "\u200B";
          }
          return t2;
        })();
        function ld(t2) {
          return od(t2) && t2.data.substr(0, ad) === cd;
        }
        function dd(t2) {
          return t2.data.length == ad && ld(t2);
        }
        function ud(t2) {
          if (ld(t2)) {
            return t2.data.slice(ad);
          } else {
            return t2.data;
          }
        }
        function hd(t2) {
          t2.document.on("keydown", fd);
        }
        function fd(t2, e2) {
          if (e2.keyCode == Nl.arrowleft) {
            const t3 = e2.domTarget.ownerDocument.defaultView.getSelection();
            if (t3.rangeCount == 1 && t3.getRangeAt(0).collapsed) {
              const e3 = t3.getRangeAt(0).startContainer;
              const i2 = t3.getRangeAt(0).startOffset;
              if (ld(e3) && i2 <= ad) {
                t3.collapse(e3, 0);
              }
            }
          }
        }
        function gd(t2, e2, i2, n2 = false) {
          i2 = i2 || function(t3, e3) {
            return t3 === e3;
          };
          if (!Array.isArray(t2)) {
            t2 = Array.from(t2);
          }
          if (!Array.isArray(e2)) {
            e2 = Array.from(e2);
          }
          const o2 = md(t2, e2, i2);
          return n2 ? kd(o2, e2.length) : wd(e2, o2);
        }
        function md(t2, e2, i2) {
          const n2 = pd(t2, e2, i2);
          if (n2 === -1) {
            return {firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1};
          }
          const o2 = bd(t2, n2);
          const r2 = bd(e2, n2);
          const s2 = pd(o2, r2, i2);
          const a2 = t2.length - s2;
          const c2 = e2.length - s2;
          return {firstIndex: n2, lastIndexOld: a2, lastIndexNew: c2};
        }
        function pd(t2, e2, i2) {
          for (let n2 = 0; n2 < Math.max(t2.length, e2.length); n2++) {
            if (t2[n2] === void 0 || e2[n2] === void 0 || !i2(t2[n2], e2[n2])) {
              return n2;
            }
          }
          return -1;
        }
        function bd(t2, e2) {
          return t2.slice(e2).reverse();
        }
        function wd(t2, e2) {
          const i2 = [];
          const {firstIndex: n2, lastIndexOld: o2, lastIndexNew: r2} = e2;
          if (r2 - n2 > 0) {
            i2.push({index: n2, type: "insert", values: t2.slice(n2, r2)});
          }
          if (o2 - n2 > 0) {
            i2.push({index: n2 + (r2 - n2), type: "delete", howMany: o2 - n2});
          }
          return i2;
        }
        function kd(t2, e2) {
          const {firstIndex: i2, lastIndexOld: n2, lastIndexNew: o2} = t2;
          if (i2 === -1) {
            return Array(e2).fill("equal");
          }
          let r2 = [];
          if (i2 > 0) {
            r2 = r2.concat(Array(i2).fill("equal"));
          }
          if (o2 - i2 > 0) {
            r2 = r2.concat(Array(o2 - i2).fill("insert"));
          }
          if (n2 - i2 > 0) {
            r2 = r2.concat(Array(n2 - i2).fill("delete"));
          }
          if (o2 < e2) {
            r2 = r2.concat(Array(e2 - o2).fill("equal"));
          }
          return r2;
        }
        function _d(t2, e2, i2) {
          i2 = i2 || function(t3, e3) {
            return t3 === e3;
          };
          const n2 = t2.length;
          const o2 = e2.length;
          if (n2 > 200 || o2 > 200 || n2 + o2 > 300) {
            return _d.fastDiff(t2, e2, i2, true);
          }
          let r2, s2;
          if (o2 < n2) {
            const i3 = t2;
            t2 = e2;
            e2 = i3;
            r2 = "delete";
            s2 = "insert";
          } else {
            r2 = "insert";
            s2 = "delete";
          }
          const a2 = t2.length;
          const c2 = e2.length;
          const l2 = c2 - a2;
          const d2 = {};
          const u2 = {};
          function h2(n3) {
            const o3 = (u2[n3 - 1] !== void 0 ? u2[n3 - 1] : -1) + 1;
            const l3 = u2[n3 + 1] !== void 0 ? u2[n3 + 1] : -1;
            const h3 = o3 > l3 ? -1 : 1;
            if (d2[n3 + h3]) {
              d2[n3] = d2[n3 + h3].slice(0);
            }
            if (!d2[n3]) {
              d2[n3] = [];
            }
            d2[n3].push(o3 > l3 ? r2 : s2);
            let f3 = Math.max(o3, l3);
            let g3 = f3 - n3;
            while (g3 < a2 && f3 < c2 && i2(t2[g3], e2[f3])) {
              g3++;
              f3++;
              d2[n3].push("equal");
            }
            return f3;
          }
          let f2 = 0;
          let g2;
          do {
            for (g2 = -f2; g2 < l2; g2++) {
              u2[g2] = h2(g2);
            }
            for (g2 = l2 + f2; g2 > l2; g2--) {
              u2[g2] = h2(g2);
            }
            u2[l2] = h2(l2);
            f2++;
          } while (u2[l2] !== c2);
          return d2[l2].slice(1);
        }
        _d.fastDiff = gd;
        function vd(t2, e2, i2) {
          t2.insertBefore(i2, t2.childNodes[e2] || null);
        }
        function yd(t2) {
          const e2 = t2.parentNode;
          if (e2) {
            e2.removeChild(t2);
          }
        }
        function xd(t2) {
          if (t2) {
            if (t2.defaultView) {
              return t2 instanceof t2.defaultView.Document;
            } else if (t2.ownerDocument && t2.ownerDocument.defaultView) {
              return t2 instanceof t2.ownerDocument.defaultView.Node;
            }
          }
          return false;
        }
        class Cd {
          constructor(t2, e2) {
            this.domDocuments = new Set();
            this.domConverter = t2;
            this.markedAttributes = new Set();
            this.markedChildren = new Set();
            this.markedTexts = new Set();
            this.selection = e2;
            this.isFocused = false;
            this._inlineFiller = null;
            this._fakeSelectionContainer = null;
          }
          markToSync(t2, e2) {
            if (t2 === "text") {
              if (this.domConverter.mapViewToDom(e2.parent)) {
                this.markedTexts.add(e2);
              }
            } else {
              if (!this.domConverter.mapViewToDom(e2)) {
                return;
              }
              if (t2 === "attributes") {
                this.markedAttributes.add(e2);
              } else if (t2 === "children") {
                this.markedChildren.add(e2);
              } else {
                throw new ss["b"]("view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.", this);
              }
            }
          }
          render() {
            let t2;
            for (const t3 of this.markedChildren) {
              this._updateChildrenMappings(t3);
            }
            if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
              this._removeInlineFiller();
            }
            if (this._inlineFiller) {
              t2 = this._getInlineFillerPosition();
            } else if (this._needsInlineFillerAtSelection()) {
              t2 = this.selection.getFirstPosition();
              this.markedChildren.add(t2.parent);
            }
            for (const t3 of this.markedAttributes) {
              this._updateAttrs(t3);
            }
            for (const e2 of this.markedChildren) {
              this._updateChildren(e2, {inlineFillerPosition: t2});
            }
            for (const e2 of this.markedTexts) {
              if (!this.markedChildren.has(e2.parent) && this.domConverter.mapViewToDom(e2.parent)) {
                this._updateText(e2, {inlineFillerPosition: t2});
              }
            }
            if (t2) {
              const e2 = this.domConverter.viewPositionToDom(t2);
              const i2 = e2.parent.ownerDocument;
              if (!ld(e2.parent)) {
                this._inlineFiller = Td(i2, e2.parent, e2.offset);
              } else {
                this._inlineFiller = e2.parent;
              }
            } else {
              this._inlineFiller = null;
            }
            this._updateSelection();
            this._updateFocus();
            this.markedTexts.clear();
            this.markedAttributes.clear();
            this.markedChildren.clear();
          }
          _updateChildrenMappings(t2) {
            const e2 = this.domConverter.mapViewToDom(t2);
            if (!e2) {
              return;
            }
            const i2 = this.domConverter.mapViewToDom(t2).childNodes;
            const n2 = Array.from(this.domConverter.viewChildrenToDom(t2, e2.ownerDocument, {withChildren: false}));
            const o2 = this._diffNodeLists(i2, n2);
            const r2 = this._findReplaceActions(o2, i2, n2);
            if (r2.indexOf("replace") !== -1) {
              const e3 = {equal: 0, insert: 0, delete: 0};
              for (const o3 of r2) {
                if (o3 === "replace") {
                  const o4 = e3.equal + e3.insert;
                  const r3 = e3.equal + e3.delete;
                  const s2 = t2.getChild(o4);
                  if (s2 && !s2.is("uiElement")) {
                    this._updateElementMappings(s2, i2[r3]);
                  }
                  yd(n2[o4]);
                  e3.equal++;
                } else {
                  e3[o3]++;
                }
              }
            }
          }
          _updateElementMappings(t2, e2) {
            this.domConverter.unbindDomElement(e2);
            this.domConverter.bindElements(e2, t2);
            this.markedChildren.add(t2);
            this.markedAttributes.add(t2);
          }
          _getInlineFillerPosition() {
            const t2 = this.selection.getFirstPosition();
            if (t2.parent.is("text")) {
              return dl._createBefore(this.selection.getFirstPosition().parent);
            } else {
              return t2;
            }
          }
          _isSelectionInInlineFiller() {
            if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
              return false;
            }
            const t2 = this.selection.getFirstPosition();
            const e2 = this.domConverter.viewPositionToDom(t2);
            if (e2 && od(e2.parent) && ld(e2.parent)) {
              return true;
            }
            return false;
          }
          _removeInlineFiller() {
            const t2 = this._inlineFiller;
            if (!ld(t2)) {
              throw new ss["b"]("view-renderer-filler-was-lost: The inline filler node was lost.", this);
            }
            if (dd(t2)) {
              t2.parentNode.removeChild(t2);
            } else {
              t2.data = t2.data.substr(ad);
            }
            this._inlineFiller = null;
          }
          _needsInlineFillerAtSelection() {
            if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
              return false;
            }
            const t2 = this.selection.getFirstPosition();
            const e2 = t2.parent;
            const i2 = t2.offset;
            if (!this.domConverter.mapViewToDom(e2.root)) {
              return false;
            }
            if (!e2.is("element")) {
              return false;
            }
            if (!Ad(e2)) {
              return false;
            }
            if (i2 === e2.getFillerOffset()) {
              return false;
            }
            const n2 = t2.nodeBefore;
            const o2 = t2.nodeAfter;
            if (n2 instanceof Ls || o2 instanceof Ls) {
              return false;
            }
            return true;
          }
          _updateText(t2, e2) {
            const i2 = this.domConverter.findCorrespondingDomText(t2);
            const n2 = this.domConverter.viewToDom(t2, i2.ownerDocument);
            const o2 = i2.data;
            let r2 = n2.data;
            const s2 = e2.inlineFillerPosition;
            if (s2 && s2.parent == t2.parent && s2.offset == t2.index) {
              r2 = cd + r2;
            }
            if (o2 != r2) {
              const t3 = gd(o2, r2);
              for (const e3 of t3) {
                if (e3.type === "insert") {
                  i2.insertData(e3.index, e3.values.join(""));
                } else {
                  i2.deleteData(e3.index, e3.howMany);
                }
              }
            }
          }
          _updateAttrs(t2) {
            const e2 = this.domConverter.mapViewToDom(t2);
            if (!e2) {
              return;
            }
            const i2 = Array.from(e2.attributes).map((t3) => t3.name);
            const n2 = t2.getAttributeKeys();
            for (const i3 of n2) {
              e2.setAttribute(i3, t2.getAttribute(i3));
            }
            for (const n3 of i2) {
              if (!t2.hasAttribute(n3)) {
                e2.removeAttribute(n3);
              }
            }
          }
          _updateChildren(t2, e2) {
            const i2 = this.domConverter.mapViewToDom(t2);
            if (!i2) {
              return;
            }
            const n2 = e2.inlineFillerPosition;
            const o2 = this.domConverter.mapViewToDom(t2).childNodes;
            const r2 = Array.from(this.domConverter.viewChildrenToDom(t2, i2.ownerDocument, {
              bind: true,
              inlineFillerPosition: n2
            }));
            if (n2 && n2.parent === t2) {
              Td(i2.ownerDocument, r2, n2.offset);
            }
            const s2 = this._diffNodeLists(o2, r2);
            let a2 = 0;
            const c2 = new Set();
            for (const t3 of s2) {
              if (t3 === "delete") {
                c2.add(o2[a2]);
                yd(o2[a2]);
              } else if (t3 === "equal") {
                a2++;
              }
            }
            a2 = 0;
            for (const t3 of s2) {
              if (t3 === "insert") {
                vd(i2, a2, r2[a2]);
                a2++;
              } else if (t3 === "equal") {
                this._markDescendantTextToSync(this.domConverter.domToView(r2[a2]));
                a2++;
              }
            }
            for (const t3 of c2) {
              if (!t3.parentNode) {
                this.domConverter.unbindDomElement(t3);
              }
            }
          }
          _diffNodeLists(t2, e2) {
            t2 = Rd(t2, this._fakeSelectionContainer);
            return _d(t2, e2, Sd.bind(null, this.domConverter));
          }
          _findReplaceActions(t2, e2, i2) {
            if (t2.indexOf("insert") === -1 || t2.indexOf("delete") === -1) {
              return t2;
            }
            let n2 = [];
            let o2 = [];
            let r2 = [];
            const s2 = {equal: 0, insert: 0, delete: 0};
            for (const a2 of t2) {
              if (a2 === "insert") {
                r2.push(i2[s2.equal + s2.insert]);
              } else if (a2 === "delete") {
                o2.push(e2[s2.equal + s2.delete]);
              } else {
                n2 = n2.concat(_d(o2, r2, Pd).map((t3) => t3 === "equal" ? "replace" : t3));
                n2.push("equal");
                o2 = [];
                r2 = [];
              }
              s2[a2]++;
            }
            return n2.concat(_d(o2, r2, Pd).map((t3) => t3 === "equal" ? "replace" : t3));
          }
          _markDescendantTextToSync(t2) {
            if (!t2) {
              return;
            }
            if (t2.is("text")) {
              this.markedTexts.add(t2);
            } else if (t2.is("element")) {
              for (const e2 of t2.getChildren()) {
                this._markDescendantTextToSync(e2);
              }
            }
          }
          _updateSelection() {
            if (this.selection.rangeCount === 0) {
              this._removeDomSelection();
              this._removeFakeSelection();
              return;
            }
            const t2 = this.domConverter.mapViewToDom(this.selection.editableElement);
            if (!this.isFocused || !t2) {
              return;
            }
            if (this.selection.isFake) {
              this._updateFakeSelection(t2);
            } else {
              this._removeFakeSelection();
              this._updateDomSelection(t2);
            }
          }
          _updateFakeSelection(t2) {
            const e2 = t2.ownerDocument;
            if (!this._fakeSelectionContainer) {
              this._fakeSelectionContainer = Od(e2);
            }
            const i2 = this._fakeSelectionContainer;
            this.domConverter.bindFakeSelection(i2, this.selection);
            if (!this._fakeSelectionNeedsUpdate(t2)) {
              return;
            }
            if (!i2.parentElement || i2.parentElement != t2) {
              t2.appendChild(i2);
            }
            i2.textContent = this.selection.fakeSelectionLabel || "\xA0";
            const n2 = e2.getSelection();
            const o2 = e2.createRange();
            n2.removeAllRanges();
            o2.selectNodeContents(i2);
            n2.addRange(o2);
          }
          _updateDomSelection(t2) {
            const e2 = t2.ownerDocument.defaultView.getSelection();
            if (!this._domSelectionNeedsUpdate(e2)) {
              return;
            }
            const i2 = this.domConverter.viewPositionToDom(this.selection.anchor);
            const n2 = this.domConverter.viewPositionToDom(this.selection.focus);
            t2.focus();
            e2.collapse(i2.parent, i2.offset);
            e2.extend(n2.parent, n2.offset);
            if (Al.isGecko) {
              Ed(n2, e2);
            }
          }
          _domSelectionNeedsUpdate(t2) {
            if (!this.domConverter.isDomSelectionCorrect(t2)) {
              return true;
            }
            const e2 = t2 && this.domConverter.domSelectionToView(t2);
            if (e2 && this.selection.isEqual(e2)) {
              return false;
            }
            if (!this.selection.isCollapsed && this.selection.isSimilar(e2)) {
              return false;
            }
            return true;
          }
          _fakeSelectionNeedsUpdate(t2) {
            const e2 = this._fakeSelectionContainer;
            const i2 = t2.ownerDocument.getSelection();
            if (!e2 || e2.parentElement !== t2) {
              return true;
            }
            if (i2.anchorNode !== e2 && !e2.contains(i2.anchorNode)) {
              return true;
            }
            return e2.textContent !== this.selection.fakeSelectionLabel;
          }
          _removeDomSelection() {
            for (const t2 of this.domDocuments) {
              const e2 = t2.getSelection();
              if (e2.rangeCount) {
                const e3 = t2.activeElement;
                const i2 = this.domConverter.mapDomToView(e3);
                if (e3 && i2) {
                  t2.getSelection().removeAllRanges();
                }
              }
            }
          }
          _removeFakeSelection() {
            const t2 = this._fakeSelectionContainer;
            if (t2) {
              t2.remove();
            }
          }
          _updateFocus() {
            if (this.isFocused) {
              const t2 = this.selection.editableElement;
              if (t2) {
                this.domConverter.focus(t2);
              }
            }
          }
        }
        vs(Cd, Jc);
        function Ad(t2) {
          if (t2.getAttribute("contenteditable") == "false") {
            return false;
          }
          const e2 = t2.findAncestor((t3) => t3.hasAttribute("contenteditable"));
          return !e2 || e2.getAttribute("contenteditable") == "true";
        }
        function Td(t2, e2, i2) {
          const n2 = e2 instanceof Array ? e2 : e2.childNodes;
          const o2 = n2[i2];
          if (od(o2)) {
            o2.data = cd + o2.data;
            return o2;
          } else {
            const o3 = t2.createTextNode(cd);
            if (Array.isArray(e2)) {
              n2.splice(i2, 0, o3);
            } else {
              vd(e2, i2, o3);
            }
            return o3;
          }
        }
        function Pd(t2, e2) {
          return xd(t2) && xd(e2) && !od(t2) && !od(e2) && t2.tagName.toLowerCase() === e2.tagName.toLowerCase();
        }
        function Sd(t2, e2, i2) {
          if (e2 === i2) {
            return true;
          } else if (od(e2) && od(i2)) {
            return e2.data === i2.data;
          } else if (t2.isBlockFiller(e2) && t2.isBlockFiller(i2)) {
            return true;
          }
          return false;
        }
        function Ed(t2, e2) {
          const i2 = t2.parent;
          if (i2.nodeType != Node.ELEMENT_NODE || t2.offset != i2.childNodes.length - 1) {
            return;
          }
          const n2 = i2.childNodes[t2.offset];
          if (n2 && n2.tagName == "BR") {
            e2.addRange(e2.getRangeAt(0));
          }
        }
        function Rd(t2, e2) {
          const i2 = Array.from(t2);
          if (i2.length == 0 || !e2) {
            return i2;
          }
          const n2 = i2[i2.length - 1];
          if (n2 == e2) {
            i2.pop();
          }
          return i2;
        }
        function Od(t2) {
          const e2 = t2.createElement("div");
          Object.assign(e2.style, {position: "fixed", top: 0, left: "-9999px", width: "42px"});
          e2.textContent = "\xA0";
          return e2;
        }
        var Id = {window, document};
        function Vd(t2) {
          let e2 = 0;
          while (t2.previousSibling) {
            t2 = t2.previousSibling;
            e2++;
          }
          return e2;
        }
        function Nd(t2) {
          const e2 = [];
          while (t2 && t2.nodeType != Node.DOCUMENT_NODE) {
            e2.unshift(t2);
            t2 = t2.parentNode;
          }
          return e2;
        }
        function Md(t2, e2) {
          const i2 = Nd(t2);
          const n2 = Nd(e2);
          let o2 = 0;
          while (i2[o2] == n2[o2] && i2[o2]) {
            o2++;
          }
          return o2 === 0 ? null : i2[o2 - 1];
        }
        const Bd = sd(document);
        class zd {
          constructor(t2, e2 = {}) {
            this.document = t2;
            this.blockFillerMode = e2.blockFillerMode || "br";
            this.preElements = ["pre"];
            this.blockElements = ["p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "li", "dd", "dt", "figcaption"];
            this._blockFiller = this.blockFillerMode == "br" ? sd : rd;
            this._domToViewMapping = new WeakMap();
            this._viewToDomMapping = new WeakMap();
            this._fakeSelectionMapping = new WeakMap();
          }
          bindFakeSelection(t2, e2) {
            this._fakeSelectionMapping.set(t2, new gl(e2));
          }
          fakeSelectionToView(t2) {
            return this._fakeSelectionMapping.get(t2);
          }
          bindElements(t2, e2) {
            this._domToViewMapping.set(t2, e2);
            this._viewToDomMapping.set(e2, t2);
          }
          unbindDomElement(t2) {
            const e2 = this._domToViewMapping.get(t2);
            if (e2) {
              this._domToViewMapping.delete(t2);
              this._viewToDomMapping.delete(e2);
              for (const e3 of Array.from(t2.childNodes)) {
                this.unbindDomElement(e3);
              }
            }
          }
          bindDocumentFragments(t2, e2) {
            this._domToViewMapping.set(t2, e2);
            this._viewToDomMapping.set(e2, t2);
          }
          viewToDom(t2, e2, i2 = {}) {
            if (t2.is("text")) {
              const i3 = this._processDataFromViewText(t2);
              return e2.createTextNode(i3);
            } else {
              if (this.mapViewToDom(t2)) {
                return this.mapViewToDom(t2);
              }
              let n2;
              if (t2.is("documentFragment")) {
                n2 = e2.createDocumentFragment();
                if (i2.bind) {
                  this.bindDocumentFragments(n2, t2);
                }
              } else if (t2.is("uiElement")) {
                n2 = t2.render(e2);
                if (i2.bind) {
                  this.bindElements(n2, t2);
                }
                return n2;
              } else {
                if (t2.hasAttribute("xmlns")) {
                  n2 = e2.createElementNS(t2.getAttribute("xmlns"), t2.name);
                } else {
                  n2 = e2.createElement(t2.name);
                }
                if (i2.bind) {
                  this.bindElements(n2, t2);
                }
                for (const e3 of t2.getAttributeKeys()) {
                  n2.setAttribute(e3, t2.getAttribute(e3));
                }
              }
              if (i2.withChildren || i2.withChildren === void 0) {
                for (const o2 of this.viewChildrenToDom(t2, e2, i2)) {
                  n2.appendChild(o2);
                }
              }
              return n2;
            }
          }
          *viewChildrenToDom(t2, e2, i2 = {}) {
            const n2 = t2.getFillerOffset && t2.getFillerOffset();
            let o2 = 0;
            for (const r2 of t2.getChildren()) {
              if (n2 === o2) {
                yield this._blockFiller(e2);
              }
              yield this.viewToDom(r2, e2, i2);
              o2++;
            }
            if (n2 === o2) {
              yield this._blockFiller(e2);
            }
          }
          viewRangeToDom(t2) {
            const e2 = this.viewPositionToDom(t2.start);
            const i2 = this.viewPositionToDom(t2.end);
            const n2 = document.createRange();
            n2.setStart(e2.parent, e2.offset);
            n2.setEnd(i2.parent, i2.offset);
            return n2;
          }
          viewPositionToDom(t2) {
            const e2 = t2.parent;
            if (e2.is("text")) {
              const i2 = this.findCorrespondingDomText(e2);
              if (!i2) {
                return null;
              }
              let n2 = t2.offset;
              if (ld(i2)) {
                n2 += ad;
              }
              return {parent: i2, offset: n2};
            } else {
              let i2, n2, o2;
              if (t2.offset === 0) {
                i2 = this.mapViewToDom(e2);
                if (!i2) {
                  return null;
                }
                o2 = i2.childNodes[0];
              } else {
                const e3 = t2.nodeBefore;
                n2 = e3.is("text") ? this.findCorrespondingDomText(e3) : this.mapViewToDom(t2.nodeBefore);
                if (!n2) {
                  return null;
                }
                i2 = n2.parentNode;
                o2 = n2.nextSibling;
              }
              if (od(o2) && ld(o2)) {
                return {parent: o2, offset: ad};
              }
              const r2 = n2 ? Vd(n2) + 1 : 0;
              return {parent: i2, offset: r2};
            }
          }
          domToView(t2, e2 = {}) {
            if (this.isBlockFiller(t2, this.blockFillerMode)) {
              return null;
            }
            const i2 = this.getParentUIElement(t2, this._domToViewMapping);
            if (i2) {
              return i2;
            }
            if (od(t2)) {
              if (dd(t2)) {
                return null;
              } else {
                const e3 = this._processDataFromDomText(t2);
                return e3 === "" ? null : new Ls(this.document, e3);
              }
            } else if (this.isComment(t2)) {
              return null;
            } else {
              if (this.mapDomToView(t2)) {
                return this.mapDomToView(t2);
              }
              let i3;
              if (this.isDocumentFragment(t2)) {
                i3 = new ql(this.document);
                if (e2.bind) {
                  this.bindDocumentFragments(t2, i3);
                }
              } else {
                const n2 = e2.keepOriginalCase ? t2.tagName : t2.tagName.toLowerCase();
                i3 = new zc(this.document, n2);
                if (e2.bind) {
                  this.bindElements(t2, i3);
                }
                const o2 = t2.attributes;
                for (let t3 = o2.length - 1; t3 >= 0; t3--) {
                  i3._setAttribute(o2[t3].name, o2[t3].value);
                }
              }
              if (e2.withChildren || e2.withChildren === void 0) {
                for (const n2 of this.domChildrenToView(t2, e2)) {
                  i3._appendChild(n2);
                }
              }
              return i3;
            }
          }
          *domChildrenToView(t2, e2 = {}) {
            for (let i2 = 0; i2 < t2.childNodes.length; i2++) {
              const n2 = t2.childNodes[i2];
              const o2 = this.domToView(n2, e2);
              if (o2 !== null) {
                yield o2;
              }
            }
          }
          domSelectionToView(t2) {
            if (t2.rangeCount === 1) {
              let e3 = t2.getRangeAt(0).startContainer;
              if (od(e3)) {
                e3 = e3.parentNode;
              }
              const i3 = this.fakeSelectionToView(e3);
              if (i3) {
                return i3;
              }
            }
            const e2 = this.isDomSelectionBackward(t2);
            const i2 = [];
            for (let e3 = 0; e3 < t2.rangeCount; e3++) {
              const n2 = t2.getRangeAt(e3);
              const o2 = this.domRangeToView(n2);
              if (o2) {
                i2.push(o2);
              }
            }
            return new gl(i2, {backward: e2});
          }
          domRangeToView(t2) {
            const e2 = this.domPositionToView(t2.startContainer, t2.startOffset);
            const i2 = this.domPositionToView(t2.endContainer, t2.endOffset);
            if (e2 && i2) {
              return new ul(e2, i2);
            }
            return null;
          }
          domPositionToView(t2, e2) {
            if (this.isBlockFiller(t2, this.blockFillerMode)) {
              return this.domPositionToView(t2.parentNode, Vd(t2));
            }
            const i2 = this.mapDomToView(t2);
            if (i2 && i2.is("uiElement")) {
              return dl._createBefore(i2);
            }
            if (od(t2)) {
              if (dd(t2)) {
                return this.domPositionToView(t2.parentNode, Vd(t2));
              }
              const i3 = this.findCorrespondingViewText(t2);
              let n2 = e2;
              if (!i3) {
                return null;
              }
              if (ld(t2)) {
                n2 -= ad;
                n2 = n2 < 0 ? 0 : n2;
              }
              return new dl(i3, n2);
            } else {
              if (e2 === 0) {
                const e3 = this.mapDomToView(t2);
                if (e3) {
                  return new dl(e3, 0);
                }
              } else {
                const i3 = t2.childNodes[e2 - 1];
                const n2 = od(i3) ? this.findCorrespondingViewText(i3) : this.mapDomToView(i3);
                if (n2 && n2.parent) {
                  return new dl(n2.parent, n2.index + 1);
                }
              }
              return null;
            }
          }
          mapDomToView(t2) {
            return this.getParentUIElement(t2) || this._domToViewMapping.get(t2);
          }
          findCorrespondingViewText(t2) {
            if (dd(t2)) {
              return null;
            }
            const e2 = this.getParentUIElement(t2);
            if (e2) {
              return e2;
            }
            const i2 = t2.previousSibling;
            if (i2) {
              if (!this.isElement(i2)) {
                return null;
              }
              const t3 = this.mapDomToView(i2);
              if (t3) {
                const e3 = t3.nextSibling;
                if (e3 instanceof Ls) {
                  return t3.nextSibling;
                } else {
                  return null;
                }
              }
            } else {
              const e3 = this.mapDomToView(t2.parentNode);
              if (e3) {
                const t3 = e3.getChild(0);
                if (t3 instanceof Ls) {
                  return t3;
                } else {
                  return null;
                }
              }
            }
            return null;
          }
          mapViewToDom(t2) {
            return this._viewToDomMapping.get(t2);
          }
          findCorrespondingDomText(t2) {
            const e2 = t2.previousSibling;
            if (e2 && this.mapViewToDom(e2)) {
              return this.mapViewToDom(e2).nextSibling;
            }
            if (!e2 && t2.parent && this.mapViewToDom(t2.parent)) {
              return this.mapViewToDom(t2.parent).childNodes[0];
            }
            return null;
          }
          focus(t2) {
            const e2 = this.mapViewToDom(t2);
            if (e2 && e2.ownerDocument.activeElement !== e2) {
              const {scrollX: t3, scrollY: i2} = Id.window;
              const n2 = [];
              Fd(e2, (t4) => {
                const {scrollLeft: e3, scrollTop: i3} = t4;
                n2.push([e3, i3]);
              });
              e2.focus();
              Fd(e2, (t4) => {
                const [e3, i3] = n2.shift();
                t4.scrollLeft = e3;
                t4.scrollTop = i3;
              });
              Id.window.scrollTo(t3, i2);
            }
          }
          isElement(t2) {
            return t2 && t2.nodeType == Node.ELEMENT_NODE;
          }
          isDocumentFragment(t2) {
            return t2 && t2.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
          }
          isComment(t2) {
            return t2 && t2.nodeType == Node.COMMENT_NODE;
          }
          isBlockFiller(t2) {
            if (this.blockFillerMode == "br") {
              return t2.isEqualNode(Bd);
            }
            if (t2.tagName === "BR" && jd(t2, this.blockElements) && t2.parentNode.childNodes.length === 1) {
              return true;
            }
            return Dd(t2, this.blockElements);
          }
          isDomSelectionBackward(t2) {
            if (t2.isCollapsed) {
              return false;
            }
            const e2 = document.createRange();
            e2.setStart(t2.anchorNode, t2.anchorOffset);
            e2.setEnd(t2.focusNode, t2.focusOffset);
            const i2 = e2.collapsed;
            e2.detach();
            return i2;
          }
          getParentUIElement(t2) {
            const e2 = Nd(t2);
            e2.pop();
            while (e2.length) {
              const t3 = e2.pop();
              const i2 = this._domToViewMapping.get(t3);
              if (i2 && i2.is("uiElement")) {
                return i2;
              }
            }
            return null;
          }
          isDomSelectionCorrect(t2) {
            return this._isDomSelectionPositionCorrect(t2.anchorNode, t2.anchorOffset) && this._isDomSelectionPositionCorrect(t2.focusNode, t2.focusOffset);
          }
          _isDomSelectionPositionCorrect(t2, e2) {
            if (od(t2) && ld(t2) && e2 < ad) {
              return false;
            }
            if (this.isElement(t2) && ld(t2.childNodes[e2])) {
              return false;
            }
            const i2 = this.mapDomToView(t2);
            if (i2 && i2.is("uiElement")) {
              return false;
            }
            return true;
          }
          _processDataFromViewText(t2) {
            let e2 = t2.data;
            if (t2.getAncestors().some((t3) => this.preElements.includes(t3.name))) {
              return e2;
            }
            if (e2.charAt(0) == " ") {
              const i2 = this._getTouchingViewTextNode(t2, false);
              const n2 = i2 && this._nodeEndsWithSpace(i2);
              if (n2 || !i2) {
                e2 = "\xA0" + e2.substr(1);
              }
            }
            if (e2.charAt(e2.length - 1) == " ") {
              const i2 = this._getTouchingViewTextNode(t2, true);
              if (e2.charAt(e2.length - 2) == " " || !i2 || i2.data.charAt(0) == " ") {
                e2 = e2.substr(0, e2.length - 1) + "\xA0";
              }
            }
            return e2.replace(/ {2}/g, " \xA0");
          }
          _nodeEndsWithSpace(t2) {
            if (t2.getAncestors().some((t3) => this.preElements.includes(t3.name))) {
              return false;
            }
            const e2 = this._processDataFromViewText(t2);
            return e2.charAt(e2.length - 1) == " ";
          }
          _processDataFromDomText(t2) {
            let e2 = t2.data;
            if (Ld(t2, this.preElements)) {
              return ud(t2);
            }
            e2 = e2.replace(/[ \n\t\r]{1,}/g, " ");
            const i2 = this._getTouchingInlineDomNode(t2, false);
            const n2 = this._getTouchingInlineDomNode(t2, true);
            const o2 = this._checkShouldLeftTrimDomText(i2);
            const r2 = this._checkShouldRightTrimDomText(t2, n2);
            if (o2) {
              e2 = e2.replace(/^ /, "");
            }
            if (r2) {
              e2 = e2.replace(/ $/, "");
            }
            e2 = ud(new Text(e2));
            e2 = e2.replace(/ \u00A0/g, "  ");
            if (/( |\u00A0)\u00A0$/.test(e2) || !n2 || n2.data && n2.data.charAt(0) == " ") {
              e2 = e2.replace(/\u00A0$/, " ");
            }
            if (o2) {
              e2 = e2.replace(/^\u00A0/, " ");
            }
            return e2;
          }
          _checkShouldLeftTrimDomText(t2) {
            if (!t2) {
              return true;
            }
            if (Kr(t2)) {
              return true;
            }
            return /[^\S\u00A0]/.test(t2.data.charAt(t2.data.length - 1));
          }
          _checkShouldRightTrimDomText(t2, e2) {
            if (e2) {
              return false;
            }
            return !ld(t2);
          }
          _getTouchingViewTextNode(t2, e2) {
            const i2 = new ll({
              startPosition: e2 ? dl._createAfter(t2) : dl._createBefore(t2),
              direction: e2 ? "forward" : "backward"
            });
            for (const t3 of i2) {
              if (t3.item.is("containerElement")) {
                return null;
              } else if (t3.item.is("br")) {
                return null;
              } else if (t3.item.is("textProxy")) {
                return t3.item;
              }
            }
            return null;
          }
          _getTouchingInlineDomNode(t2, e2) {
            if (!t2.parentNode) {
              return null;
            }
            const i2 = e2 ? "nextNode" : "previousNode";
            const n2 = t2.ownerDocument;
            const o2 = Nd(t2)[0];
            const r2 = n2.createTreeWalker(o2, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {
              acceptNode(t3) {
                if (od(t3)) {
                  return NodeFilter.FILTER_ACCEPT;
                }
                if (t3.tagName == "BR") {
                  return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_SKIP;
              }
            });
            r2.currentNode = t2;
            const s2 = r2[i2]();
            if (s2 !== null) {
              const e3 = Md(t2, s2);
              if (e3 && !Ld(t2, this.blockElements, e3) && !Ld(s2, this.blockElements, e3)) {
                return s2;
              }
            }
            return null;
          }
        }
        function Ld(t2, e2, i2) {
          let n2 = Nd(t2);
          if (i2) {
            n2 = n2.slice(n2.indexOf(i2) + 1);
          }
          return n2.some((t3) => t3.tagName && e2.includes(t3.tagName.toLowerCase()));
        }
        function Fd(t2, e2) {
          while (t2 && t2 != Id.document) {
            e2(t2);
            t2 = t2.parentNode;
          }
        }
        function Dd(t2, e2) {
          const i2 = od(t2) && t2.data == "\xA0";
          return i2 && jd(t2, e2) && t2.parentNode.childNodes.length === 1;
        }
        function jd(t2, e2) {
          const i2 = t2.parentNode;
          return i2 && i2.tagName && e2.includes(i2.tagName.toLowerCase());
        }
        function Hd(t2) {
          const e2 = Object.prototype.toString.apply(t2);
          if (e2 == "[object Window]") {
            return true;
          }
          if (e2 == "[object global]") {
            return true;
          }
          return false;
        }
        const Wd = qc({}, ds, {
          listenTo(t2, ...e2) {
            if (xd(t2) || Hd(t2)) {
              const i2 = this._getProxyEmitter(t2) || new Ud(t2);
              i2.attach(...e2);
              t2 = i2;
            }
            ds.listenTo.call(this, t2, ...e2);
          },
          stopListening(t2, e2, i2) {
            if (xd(t2) || Hd(t2)) {
              const e3 = this._getProxyEmitter(t2);
              if (!e3) {
                return;
              }
              t2 = e3;
            }
            ds.stopListening.call(this, t2, e2, i2);
            if (t2 instanceof Ud) {
              t2.detach(e2);
            }
          },
          _getProxyEmitter(t2) {
            return us(this, $d(t2));
          }
        });
        var qd = Wd;
        class Ud {
          constructor(t2) {
            hs(this, $d(t2));
            this._domNode = t2;
          }
        }
        qc(Ud.prototype, ds, {
          attach(t2, e2, i2 = {}) {
            if (this._domListeners && this._domListeners[t2]) {
              return;
            }
            const n2 = this._createDomListener(t2, !!i2.useCapture);
            this._domNode.addEventListener(t2, n2, !!i2.useCapture);
            if (!this._domListeners) {
              this._domListeners = {};
            }
            this._domListeners[t2] = n2;
          },
          detach(t2) {
            let e2;
            if (this._domListeners[t2] && (!(e2 = this._events[t2]) || !e2.callbacks.length)) {
              this._domListeners[t2].removeListener();
            }
          },
          _createDomListener(t2, e2) {
            const i2 = (e3) => {
              this.fire(t2, e3);
            };
            i2.removeListener = () => {
              this._domNode.removeEventListener(t2, i2, e2);
              delete this._domListeners[t2];
            };
            return i2;
          }
        });
        function $d(t2) {
          return t2["data-ck-expando"] || (t2["data-ck-expando"] = is());
        }
        class Gd {
          constructor(t2) {
            this.view = t2;
            this.document = t2.document;
            this.isEnabled = false;
          }
          enable() {
            this.isEnabled = true;
          }
          disable() {
            this.isEnabled = false;
          }
          destroy() {
            this.disable();
            this.stopListening();
          }
        }
        vs(Gd, qd);
        var Kd = "__lodash_hash_undefined__";
        function Jd(t2) {
          this.__data__.set(t2, Kd);
          return this;
        }
        var Yd = Jd;
        function Qd(t2) {
          return this.__data__.has(t2);
        }
        var Xd = Qd;
        function Zd(t2) {
          var e2 = -1, i2 = t2 == null ? 0 : t2.length;
          this.__data__ = new _e();
          while (++e2 < i2) {
            this.add(t2[e2]);
          }
        }
        Zd.prototype.add = Zd.prototype.push = Yd;
        Zd.prototype.has = Xd;
        var tu = Zd;
        function eu(t2, e2) {
          var i2 = -1, n2 = t2 == null ? 0 : t2.length;
          while (++i2 < n2) {
            if (e2(t2[i2], i2, t2)) {
              return true;
            }
          }
          return false;
        }
        var iu = eu;
        function nu(t2, e2) {
          return t2.has(e2);
        }
        var ou = nu;
        var ru = 1, su = 2;
        function au(t2, e2, i2, n2, o2, r2) {
          var s2 = i2 & ru, a2 = t2.length, c2 = e2.length;
          if (a2 != c2 && !(s2 && c2 > a2)) {
            return false;
          }
          var l2 = r2.get(t2);
          if (l2 && r2.get(e2)) {
            return l2 == e2;
          }
          var d2 = -1, u2 = true, h2 = i2 & su ? new tu() : void 0;
          r2.set(t2, e2);
          r2.set(e2, t2);
          while (++d2 < a2) {
            var f2 = t2[d2], g2 = e2[d2];
            if (n2) {
              var m2 = s2 ? n2(g2, f2, d2, e2, t2, r2) : n2(f2, g2, d2, t2, e2, r2);
            }
            if (m2 !== void 0) {
              if (m2) {
                continue;
              }
              u2 = false;
              break;
            }
            if (h2) {
              if (!iu(e2, function(t3, e3) {
                if (!ou(h2, e3) && (f2 === t3 || o2(f2, t3, i2, n2, r2))) {
                  return h2.push(e3);
                }
              })) {
                u2 = false;
                break;
              }
            } else if (!(f2 === g2 || o2(f2, g2, i2, n2, r2))) {
              u2 = false;
              break;
            }
          }
          r2["delete"](t2);
          r2["delete"](e2);
          return u2;
        }
        var cu = au;
        function lu(t2) {
          var e2 = -1, i2 = Array(t2.size);
          t2.forEach(function(t3, n2) {
            i2[++e2] = [n2, t3];
          });
          return i2;
        }
        var du = lu;
        function uu(t2) {
          var e2 = -1, i2 = Array(t2.size);
          t2.forEach(function(t3) {
            i2[++e2] = t3;
          });
          return i2;
        }
        var hu = uu;
        var fu = 1, gu = 2;
        var mu = "[object Boolean]", pu = "[object Date]", bu = "[object Error]", wu = "[object Map]", ku = "[object Number]", _u = "[object RegExp]", vu = "[object Set]", yu = "[object String]", xu = "[object Symbol]";
        var Cu = "[object ArrayBuffer]", Au = "[object DataView]";
        var Tu = r ? r.prototype : void 0, Pu = Tu ? Tu.valueOf : void 0;
        function Su(t2, e2, i2, n2, o2, r2, s2) {
          switch (i2) {
            case Au:
              if (t2.byteLength != e2.byteLength || t2.byteOffset != e2.byteOffset) {
                return false;
              }
              t2 = t2.buffer;
              e2 = e2.buffer;
            case Cu:
              if (t2.byteLength != e2.byteLength || !r2(new fo(t2), new fo(e2))) {
                return false;
              }
              return true;
            case mu:
            case pu:
            case ku:
              return L(+t2, +e2);
            case bu:
              return t2.name == e2.name && t2.message == e2.message;
            case _u:
            case yu:
              return t2 == e2 + "";
            case wu:
              var a2 = du;
            case vu:
              var c2 = n2 & fu;
              a2 || (a2 = hu);
              if (t2.size != e2.size && !c2) {
                return false;
              }
              var l2 = s2.get(t2);
              if (l2) {
                return l2 == e2;
              }
              n2 |= gu;
              s2.set(t2, e2);
              var d2 = cu(a2(t2), a2(e2), n2, o2, r2, s2);
              s2["delete"](t2);
              return d2;
            case xu:
              if (Pu) {
                return Pu.call(t2) == Pu.call(e2);
              }
          }
          return false;
        }
        var Eu = Su;
        var Ru = 1;
        var Ou = Object.prototype;
        var Iu = Ou.hasOwnProperty;
        function Vu(t2, e2, i2, n2, o2, r2) {
          var s2 = i2 & Ru, a2 = zn(t2), c2 = a2.length, l2 = zn(e2), d2 = l2.length;
          if (c2 != d2 && !s2) {
            return false;
          }
          var u2 = c2;
          while (u2--) {
            var h2 = a2[u2];
            if (!(s2 ? h2 in e2 : Iu.call(e2, h2))) {
              return false;
            }
          }
          var f2 = r2.get(t2);
          if (f2 && r2.get(e2)) {
            return f2 == e2;
          }
          var g2 = true;
          r2.set(t2, e2);
          r2.set(e2, t2);
          var m2 = s2;
          while (++u2 < c2) {
            h2 = a2[u2];
            var p2 = t2[h2], b2 = e2[h2];
            if (n2) {
              var w2 = s2 ? n2(b2, p2, h2, e2, t2, r2) : n2(p2, b2, h2, t2, e2, r2);
            }
            if (!(w2 === void 0 ? p2 === b2 || o2(p2, b2, i2, n2, r2) : w2)) {
              g2 = false;
              break;
            }
            m2 || (m2 = h2 == "constructor");
          }
          if (g2 && !m2) {
            var k2 = t2.constructor, _2 = e2.constructor;
            if (k2 != _2 && ("constructor" in t2 && "constructor" in e2) && !(typeof k2 == "function" && k2 instanceof k2 && typeof _2 == "function" && _2 instanceof _2)) {
              g2 = false;
            }
          }
          r2["delete"](t2);
          r2["delete"](e2);
          return g2;
        }
        var Nu = Vu;
        var Mu = 1;
        var Bu = "[object Arguments]", zu = "[object Array]", Lu = "[object Object]";
        var Fu = Object.prototype;
        var Du = Fu.hasOwnProperty;
        function ju(t2, e2, i2, n2, o2, r2) {
          var s2 = Je(t2), a2 = Je(e2), c2 = s2 ? zu : so(t2), l2 = a2 ? zu : so(e2);
          c2 = c2 == Bu ? Lu : c2;
          l2 = l2 == Bu ? Lu : l2;
          var d2 = c2 == Lu, u2 = l2 == Lu, h2 = c2 == l2;
          if (h2 && Object(Ye["a"])(t2)) {
            if (!Object(Ye["a"])(e2)) {
              return false;
            }
            s2 = true;
            d2 = false;
          }
          if (h2 && !d2) {
            r2 || (r2 = new Ae());
            return s2 || Bi(t2) ? cu(t2, e2, i2, n2, o2, r2) : Eu(t2, e2, c2, i2, n2, o2, r2);
          }
          if (!(i2 & Mu)) {
            var f2 = d2 && Du.call(t2, "__wrapped__"), g2 = u2 && Du.call(e2, "__wrapped__");
            if (f2 || g2) {
              var m2 = f2 ? t2.value() : t2, p2 = g2 ? e2.value() : e2;
              r2 || (r2 = new Ae());
              return o2(m2, p2, i2, n2, r2);
            }
          }
          if (!h2) {
            return false;
          }
          r2 || (r2 = new Ae());
          return Nu(t2, e2, i2, n2, o2, r2);
        }
        var Hu = ju;
        function Wu(t2, e2, i2, n2, o2) {
          if (t2 === e2) {
            return true;
          }
          if (t2 == null || e2 == null || !T(t2) && !T(e2)) {
            return t2 !== t2 && e2 !== e2;
          }
          return Hu(t2, e2, i2, n2, Wu, o2);
        }
        var qu = Wu;
        function Uu(t2, e2, i2) {
          i2 = typeof i2 == "function" ? i2 : void 0;
          var n2 = i2 ? i2(t2, e2) : void 0;
          return n2 === void 0 ? qu(t2, e2, void 0, i2) : !!n2;
        }
        var $u = Uu;
        class Gu extends Gd {
          constructor(t2) {
            super(t2);
            this._config = {childList: true, characterData: true, characterDataOldValue: true, subtree: true};
            this.domConverter = t2.domConverter;
            this.renderer = t2._renderer;
            this._domElements = [];
            this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
          }
          flush() {
            this._onMutations(this._mutationObserver.takeRecords());
          }
          observe(t2) {
            this._domElements.push(t2);
            if (this.isEnabled) {
              this._mutationObserver.observe(t2, this._config);
            }
          }
          enable() {
            super.enable();
            for (const t2 of this._domElements) {
              this._mutationObserver.observe(t2, this._config);
            }
          }
          disable() {
            super.disable();
            this._mutationObserver.disconnect();
          }
          destroy() {
            super.destroy();
            this._mutationObserver.disconnect();
          }
          _onMutations(t2) {
            if (t2.length === 0) {
              return;
            }
            const e2 = this.domConverter;
            const i2 = new Map();
            const n2 = new Set();
            for (const i3 of t2) {
              if (i3.type === "childList") {
                const t3 = e2.mapDomToView(i3.target);
                if (t3 && t3.is("uiElement")) {
                  continue;
                }
                if (t3 && !this._isBogusBrMutation(i3)) {
                  n2.add(t3);
                }
              }
            }
            for (const o3 of t2) {
              const t3 = e2.mapDomToView(o3.target);
              if (t3 && t3.is("uiElement")) {
                continue;
              }
              if (o3.type === "characterData") {
                const t4 = e2.findCorrespondingViewText(o3.target);
                if (t4 && !n2.has(t4.parent)) {
                  i2.set(t4, {type: "text", oldText: t4.data, newText: ud(o3.target), node: t4});
                } else if (!t4 && ld(o3.target)) {
                  n2.add(e2.mapDomToView(o3.target.parentNode));
                }
              }
            }
            const o2 = [];
            for (const t3 of i2.values()) {
              this.renderer.markToSync("text", t3.node);
              o2.push(t3);
            }
            for (const t3 of n2) {
              const i3 = e2.mapViewToDom(t3);
              const n3 = Array.from(t3.getChildren());
              const r3 = Array.from(e2.domChildrenToView(i3, {withChildren: false}));
              if (!$u(n3, r3, a2)) {
                this.renderer.markToSync("children", t3);
                o2.push({type: "children", oldChildren: n3, newChildren: r3, node: t3});
              }
            }
            const r2 = t2[0].target.ownerDocument.getSelection();
            let s2 = null;
            if (r2 && r2.anchorNode) {
              const t3 = e2.domPositionToView(r2.anchorNode, r2.anchorOffset);
              const i3 = e2.domPositionToView(r2.focusNode, r2.focusOffset);
              if (t3 && i3) {
                s2 = new gl(t3);
                s2.setFocus(i3);
              }
            }
            if (o2.length) {
              this.document.fire("mutations", o2, s2);
              this.view.forceRender();
            }
            function a2(t3, e3) {
              if (Array.isArray(t3)) {
                return;
              }
              if (t3 === e3) {
                return true;
              } else if (t3.is("text") && e3.is("text")) {
                return t3.data === e3.data;
              }
              return false;
            }
          }
          _isBogusBrMutation(t2) {
            let e2 = null;
            if (t2.nextSibling === null && t2.removedNodes.length === 0 && t2.addedNodes.length == 1) {
              e2 = this.domConverter.domToView(t2.addedNodes[0], {withChildren: false});
            }
            return e2 && e2.is("element", "br");
          }
        }
        class Ku {
          constructor(t2, e2, i2) {
            this.view = t2;
            this.document = t2.document;
            this.domEvent = e2;
            this.domTarget = e2.target;
            qc(this, i2);
          }
          get target() {
            return this.view.domConverter.mapDomToView(this.domTarget);
          }
          preventDefault() {
            this.domEvent.preventDefault();
          }
          stopPropagation() {
            this.domEvent.stopPropagation();
          }
        }
        class Ju extends Gd {
          constructor(t2) {
            super(t2);
            this.useCapture = false;
          }
          observe(t2) {
            const e2 = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
            e2.forEach((e3) => {
              this.listenTo(t2, e3, (t3, e4) => {
                if (this.isEnabled) {
                  this.onDomEvent(e4);
                }
              }, {useCapture: this.useCapture});
            });
          }
          fire(t2, e2, i2) {
            if (this.isEnabled) {
              this.document.fire(t2, new Ku(this.view, e2, i2));
            }
          }
        }
        class Yu extends Ju {
          constructor(t2) {
            super(t2);
            this.domEventType = ["keydown", "keyup"];
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2, {
              keyCode: t2.keyCode,
              altKey: t2.altKey,
              ctrlKey: t2.ctrlKey || t2.metaKey,
              shiftKey: t2.shiftKey,
              get keystroke() {
                return Ml(this);
              }
            });
          }
        }
        var Qu = function() {
          return n["a"].Date.now();
        };
        var Xu = Qu;
        var Zu = 0 / 0;
        var th = /^\s+|\s+$/g;
        var eh = /^[-+]0x[0-9a-f]+$/i;
        var ih = /^0b[01]+$/i;
        var nh = /^0o[0-7]+$/i;
        var oh = parseInt;
        function rh(t2) {
          if (typeof t2 == "number") {
            return t2;
          }
          if (Qs(t2)) {
            return Zu;
          }
          if (ct(t2)) {
            var e2 = typeof t2.valueOf == "function" ? t2.valueOf() : t2;
            t2 = ct(e2) ? e2 + "" : e2;
          }
          if (typeof t2 != "string") {
            return t2 === 0 ? t2 : +t2;
          }
          t2 = t2.replace(th, "");
          var i2 = ih.test(t2);
          return i2 || nh.test(t2) ? oh(t2.slice(2), i2 ? 2 : 8) : eh.test(t2) ? Zu : +t2;
        }
        var sh = rh;
        var ah = "Expected a function";
        var ch = Math.max, lh = Math.min;
        function dh(t2, e2, i2) {
          var n2, o2, r2, s2, a2, c2, l2 = 0, d2 = false, u2 = false, h2 = true;
          if (typeof t2 != "function") {
            throw new TypeError(ah);
          }
          e2 = sh(e2) || 0;
          if (ct(i2)) {
            d2 = !!i2.leading;
            u2 = "maxWait" in i2;
            r2 = u2 ? ch(sh(i2.maxWait) || 0, e2) : r2;
            h2 = "trailing" in i2 ? !!i2.trailing : h2;
          }
          function f2(e3) {
            var i3 = n2, r3 = o2;
            n2 = o2 = void 0;
            l2 = e3;
            s2 = t2.apply(r3, i3);
            return s2;
          }
          function g2(t3) {
            l2 = t3;
            a2 = setTimeout(b2, e2);
            return d2 ? f2(t3) : s2;
          }
          function m2(t3) {
            var i3 = t3 - c2, n3 = t3 - l2, o3 = e2 - i3;
            return u2 ? lh(o3, r2 - n3) : o3;
          }
          function p2(t3) {
            var i3 = t3 - c2, n3 = t3 - l2;
            return c2 === void 0 || i3 >= e2 || i3 < 0 || u2 && n3 >= r2;
          }
          function b2() {
            var t3 = Xu();
            if (p2(t3)) {
              return w2(t3);
            }
            a2 = setTimeout(b2, m2(t3));
          }
          function w2(t3) {
            a2 = void 0;
            if (h2 && n2) {
              return f2(t3);
            }
            n2 = o2 = void 0;
            return s2;
          }
          function k2() {
            if (a2 !== void 0) {
              clearTimeout(a2);
            }
            l2 = 0;
            n2 = c2 = o2 = a2 = void 0;
          }
          function _2() {
            return a2 === void 0 ? s2 : w2(Xu());
          }
          function v2() {
            var t3 = Xu(), i3 = p2(t3);
            n2 = arguments;
            o2 = this;
            c2 = t3;
            if (i3) {
              if (a2 === void 0) {
                return g2(c2);
              }
              if (u2) {
                clearTimeout(a2);
                a2 = setTimeout(b2, e2);
                return f2(c2);
              }
            }
            if (a2 === void 0) {
              a2 = setTimeout(b2, e2);
            }
            return s2;
          }
          v2.cancel = k2;
          v2.flush = _2;
          return v2;
        }
        var uh = dh;
        class hh extends Gd {
          constructor(t2) {
            super(t2);
            this._fireSelectionChangeDoneDebounced = uh((t3) => this.document.fire("selectionChangeDone", t3), 200);
          }
          observe() {
            const t2 = this.document;
            t2.on("keydown", (e2, i2) => {
              const n2 = t2.selection;
              if (n2.isFake && fh(i2.keyCode) && this.isEnabled) {
                i2.preventDefault();
                this._handleSelectionMove(i2.keyCode);
              }
            }, {priority: "lowest"});
          }
          destroy() {
            super.destroy();
            this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionMove(t2) {
            const e2 = this.document.selection;
            const i2 = new gl(e2.getRanges(), {backward: e2.isBackward, fake: false});
            if (t2 == Nl.arrowleft || t2 == Nl.arrowup) {
              i2.setTo(i2.getFirstPosition());
            }
            if (t2 == Nl.arrowright || t2 == Nl.arrowdown) {
              i2.setTo(i2.getLastPosition());
            }
            const n2 = {oldSelection: e2, newSelection: i2, domSelection: null};
            this.document.fire("selectionChange", n2);
            this._fireSelectionChangeDoneDebounced(n2);
          }
        }
        function fh(t2) {
          return t2 == Nl.arrowright || t2 == Nl.arrowleft || t2 == Nl.arrowup || t2 == Nl.arrowdown;
        }
        class gh extends Gd {
          constructor(t2) {
            super(t2);
            this.mutationObserver = t2.getObserver(Gu);
            this.selection = this.document.selection;
            this.domConverter = t2.domConverter;
            this._documents = new WeakSet();
            this._fireSelectionChangeDoneDebounced = uh((t3) => this.document.fire("selectionChangeDone", t3), 200);
            this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3);
            this._loopbackCounter = 0;
          }
          observe(t2) {
            const e2 = t2.ownerDocument;
            if (this._documents.has(e2)) {
              return;
            }
            this.listenTo(e2, "selectionchange", () => {
              this._handleSelectionChange(e2);
            });
            this._documents.add(e2);
          }
          destroy() {
            super.destroy();
            clearInterval(this._clearInfiniteLoopInterval);
            this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionChange(t2) {
            if (!this.isEnabled) {
              return;
            }
            this.mutationObserver.flush();
            const e2 = t2.defaultView.getSelection();
            const i2 = this.domConverter.domSelectionToView(e2);
            if (i2.rangeCount == 0) {
              return;
            }
            if (this.selection.isEqual(i2) && this.domConverter.isDomSelectionCorrect(e2)) {
              return;
            }
            if (++this._loopbackCounter > 60) {
              return;
            }
            if (this.selection.isSimilar(i2)) {
              this.view.forceRender();
            } else {
              const t3 = {oldSelection: this.selection, newSelection: i2, domSelection: e2};
              this.document.fire("selectionChange", t3);
              this._fireSelectionChangeDoneDebounced(t3);
            }
          }
          _clearInfiniteLoop() {
            this._loopbackCounter = 0;
          }
        }
        class mh extends Ju {
          constructor(t2) {
            super(t2);
            this.domEventType = ["focus", "blur"];
            this.useCapture = true;
            const e2 = this.document;
            e2.on("focus", () => {
              e2.isFocused = true;
              this._renderTimeoutId = setTimeout(() => t2.forceRender(), 50);
            });
            e2.on("blur", (i2, n2) => {
              const o2 = e2.selection.editableElement;
              if (o2 === null || o2 === n2.target) {
                e2.isFocused = false;
                t2.forceRender();
              }
            });
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
          destroy() {
            if (this._renderTimeoutId) {
              clearTimeout(this._renderTimeoutId);
            }
            super.destroy();
          }
        }
        class ph extends Ju {
          constructor(t2) {
            super(t2);
            this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
            const e2 = this.document;
            e2.on("compositionstart", () => {
              e2.isComposing = true;
            });
            e2.on("compositionend", () => {
              e2.isComposing = false;
            });
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        class bh extends Ju {
          constructor(t2) {
            super(t2);
            this.domEventType = ["beforeinput"];
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        function wh(t2) {
          return Object.prototype.toString.apply(t2) == "[object Range]";
        }
        function kh(t2) {
          const e2 = t2.ownerDocument.defaultView.getComputedStyle(t2);
          return {
            top: parseInt(e2.borderTopWidth, 10),
            right: parseInt(e2.borderRightWidth, 10),
            bottom: parseInt(e2.borderBottomWidth, 10),
            left: parseInt(e2.borderLeftWidth, 10)
          };
        }
        const _h = ["top", "right", "bottom", "left", "width", "height"];
        class vh {
          constructor(t2) {
            const e2 = wh(t2);
            Object.defineProperty(this, "_source", {value: t2._source || t2, writable: true, enumerable: false});
            if (Kr(t2) || e2) {
              if (e2) {
                yh(this, vh.getDomRangeRects(t2)[0]);
              } else {
                yh(this, t2.getBoundingClientRect());
              }
            } else if (Hd(t2)) {
              const {innerWidth: e3, innerHeight: i2} = t2;
              yh(this, {top: 0, right: e3, bottom: i2, left: 0, width: e3, height: i2});
            } else {
              yh(this, t2);
            }
          }
          clone() {
            return new vh(this);
          }
          moveTo(t2, e2) {
            this.top = e2;
            this.right = t2 + this.width;
            this.bottom = e2 + this.height;
            this.left = t2;
            return this;
          }
          moveBy(t2, e2) {
            this.top += e2;
            this.right += t2;
            this.left += t2;
            this.bottom += e2;
            return this;
          }
          getIntersection(t2) {
            const e2 = {
              top: Math.max(this.top, t2.top),
              right: Math.min(this.right, t2.right),
              bottom: Math.min(this.bottom, t2.bottom),
              left: Math.max(this.left, t2.left)
            };
            e2.width = e2.right - e2.left;
            e2.height = e2.bottom - e2.top;
            if (e2.width < 0 || e2.height < 0) {
              return null;
            } else {
              return new vh(e2);
            }
          }
          getIntersectionArea(t2) {
            const e2 = this.getIntersection(t2);
            if (e2) {
              return e2.getArea();
            } else {
              return 0;
            }
          }
          getArea() {
            return this.width * this.height;
          }
          getVisible() {
            const t2 = this._source;
            let e2 = this.clone();
            if (!xh(t2)) {
              let i2 = t2.parentNode || t2.commonAncestorContainer;
              while (i2 && !xh(i2)) {
                const t3 = new vh(i2);
                const n2 = e2.getIntersection(t3);
                if (n2) {
                  if (n2.getArea() < e2.getArea()) {
                    e2 = n2;
                  }
                } else {
                  return null;
                }
                i2 = i2.parentNode;
              }
            }
            return e2;
          }
          isEqual(t2) {
            for (const e2 of _h) {
              if (this[e2] !== t2[e2]) {
                return false;
              }
            }
            return true;
          }
          contains(t2) {
            const e2 = this.getIntersection(t2);
            return !!(e2 && e2.isEqual(t2));
          }
          excludeScrollbarsAndBorders() {
            const t2 = this._source;
            let e2, i2, n2;
            if (Hd(t2)) {
              e2 = t2.innerWidth - t2.document.documentElement.clientWidth;
              i2 = t2.innerHeight - t2.document.documentElement.clientHeight;
              n2 = t2.getComputedStyle(t2.document.documentElement).direction;
            } else {
              const o2 = kh(this._source);
              e2 = t2.offsetWidth - t2.clientWidth - o2.left - o2.right;
              i2 = t2.offsetHeight - t2.clientHeight - o2.top - o2.bottom;
              n2 = t2.ownerDocument.defaultView.getComputedStyle(t2).direction;
              this.left += o2.left;
              this.top += o2.top;
              this.right -= o2.right;
              this.bottom -= o2.bottom;
              this.width = this.right - this.left;
              this.height = this.bottom - this.top;
            }
            this.width -= e2;
            if (n2 === "ltr") {
              this.right -= e2;
            } else {
              this.left += e2;
            }
            this.height -= i2;
            this.bottom -= i2;
            return this;
          }
          static getDomRangeRects(t2) {
            const e2 = [];
            const i2 = Array.from(t2.getClientRects());
            if (i2.length) {
              for (const t3 of i2) {
                e2.push(new vh(t3));
              }
            } else {
              let i3 = t2.startContainer;
              if (od(i3)) {
                i3 = i3.parentNode;
              }
              const n2 = new vh(i3.getBoundingClientRect());
              n2.right = n2.left;
              n2.width = 0;
              e2.push(n2);
            }
            return e2;
          }
        }
        function yh(t2, e2) {
          for (const i2 of _h) {
            t2[i2] = e2[i2];
          }
        }
        function xh(t2) {
          if (!Kr(t2)) {
            return false;
          }
          return t2 === t2.ownerDocument.body;
        }
        const Ch = {};
        function Ah({target: t2, viewportOffset: e2 = 0}) {
          const i2 = Vh(t2);
          let n2 = i2;
          let o2 = null;
          while (n2) {
            let r2;
            if (n2 == i2) {
              r2 = Nh(t2);
            } else {
              r2 = Nh(o2);
            }
            Sh(r2, () => Mh(t2, n2));
            const s2 = Mh(t2, n2);
            Ph(n2, s2, e2);
            if (n2.parent != n2) {
              o2 = n2.frameElement;
              n2 = n2.parent;
              if (!o2) {
                return;
              }
            } else {
              n2 = null;
            }
          }
        }
        function Th(t2) {
          const e2 = Nh(t2);
          Sh(e2, () => new vh(t2));
        }
        Object.assign(Ch, {scrollViewportToShowTarget: Ah, scrollAncestorsToShowTarget: Th});
        function Ph(t2, e2, i2) {
          const n2 = e2.clone().moveBy(0, i2);
          const o2 = e2.clone().moveBy(0, -i2);
          const r2 = new vh(t2).excludeScrollbarsAndBorders();
          const s2 = [o2, n2];
          if (!s2.every((t3) => r2.contains(t3))) {
            let {scrollX: s3, scrollY: a2} = t2;
            if (Rh(o2, r2)) {
              a2 -= r2.top - e2.top + i2;
            } else if (Eh(n2, r2)) {
              a2 += e2.bottom - r2.bottom + i2;
            }
            if (Oh(e2, r2)) {
              s3 -= r2.left - e2.left + i2;
            } else if (Ih(e2, r2)) {
              s3 += e2.right - r2.right + i2;
            }
            t2.scrollTo(s3, a2);
          }
        }
        function Sh(t2, e2) {
          const i2 = Vh(t2);
          let n2, o2;
          while (t2 != i2.document.body) {
            o2 = e2();
            n2 = new vh(t2).excludeScrollbarsAndBorders();
            if (!n2.contains(o2)) {
              if (Rh(o2, n2)) {
                t2.scrollTop -= n2.top - o2.top;
              } else if (Eh(o2, n2)) {
                t2.scrollTop += o2.bottom - n2.bottom;
              }
              if (Oh(o2, n2)) {
                t2.scrollLeft -= n2.left - o2.left;
              } else if (Ih(o2, n2)) {
                t2.scrollLeft += o2.right - n2.right;
              }
            }
            t2 = t2.parentNode;
          }
        }
        function Eh(t2, e2) {
          return t2.bottom > e2.bottom;
        }
        function Rh(t2, e2) {
          return t2.top < e2.top;
        }
        function Oh(t2, e2) {
          return t2.left < e2.left;
        }
        function Ih(t2, e2) {
          return t2.right > e2.right;
        }
        function Vh(t2) {
          if (wh(t2)) {
            return t2.startContainer.ownerDocument.defaultView;
          } else {
            return t2.ownerDocument.defaultView;
          }
        }
        function Nh(t2) {
          if (wh(t2)) {
            let e2 = t2.commonAncestorContainer;
            if (od(e2)) {
              e2 = e2.parentNode;
            }
            return e2;
          } else {
            return t2.parentNode;
          }
        }
        function Mh(t2, e2) {
          const i2 = Vh(t2);
          const n2 = new vh(t2);
          if (i2 === e2) {
            return n2;
          } else {
            let t3 = i2;
            while (t3 != e2) {
              const e3 = t3.frameElement;
              const i3 = new vh(e3).excludeScrollbarsAndBorders();
              n2.moveBy(i3.left, i3.top);
              t3 = t3.parent;
            }
          }
          return n2;
        }
        class Bh {
          constructor(t2) {
            this.document = new pl(t2);
            this.domConverter = new zd(this.document);
            this.domRoots = new Map();
            this.set("isRenderingInProgress", false);
            this._renderer = new Cd(this.domConverter, this.document.selection);
            this._renderer.bind("isFocused").to(this.document);
            this._initialDomRootAttributes = new WeakMap();
            this._observers = new Map();
            this._ongoingChange = false;
            this._postFixersInProgress = false;
            this._renderingDisabled = false;
            this._hasChangedSinceTheLastRendering = false;
            this._writer = new $l(this.document);
            this.addObserver(Gu);
            this.addObserver(gh);
            this.addObserver(mh);
            this.addObserver(Yu);
            this.addObserver(hh);
            this.addObserver(ph);
            if (Al.isAndroid) {
              this.addObserver(bh);
            }
            hd(this);
            jl(this);
            this.on("render", () => {
              this._render();
              this.document.fire("layoutChanged");
              this._hasChangedSinceTheLastRendering = false;
            });
            this.listenTo(this.document.selection, "change", () => {
              this._hasChangedSinceTheLastRendering = true;
            });
          }
          attachDomRoot(t2, e2 = "main") {
            const i2 = this.document.getRoot(e2);
            i2._name = t2.tagName.toLowerCase();
            const n2 = {};
            for (const {name: e3, value: o3} of Array.from(t2.attributes)) {
              n2[e3] = o3;
              if (e3 === "class") {
                this._writer.addClass(o3.split(" "), i2);
              } else {
                this._writer.setAttribute(e3, o3, i2);
              }
            }
            this._initialDomRootAttributes.set(t2, n2);
            const o2 = () => {
              this._writer.setAttribute("contenteditable", !i2.isReadOnly, i2);
              if (i2.isReadOnly) {
                this._writer.addClass("ck-read-only", i2);
              } else {
                this._writer.removeClass("ck-read-only", i2);
              }
            };
            o2();
            this.domRoots.set(e2, t2);
            this.domConverter.bindElements(t2, i2);
            this._renderer.markToSync("children", i2);
            this._renderer.markToSync("attributes", i2);
            this._renderer.domDocuments.add(t2.ownerDocument);
            i2.on("change:children", (t3, e3) => this._renderer.markToSync("children", e3));
            i2.on("change:attributes", (t3, e3) => this._renderer.markToSync("attributes", e3));
            i2.on("change:text", (t3, e3) => this._renderer.markToSync("text", e3));
            i2.on("change:isReadOnly", () => this.change(o2));
            i2.on("change", () => {
              this._hasChangedSinceTheLastRendering = true;
            });
            for (const i3 of this._observers.values()) {
              i3.observe(t2, e2);
            }
          }
          detachDomRoot(t2) {
            const e2 = this.domRoots.get(t2);
            Array.from(e2.attributes).forEach(({name: t3}) => e2.removeAttribute(t3));
            const i2 = this._initialDomRootAttributes.get(e2);
            for (const t3 in i2) {
              e2.setAttribute(t3, i2[t3]);
            }
            this.domRoots.delete(t2);
            this.domConverter.unbindDomElement(e2);
          }
          getDomRoot(t2 = "main") {
            return this.domRoots.get(t2);
          }
          addObserver(t2) {
            let e2 = this._observers.get(t2);
            if (e2) {
              return e2;
            }
            e2 = new t2(this);
            this._observers.set(t2, e2);
            for (const [t3, i2] of this.domRoots) {
              e2.observe(i2, t3);
            }
            e2.enable();
            return e2;
          }
          getObserver(t2) {
            return this._observers.get(t2);
          }
          disableObservers() {
            for (const t2 of this._observers.values()) {
              t2.disable();
            }
          }
          enableObservers() {
            for (const t2 of this._observers.values()) {
              t2.enable();
            }
          }
          scrollToTheSelection() {
            const t2 = this.document.selection.getFirstRange();
            if (t2) {
              Ah({target: this.domConverter.viewRangeToDom(t2), viewportOffset: 20});
            }
          }
          focus() {
            if (!this.document.isFocused) {
              const t2 = this.document.selection.editableElement;
              if (t2) {
                this.domConverter.focus(t2);
                this.forceRender();
              } else {
              }
            }
          }
          change(t2) {
            if (this.isRenderingInProgress || this._postFixersInProgress) {
              throw new ss["b"]("cannot-change-view-tree: Attempting to make changes to the view when it is in an incorrect state: rendering or post-fixers are in progress. This may cause some unexpected behavior and inconsistency between the DOM and the view.", this);
            }
            try {
              if (this._ongoingChange) {
                return t2(this._writer);
              }
              this._ongoingChange = true;
              const e2 = t2(this._writer);
              this._ongoingChange = false;
              if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
                this._postFixersInProgress = true;
                this.document._callPostFixers(this._writer);
                this._postFixersInProgress = false;
                this.fire("render");
              }
              return e2;
            } catch (t3) {
              ss["b"].rethrowUnexpectedError(t3, this);
            }
          }
          forceRender() {
            this._hasChangedSinceTheLastRendering = true;
            this.change(() => {
            });
          }
          destroy() {
            for (const t2 of this._observers.values()) {
              t2.destroy();
            }
            this.document.destroy();
            this.stopListening();
          }
          createPositionAt(t2, e2) {
            return dl._createAt(t2, e2);
          }
          createPositionAfter(t2) {
            return dl._createAfter(t2);
          }
          createPositionBefore(t2) {
            return dl._createBefore(t2);
          }
          createRange(t2, e2) {
            return new ul(t2, e2);
          }
          createRangeOn(t2) {
            return ul._createOn(t2);
          }
          createRangeIn(t2) {
            return ul._createIn(t2);
          }
          createSelection(t2, e2, i2) {
            return new gl(t2, e2, i2);
          }
          _disableRendering(t2) {
            this._renderingDisabled = t2;
            if (t2 == false) {
              this.change(() => {
              });
            }
          }
          _render() {
            this.isRenderingInProgress = true;
            this.disableObservers();
            this._renderer.render();
            this.enableObservers();
            this.isRenderingInProgress = false;
          }
        }
        vs(Bh, Jc);
        class zh {
          constructor(t2) {
            this.parent = null;
            this._attrs = Hs(t2);
          }
          get index() {
            let t2;
            if (!this.parent) {
              return null;
            }
            if ((t2 = this.parent.getChildIndex(this)) === null) {
              throw new ss["b"]("model-node-not-found-in-parent: The node's parent does not contain this node.", this);
            }
            return t2;
          }
          get startOffset() {
            let t2;
            if (!this.parent) {
              return null;
            }
            if ((t2 = this.parent.getChildStartOffset(this)) === null) {
              throw new ss["b"]("model-node-not-found-in-parent: The node's parent does not contain this node.", this);
            }
            return t2;
          }
          get offsetSize() {
            return 1;
          }
          get endOffset() {
            if (!this.parent) {
              return null;
            }
            return this.startOffset + this.offsetSize;
          }
          get nextSibling() {
            const t2 = this.index;
            return t2 !== null && this.parent.getChild(t2 + 1) || null;
          }
          get previousSibling() {
            const t2 = this.index;
            return t2 !== null && this.parent.getChild(t2 - 1) || null;
          }
          get root() {
            let t2 = this;
            while (t2.parent) {
              t2 = t2.parent;
            }
            return t2;
          }
          isAttached() {
            return this.root.is("rootElement");
          }
          getPath() {
            const t2 = [];
            let e2 = this;
            while (e2.parent) {
              t2.unshift(e2.startOffset);
              e2 = e2.parent;
            }
            return t2;
          }
          getAncestors(t2 = {includeSelf: false, parentFirst: false}) {
            const e2 = [];
            let i2 = t2.includeSelf ? this : this.parent;
            while (i2) {
              e2[t2.parentFirst ? "push" : "unshift"](i2);
              i2 = i2.parent;
            }
            return e2;
          }
          getCommonAncestor(t2, e2 = {}) {
            const i2 = this.getAncestors(e2);
            const n2 = t2.getAncestors(e2);
            let o2 = 0;
            while (i2[o2] == n2[o2] && i2[o2]) {
              o2++;
            }
            return o2 === 0 ? null : i2[o2 - 1];
          }
          isBefore(t2) {
            if (this == t2) {
              return false;
            }
            if (this.root !== t2.root) {
              return false;
            }
            const e2 = this.getPath();
            const i2 = t2.getPath();
            const n2 = Vs(e2, i2);
            switch (n2) {
              case "prefix":
                return true;
              case "extension":
                return false;
              default:
                return e2[n2] < i2[n2];
            }
          }
          isAfter(t2) {
            if (this == t2) {
              return false;
            }
            if (this.root !== t2.root) {
              return false;
            }
            return !this.isBefore(t2);
          }
          hasAttribute(t2) {
            return this._attrs.has(t2);
          }
          getAttribute(t2) {
            return this._attrs.get(t2);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          toJSON() {
            const t2 = {};
            if (this._attrs.size) {
              t2.attributes = Array.from(this._attrs).reduce((t3, e2) => {
                t3[e2[0]] = e2[1];
                return t3;
              }, {});
            }
            return t2;
          }
          is(t2) {
            return t2 == "node" || t2 == "model:node";
          }
          _clone() {
            return new zh(this._attrs);
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _setAttribute(t2, e2) {
            this._attrs.set(t2, e2);
          }
          _setAttributesTo(t2) {
            this._attrs = Hs(t2);
          }
          _removeAttribute(t2) {
            return this._attrs.delete(t2);
          }
          _clearAttributes() {
            this._attrs.clear();
          }
        }
        class Lh extends zh {
          constructor(t2, e2) {
            super(e2);
            this._data = t2 || "";
          }
          get offsetSize() {
            return this.data.length;
          }
          get data() {
            return this._data;
          }
          is(t2) {
            return t2 == "text" || t2 == "model:text" || super.is(t2);
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.data = this.data;
            return t2;
          }
          _clone() {
            return new Lh(this.data, this.getAttributes());
          }
          static fromJSON(t2) {
            return new Lh(t2.data, t2.attributes);
          }
        }
        class Fh {
          constructor(t2, e2, i2) {
            this.textNode = t2;
            if (e2 < 0 || e2 > t2.offsetSize) {
              throw new ss["b"]("model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.", this);
            }
            if (i2 < 0 || e2 + i2 > t2.offsetSize) {
              throw new ss["b"]("model-textproxy-wrong-length: Given length value is incorrect.", this);
            }
            this.data = t2.data.substring(e2, e2 + i2);
            this.offsetInText = e2;
          }
          get startOffset() {
            return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
          }
          get offsetSize() {
            return this.data.length;
          }
          get endOffset() {
            return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
          }
          get isPartial() {
            return this.offsetSize !== this.textNode.offsetSize;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          is(t2) {
            return t2 == "textProxy" || t2 == "model:textProxy";
          }
          getPath() {
            const t2 = this.textNode.getPath();
            if (t2.length > 0) {
              t2[t2.length - 1] += this.offsetInText;
            }
            return t2;
          }
          getAncestors(t2 = {includeSelf: false, parentFirst: false}) {
            const e2 = [];
            let i2 = t2.includeSelf ? this : this.parent;
            while (i2) {
              e2[t2.parentFirst ? "push" : "unshift"](i2);
              i2 = i2.parent;
            }
            return e2;
          }
          hasAttribute(t2) {
            return this.textNode.hasAttribute(t2);
          }
          getAttribute(t2) {
            return this.textNode.getAttribute(t2);
          }
          getAttributes() {
            return this.textNode.getAttributes();
          }
          getAttributeKeys() {
            return this.textNode.getAttributeKeys();
          }
        }
        class Dh {
          constructor(t2) {
            this._nodes = [];
            if (t2) {
              this._insertNodes(0, t2);
            }
          }
          [Symbol.iterator]() {
            return this._nodes[Symbol.iterator]();
          }
          get length() {
            return this._nodes.length;
          }
          get maxOffset() {
            return this._nodes.reduce((t2, e2) => t2 + e2.offsetSize, 0);
          }
          getNode(t2) {
            return this._nodes[t2] || null;
          }
          getNodeIndex(t2) {
            const e2 = this._nodes.indexOf(t2);
            return e2 == -1 ? null : e2;
          }
          getNodeStartOffset(t2) {
            const e2 = this.getNodeIndex(t2);
            return e2 === null ? null : this._nodes.slice(0, e2).reduce((t3, e3) => t3 + e3.offsetSize, 0);
          }
          indexToOffset(t2) {
            if (t2 == this._nodes.length) {
              return this.maxOffset;
            }
            const e2 = this._nodes[t2];
            if (!e2) {
              throw new ss["b"]("model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.", this);
            }
            return this.getNodeStartOffset(e2);
          }
          offsetToIndex(t2) {
            let e2 = 0;
            for (const i2 of this._nodes) {
              if (t2 >= e2 && t2 < e2 + i2.offsetSize) {
                return this.getNodeIndex(i2);
              }
              e2 += i2.offsetSize;
            }
            if (e2 != t2) {
              throw new ss["b"]("model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.", this, {
                offset: t2,
                nodeList: this
              });
            }
            return this.length;
          }
          _insertNodes(t2, e2) {
            for (const t3 of e2) {
              if (!(t3 instanceof zh)) {
                throw new ss["b"]("model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.", this);
              }
            }
            this._nodes.splice(t2, 0, ...e2);
          }
          _removeNodes(t2, e2 = 1) {
            return this._nodes.splice(t2, e2);
          }
          toJSON() {
            return this._nodes.map((t2) => t2.toJSON());
          }
        }
        class jh extends zh {
          constructor(t2, e2, i2) {
            super(e2);
            this.name = t2;
            this._children = new Dh();
            if (i2) {
              this._insertChild(0, i2);
            }
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return this.childCount === 0;
          }
          is(t2, e2 = null) {
            const i2 = t2.replace(/^model:/, "");
            if (!e2) {
              return i2 == "element" || i2 == this.name || super.is(t2);
            } else {
              return i2 == "element" && e2 == this.name;
            }
          }
          getChild(t2) {
            return this._children.getNode(t2);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t2) {
            return this._children.getNodeIndex(t2);
          }
          getChildStartOffset(t2) {
            return this._children.getNodeStartOffset(t2);
          }
          offsetToIndex(t2) {
            return this._children.offsetToIndex(t2);
          }
          getNodeByPath(t2) {
            let e2 = this;
            for (const i2 of t2) {
              e2 = e2.getChild(e2.offsetToIndex(i2));
            }
            return e2;
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.name = this.name;
            if (this._children.length > 0) {
              t2.children = [];
              for (const e2 of this._children) {
                t2.children.push(e2.toJSON());
              }
            }
            return t2;
          }
          _clone(t2 = false) {
            const e2 = t2 ? Array.from(this._children).map((t3) => t3._clone(true)) : null;
            return new jh(this.name, this.getAttributes(), e2);
          }
          _appendChild(t2) {
            this._insertChild(this.childCount, t2);
          }
          _insertChild(t2, e2) {
            const i2 = Hh(e2);
            for (const t3 of i2) {
              if (t3.parent !== null) {
                t3._remove();
              }
              t3.parent = this;
            }
            this._children._insertNodes(t2, i2);
          }
          _removeChildren(t2, e2 = 1) {
            const i2 = this._children._removeNodes(t2, e2);
            for (const t3 of i2) {
              t3.parent = null;
            }
            return i2;
          }
          static fromJSON(t2) {
            let e2 = null;
            if (t2.children) {
              e2 = [];
              for (const i2 of t2.children) {
                if (i2.name) {
                  e2.push(jh.fromJSON(i2));
                } else {
                  e2.push(Lh.fromJSON(i2));
                }
              }
            }
            return new jh(t2.name, t2.attributes, e2);
          }
        }
        function Hh(t2) {
          if (typeof t2 == "string") {
            return [new Lh(t2)];
          }
          if (!js(t2)) {
            t2 = [t2];
          }
          return Array.from(t2).map((t3) => {
            if (typeof t3 == "string") {
              return new Lh(t3);
            }
            if (t3 instanceof Fh) {
              return new Lh(t3.data, t3.getAttributes());
            }
            return t3;
          });
        }
        class Wh {
          constructor(t2 = {}) {
            if (!t2.boundaries && !t2.startPosition) {
              throw new ss["b"]("model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.", null);
            }
            const e2 = t2.direction || "forward";
            if (e2 != "forward" && e2 != "backward") {
              throw new ss["b"]("model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.", t2, {direction: e2});
            }
            this.direction = e2;
            this.boundaries = t2.boundaries || null;
            if (t2.startPosition) {
              this.position = t2.startPosition.clone();
            } else {
              this.position = Uh._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]);
            }
            this.position.stickiness = "toNone";
            this.singleCharacters = !!t2.singleCharacters;
            this.shallow = !!t2.shallow;
            this.ignoreElementEnd = !!t2.ignoreElementEnd;
            this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
            this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
            this._visitedParent = this.position.parent;
          }
          [Symbol.iterator]() {
            return this;
          }
          skip(t2) {
            let e2, i2, n2, o2;
            do {
              n2 = this.position;
              o2 = this._visitedParent;
              ({done: e2, value: i2} = this.next());
            } while (!e2 && t2(i2));
            if (!e2) {
              this.position = n2;
              this._visitedParent = o2;
            }
          }
          next() {
            if (this.direction == "forward") {
              return this._next();
            } else {
              return this._previous();
            }
          }
          _next() {
            const t2 = this.position;
            const e2 = this.position.clone();
            const i2 = this._visitedParent;
            if (i2.parent === null && e2.offset === i2.maxOffset) {
              return {done: true};
            }
            if (i2 === this._boundaryEndParent && e2.offset == this.boundaries.end.offset) {
              return {done: true};
            }
            const n2 = e2.textNode ? e2.textNode : e2.nodeAfter;
            if (n2 instanceof jh) {
              if (!this.shallow) {
                e2.path.push(0);
                this._visitedParent = n2;
              } else {
                e2.offset++;
              }
              this.position = e2;
              return qh("elementStart", n2, t2, e2, 1);
            } else if (n2 instanceof Lh) {
              let o2;
              if (this.singleCharacters) {
                o2 = 1;
              } else {
                let t3 = n2.endOffset;
                if (this._boundaryEndParent == i2 && this.boundaries.end.offset < t3) {
                  t3 = this.boundaries.end.offset;
                }
                o2 = t3 - e2.offset;
              }
              const r2 = e2.offset - n2.startOffset;
              const s2 = new Fh(n2, r2, o2);
              e2.offset += o2;
              this.position = e2;
              return qh("text", s2, t2, e2, o2);
            } else {
              e2.path.pop();
              e2.offset++;
              this.position = e2;
              this._visitedParent = i2.parent;
              if (this.ignoreElementEnd) {
                return this._next();
              } else {
                return qh("elementEnd", i2, t2, e2);
              }
            }
          }
          _previous() {
            const t2 = this.position;
            const e2 = this.position.clone();
            const i2 = this._visitedParent;
            if (i2.parent === null && e2.offset === 0) {
              return {done: true};
            }
            if (i2 == this._boundaryStartParent && e2.offset == this.boundaries.start.offset) {
              return {done: true};
            }
            const n2 = e2.textNode ? e2.textNode : e2.nodeBefore;
            if (n2 instanceof jh) {
              e2.offset--;
              if (!this.shallow) {
                e2.path.push(n2.maxOffset);
                this.position = e2;
                this._visitedParent = n2;
                if (this.ignoreElementEnd) {
                  return this._previous();
                } else {
                  return qh("elementEnd", n2, t2, e2);
                }
              } else {
                this.position = e2;
                return qh("elementStart", n2, t2, e2, 1);
              }
            } else if (n2 instanceof Lh) {
              let o2;
              if (this.singleCharacters) {
                o2 = 1;
              } else {
                let t3 = n2.startOffset;
                if (this._boundaryStartParent == i2 && this.boundaries.start.offset > t3) {
                  t3 = this.boundaries.start.offset;
                }
                o2 = e2.offset - t3;
              }
              const r2 = e2.offset - n2.startOffset;
              const s2 = new Fh(n2, r2 - o2, o2);
              e2.offset -= o2;
              this.position = e2;
              return qh("text", s2, t2, e2, o2);
            } else {
              e2.path.pop();
              this.position = e2;
              this._visitedParent = i2.parent;
              return qh("elementStart", i2, t2, e2, 1);
            }
          }
        }
        function qh(t2, e2, i2, n2, o2) {
          return {done: false, value: {type: t2, item: e2, previousPosition: i2, nextPosition: n2, length: o2}};
        }
        class Uh {
          constructor(t2, e2, i2 = "toNone") {
            if (!t2.is("element") && !t2.is("documentFragment")) {
              throw new ss["b"]("model-position-root-invalid: Position root invalid.", t2);
            }
            if (!(e2 instanceof Array) || e2.length === 0) {
              throw new ss["b"]("model-position-path-incorrect-format: Position path must be an array with at least one item.", t2, {path: e2});
            }
            e2 = t2.getPath().concat(e2);
            t2 = t2.root;
            this.root = t2;
            this.path = e2;
            this.stickiness = i2;
          }
          get offset() {
            return Ca(this.path);
          }
          set offset(t2) {
            this.path[this.path.length - 1] = t2;
          }
          get parent() {
            let t2 = this.root;
            for (let e2 = 0; e2 < this.path.length - 1; e2++) {
              t2 = t2.getChild(t2.offsetToIndex(this.path[e2]));
              if (!t2) {
                throw new ss["b"]("model-position-path-incorrect: The position's path is incorrect.", this, {position: this});
              }
            }
            if (t2.is("text")) {
              throw new ss["b"]("model-position-path-incorrect: The position's path is incorrect.", this, {position: this});
            }
            return t2;
          }
          get index() {
            return this.parent.offsetToIndex(this.offset);
          }
          get textNode() {
            const t2 = this.parent.getChild(this.index);
            return t2 instanceof Lh && t2.startOffset < this.offset ? t2 : null;
          }
          get nodeAfter() {
            return this.textNode === null ? this.parent.getChild(this.index) : null;
          }
          get nodeBefore() {
            return this.textNode === null ? this.parent.getChild(this.index - 1) : null;
          }
          get isAtStart() {
            return this.offset === 0;
          }
          get isAtEnd() {
            return this.offset == this.parent.maxOffset;
          }
          compareWith(t2) {
            if (this.root != t2.root) {
              return "different";
            }
            const e2 = Vs(this.path, t2.path);
            switch (e2) {
              case "same":
                return "same";
              case "prefix":
                return "before";
              case "extension":
                return "after";
              default:
                return this.path[e2] < t2.path[e2] ? "before" : "after";
            }
          }
          getLastMatchingPosition(t2, e2 = {}) {
            e2.startPosition = this;
            const i2 = new Wh(e2);
            i2.skip(t2);
            return i2.position;
          }
          getParentPath() {
            return this.path.slice(0, -1);
          }
          getAncestors() {
            if (this.parent.is("documentFragment")) {
              return [this.parent];
            } else {
              return this.parent.getAncestors({includeSelf: true});
            }
          }
          getCommonPath(t2) {
            if (this.root != t2.root) {
              return [];
            }
            const e2 = Vs(this.path, t2.path);
            const i2 = typeof e2 == "string" ? Math.min(this.path.length, t2.path.length) : e2;
            return this.path.slice(0, i2);
          }
          getCommonAncestor(t2) {
            const e2 = this.getAncestors();
            const i2 = t2.getAncestors();
            let n2 = 0;
            while (e2[n2] == i2[n2] && e2[n2]) {
              n2++;
            }
            return n2 === 0 ? null : e2[n2 - 1];
          }
          getShiftedBy(t2) {
            const e2 = this.clone();
            const i2 = e2.offset + t2;
            e2.offset = i2 < 0 ? 0 : i2;
            return e2;
          }
          isAfter(t2) {
            return this.compareWith(t2) == "after";
          }
          isBefore(t2) {
            return this.compareWith(t2) == "before";
          }
          isEqual(t2) {
            return this.compareWith(t2) == "same";
          }
          isTouching(t2) {
            let e2 = null;
            let i2 = null;
            const n2 = this.compareWith(t2);
            switch (n2) {
              case "same":
                return true;
              case "before":
                e2 = Uh._createAt(this);
                i2 = Uh._createAt(t2);
                break;
              case "after":
                e2 = Uh._createAt(t2);
                i2 = Uh._createAt(this);
                break;
              default:
                return false;
            }
            let o2 = e2.parent;
            while (e2.path.length + i2.path.length) {
              if (e2.isEqual(i2)) {
                return true;
              }
              if (e2.path.length > i2.path.length) {
                if (e2.offset !== o2.maxOffset) {
                  return false;
                }
                e2.path = e2.path.slice(0, -1);
                o2 = o2.parent;
                e2.offset++;
              } else {
                if (i2.offset !== 0) {
                  return false;
                }
                i2.path = i2.path.slice(0, -1);
              }
            }
          }
          is(t2) {
            return t2 == "position" || t2 == "model:position";
          }
          hasSameParentAs(t2) {
            if (this.root !== t2.root) {
              return false;
            }
            const e2 = this.getParentPath();
            const i2 = t2.getParentPath();
            return Vs(e2, i2) == "same";
          }
          getTransformedByOperation(t2) {
            let e2;
            switch (t2.type) {
              case "insert":
                e2 = this._getTransformedByInsertOperation(t2);
                break;
              case "move":
              case "remove":
              case "reinsert":
                e2 = this._getTransformedByMoveOperation(t2);
                break;
              case "split":
                e2 = this._getTransformedBySplitOperation(t2);
                break;
              case "merge":
                e2 = this._getTransformedByMergeOperation(t2);
                break;
              default:
                e2 = Uh._createAt(this);
                break;
            }
            return e2;
          }
          _getTransformedByInsertOperation(t2) {
            return this._getTransformedByInsertion(t2.position, t2.howMany);
          }
          _getTransformedByMoveOperation(t2) {
            return this._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany);
          }
          _getTransformedBySplitOperation(t2) {
            const e2 = t2.movedRange;
            const i2 = e2.containsPosition(this) || e2.start.isEqual(this) && this.stickiness == "toNext";
            if (i2) {
              return this._getCombined(t2.splitPosition, t2.moveTargetPosition);
            } else {
              if (t2.graveyardPosition) {
                return this._getTransformedByMove(t2.graveyardPosition, t2.insertionPosition, 1);
              } else {
                return this._getTransformedByInsertion(t2.insertionPosition, 1);
              }
            }
          }
          _getTransformedByMergeOperation(t2) {
            const e2 = t2.movedRange;
            const i2 = e2.containsPosition(this) || e2.start.isEqual(this);
            let n2;
            if (i2) {
              n2 = this._getCombined(t2.sourcePosition, t2.targetPosition);
              if (t2.sourcePosition.isBefore(t2.targetPosition)) {
                n2 = n2._getTransformedByDeletion(t2.deletionPosition, 1);
              }
            } else if (this.isEqual(t2.deletionPosition)) {
              n2 = Uh._createAt(t2.deletionPosition);
            } else {
              n2 = this._getTransformedByMove(t2.deletionPosition, t2.graveyardPosition, 1);
            }
            return n2;
          }
          _getTransformedByDeletion(t2, e2) {
            const i2 = Uh._createAt(this);
            if (this.root != t2.root) {
              return i2;
            }
            if (Vs(t2.getParentPath(), this.getParentPath()) == "same") {
              if (t2.offset < this.offset) {
                if (t2.offset + e2 > this.offset) {
                  return null;
                } else {
                  i2.offset -= e2;
                }
              }
            } else if (Vs(t2.getParentPath(), this.getParentPath()) == "prefix") {
              const n2 = t2.path.length - 1;
              if (t2.offset <= this.path[n2]) {
                if (t2.offset + e2 > this.path[n2]) {
                  return null;
                } else {
                  i2.path[n2] -= e2;
                }
              }
            }
            return i2;
          }
          _getTransformedByInsertion(t2, e2) {
            const i2 = Uh._createAt(this);
            if (this.root != t2.root) {
              return i2;
            }
            if (Vs(t2.getParentPath(), this.getParentPath()) == "same") {
              if (t2.offset < this.offset || t2.offset == this.offset && this.stickiness != "toPrevious") {
                i2.offset += e2;
              }
            } else if (Vs(t2.getParentPath(), this.getParentPath()) == "prefix") {
              const n2 = t2.path.length - 1;
              if (t2.offset <= this.path[n2]) {
                i2.path[n2] += e2;
              }
            }
            return i2;
          }
          _getTransformedByMove(t2, e2, i2) {
            e2 = e2._getTransformedByDeletion(t2, i2);
            if (t2.isEqual(e2)) {
              return Uh._createAt(this);
            }
            const n2 = this._getTransformedByDeletion(t2, i2);
            const o2 = n2 === null || t2.isEqual(this) && this.stickiness == "toNext" || t2.getShiftedBy(i2).isEqual(this) && this.stickiness == "toPrevious";
            if (o2) {
              return this._getCombined(t2, e2);
            } else {
              return n2._getTransformedByInsertion(e2, i2);
            }
          }
          _getCombined(t2, e2) {
            const i2 = t2.path.length - 1;
            const n2 = Uh._createAt(e2);
            n2.stickiness = this.stickiness;
            n2.offset = n2.offset + this.path[i2] - t2.offset;
            n2.path = n2.path.concat(this.path.slice(i2 + 1));
            return n2;
          }
          toJSON() {
            return {root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness};
          }
          clone() {
            return new this.constructor(this.root, this.path, this.stickiness);
          }
          static _createAt(t2, e2, i2 = "toNone") {
            if (t2 instanceof Uh) {
              return new Uh(t2.root, t2.path, t2.stickiness);
            } else {
              const n2 = t2;
              if (e2 == "end") {
                e2 = n2.maxOffset;
              } else if (e2 == "before") {
                return this._createBefore(n2, i2);
              } else if (e2 == "after") {
                return this._createAfter(n2, i2);
              } else if (e2 !== 0 && !e2) {
                throw new ss["b"]("model-createPositionAt-offset-required: Model#createPositionAt() requires the offset when the first parameter is a model item.", [this, t2]);
              }
              if (!n2.is("element") && !n2.is("documentFragment")) {
                throw new ss["b"]("model-position-parent-incorrect: Position parent have to be a element or document fragment.", [this, t2]);
              }
              const o2 = n2.getPath();
              o2.push(e2);
              return new this(n2.root, o2, i2);
            }
          }
          static _createAfter(t2, e2) {
            if (!t2.parent) {
              throw new ss["b"]("model-position-after-root: You cannot make a position after root.", [this, t2], {root: t2});
            }
            return this._createAt(t2.parent, t2.endOffset, e2);
          }
          static _createBefore(t2, e2) {
            if (!t2.parent) {
              throw new ss["b"]("model-position-before-root: You cannot make a position before root.", t2, {root: t2});
            }
            return this._createAt(t2.parent, t2.startOffset, e2);
          }
          static fromJSON(t2, e2) {
            if (t2.root === "$graveyard") {
              const i2 = new Uh(e2.graveyard, t2.path);
              i2.stickiness = t2.stickiness;
              return i2;
            }
            if (!e2.getRoot(t2.root)) {
              throw new ss["b"]("model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.", e2, {rootName: t2.root});
            }
            return new Uh(e2.getRoot(t2.root), t2.path, t2.stickiness);
          }
        }
        class $h {
          constructor(t2, e2 = null) {
            this.start = Uh._createAt(t2);
            this.end = e2 ? Uh._createAt(e2) : Uh._createAt(t2);
            this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
            this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
          }
          *[Symbol.iterator]() {
            yield* new Wh({boundaries: this, ignoreElementEnd: true});
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            const t2 = this.start.getParentPath();
            const e2 = this.end.getParentPath();
            return Vs(t2, e2) == "same";
          }
          get root() {
            return this.start.root;
          }
          containsPosition(t2) {
            return t2.isAfter(this.start) && t2.isBefore(this.end);
          }
          containsRange(t2, e2 = false) {
            if (t2.isCollapsed) {
              e2 = false;
            }
            const i2 = this.containsPosition(t2.start) || e2 && this.start.isEqual(t2.start);
            const n2 = this.containsPosition(t2.end) || e2 && this.end.isEqual(t2.end);
            return i2 && n2;
          }
          containsItem(t2) {
            const e2 = Uh._createBefore(t2);
            return this.containsPosition(e2) || this.start.isEqual(e2);
          }
          is(t2) {
            return t2 == "range" || t2 == "model:range";
          }
          isEqual(t2) {
            return this.start.isEqual(t2.start) && this.end.isEqual(t2.end);
          }
          isIntersecting(t2) {
            return this.start.isBefore(t2.end) && this.end.isAfter(t2.start);
          }
          getDifference(t2) {
            const e2 = [];
            if (this.isIntersecting(t2)) {
              if (this.containsPosition(t2.start)) {
                e2.push(new $h(this.start, t2.start));
              }
              if (this.containsPosition(t2.end)) {
                e2.push(new $h(t2.end, this.end));
              }
            } else {
              e2.push(new $h(this.start, this.end));
            }
            return e2;
          }
          getIntersection(t2) {
            if (this.isIntersecting(t2)) {
              let e2 = this.start;
              let i2 = this.end;
              if (this.containsPosition(t2.start)) {
                e2 = t2.start;
              }
              if (this.containsPosition(t2.end)) {
                i2 = t2.end;
              }
              return new $h(e2, i2);
            }
            return null;
          }
          getMinimalFlatRanges() {
            const t2 = [];
            const e2 = this.start.getCommonPath(this.end).length;
            const i2 = Uh._createAt(this.start);
            let n2 = i2.parent;
            while (i2.path.length > e2 + 1) {
              const e3 = n2.maxOffset - i2.offset;
              if (e3 !== 0) {
                t2.push(new $h(i2, i2.getShiftedBy(e3)));
              }
              i2.path = i2.path.slice(0, -1);
              i2.offset++;
              n2 = n2.parent;
            }
            while (i2.path.length <= this.end.path.length) {
              const e3 = this.end.path[i2.path.length - 1];
              const n3 = e3 - i2.offset;
              if (n3 !== 0) {
                t2.push(new $h(i2, i2.getShiftedBy(n3)));
              }
              i2.offset = e3;
              i2.path.push(0);
            }
            return t2;
          }
          getWalker(t2 = {}) {
            t2.boundaries = this;
            return new Wh(t2);
          }
          *getItems(t2 = {}) {
            t2.boundaries = this;
            t2.ignoreElementEnd = true;
            const e2 = new Wh(t2);
            for (const t3 of e2) {
              yield t3.item;
            }
          }
          *getPositions(t2 = {}) {
            t2.boundaries = this;
            const e2 = new Wh(t2);
            yield e2.position;
            for (const t3 of e2) {
              yield t3.nextPosition;
            }
          }
          getTransformedByOperation(t2) {
            switch (t2.type) {
              case "insert":
                return this._getTransformedByInsertOperation(t2);
              case "move":
              case "remove":
              case "reinsert":
                return this._getTransformedByMoveOperation(t2);
              case "split":
                return [this._getTransformedBySplitOperation(t2)];
              case "merge":
                return [this._getTransformedByMergeOperation(t2)];
            }
            return [new $h(this.start, this.end)];
          }
          getTransformedByOperations(t2) {
            const e2 = [new $h(this.start, this.end)];
            for (const i2 of t2) {
              for (let t3 = 0; t3 < e2.length; t3++) {
                const n2 = e2[t3].getTransformedByOperation(i2);
                e2.splice(t3, 1, ...n2);
                t3 += n2.length - 1;
              }
            }
            for (let t3 = 0; t3 < e2.length; t3++) {
              const i2 = e2[t3];
              for (let n2 = t3 + 1; n2 < e2.length; n2++) {
                const t4 = e2[n2];
                if (i2.containsRange(t4) || t4.containsRange(i2) || i2.isEqual(t4)) {
                  e2.splice(n2, 1);
                }
              }
            }
            return e2;
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed) {
              return null;
            }
            const t2 = this.start.nodeAfter;
            const e2 = this.end.nodeBefore;
            if (t2 && t2.is("element") && t2 === e2) {
              return t2;
            }
            return null;
          }
          toJSON() {
            return {start: this.start.toJSON(), end: this.end.toJSON()};
          }
          clone() {
            return new this.constructor(this.start, this.end);
          }
          _getTransformedByInsertOperation(t2, e2 = false) {
            return this._getTransformedByInsertion(t2.position, t2.howMany, e2);
          }
          _getTransformedByMoveOperation(t2, e2 = false) {
            const i2 = t2.sourcePosition;
            const n2 = t2.howMany;
            const o2 = t2.targetPosition;
            return this._getTransformedByMove(i2, o2, n2, e2);
          }
          _getTransformedBySplitOperation(t2) {
            const e2 = this.start._getTransformedBySplitOperation(t2);
            let i2 = this.end._getTransformedBySplitOperation(t2);
            if (this.end.isEqual(t2.insertionPosition)) {
              i2 = this.end.getShiftedBy(1);
            }
            if (e2.root != i2.root) {
              i2 = this.end.getShiftedBy(-1);
            }
            return new $h(e2, i2);
          }
          _getTransformedByMergeOperation(t2) {
            if (this.start.isEqual(t2.targetPosition) && this.end.isEqual(t2.deletionPosition)) {
              return new $h(this.start);
            }
            let e2 = this.start._getTransformedByMergeOperation(t2);
            let i2 = this.end._getTransformedByMergeOperation(t2);
            if (e2.root != i2.root) {
              i2 = this.end.getShiftedBy(-1);
            }
            if (e2.isAfter(i2)) {
              if (t2.sourcePosition.isBefore(t2.targetPosition)) {
                e2 = Uh._createAt(i2);
                e2.offset = 0;
              } else {
                if (!t2.deletionPosition.isEqual(e2)) {
                  i2 = t2.deletionPosition;
                }
                e2 = t2.targetPosition;
              }
              return new $h(e2, i2);
            }
            return new $h(e2, i2);
          }
          _getTransformedByInsertion(t2, e2, i2 = false) {
            if (i2 && this.containsPosition(t2)) {
              return [new $h(this.start, t2), new $h(t2.getShiftedBy(e2), this.end._getTransformedByInsertion(t2, e2))];
            } else {
              const i3 = new $h(this.start, this.end);
              i3.start = i3.start._getTransformedByInsertion(t2, e2);
              i3.end = i3.end._getTransformedByInsertion(t2, e2);
              return [i3];
            }
          }
          _getTransformedByMove(t2, e2, i2, n2 = false) {
            if (this.isCollapsed) {
              const n3 = this.start._getTransformedByMove(t2, e2, i2);
              return [new $h(n3)];
            }
            const o2 = $h._createFromPositionAndShift(t2, i2);
            const r2 = e2._getTransformedByDeletion(t2, i2);
            if (this.containsPosition(e2) && !n2) {
              if (o2.containsPosition(this.start) || o2.containsPosition(this.end)) {
                const n3 = this.start._getTransformedByMove(t2, e2, i2);
                const o3 = this.end._getTransformedByMove(t2, e2, i2);
                return [new $h(n3, o3)];
              }
            }
            let s2;
            const a2 = this.getDifference(o2);
            let c2 = null;
            const l2 = this.getIntersection(o2);
            if (a2.length == 1) {
              c2 = new $h(a2[0].start._getTransformedByDeletion(t2, i2), a2[0].end._getTransformedByDeletion(t2, i2));
            } else if (a2.length == 2) {
              c2 = new $h(this.start, this.end._getTransformedByDeletion(t2, i2));
            }
            if (c2) {
              s2 = c2._getTransformedByInsertion(r2, i2, l2 !== null || n2);
            } else {
              s2 = [];
            }
            if (l2) {
              const t3 = new $h(l2.start._getCombined(o2.start, r2), l2.end._getCombined(o2.start, r2));
              if (s2.length == 2) {
                s2.splice(1, 0, t3);
              } else {
                s2.push(t3);
              }
            }
            return s2;
          }
          _getTransformedByDeletion(t2, e2) {
            let i2 = this.start._getTransformedByDeletion(t2, e2);
            let n2 = this.end._getTransformedByDeletion(t2, e2);
            if (i2 == null && n2 == null) {
              return null;
            }
            if (i2 == null) {
              i2 = t2;
            }
            if (n2 == null) {
              n2 = t2;
            }
            return new $h(i2, n2);
          }
          static _createFromPositionAndShift(t2, e2) {
            const i2 = t2;
            const n2 = t2.getShiftedBy(e2);
            return e2 > 0 ? new this(i2, n2) : new this(n2, i2);
          }
          static _createIn(t2) {
            return new this(Uh._createAt(t2, 0), Uh._createAt(t2, t2.maxOffset));
          }
          static _createOn(t2) {
            return this._createFromPositionAndShift(Uh._createBefore(t2), t2.offsetSize);
          }
          static _createFromRanges(t2) {
            if (t2.length === 0) {
              throw new ss["b"]("range-create-from-ranges-empty-array: At least one range has to be passed.", null);
            } else if (t2.length == 1) {
              return t2[0].clone();
            }
            const e2 = t2[0];
            t2.sort((t3, e3) => t3.start.isAfter(e3.start) ? 1 : -1);
            const i2 = t2.indexOf(e2);
            const n2 = new this(e2.start, e2.end);
            if (i2 > 0) {
              for (let e3 = i2 - 1; true; e3++) {
                if (t2[e3].end.isEqual(n2.start)) {
                  n2.start = Uh._createAt(t2[e3].start);
                } else {
                  break;
                }
              }
            }
            for (let e3 = i2 + 1; e3 < t2.length; e3++) {
              if (t2[e3].start.isEqual(n2.end)) {
                n2.end = Uh._createAt(t2[e3].end);
              } else {
                break;
              }
            }
            return n2;
          }
          static fromJSON(t2, e2) {
            return new this(Uh.fromJSON(t2.start, e2), Uh.fromJSON(t2.end, e2));
          }
        }
        class Gh {
          constructor() {
            this._modelToViewMapping = new WeakMap();
            this._viewToModelMapping = new WeakMap();
            this._viewToModelLengthCallbacks = new Map();
            this._markerNameToElements = new Map();
            this._elementToMarkerNames = new Map();
            this._unboundMarkerNames = new Set();
            this.on("modelToViewPosition", (t2, e2) => {
              if (e2.viewPosition) {
                return;
              }
              const i2 = this._modelToViewMapping.get(e2.modelPosition.parent);
              e2.viewPosition = this._findPositionIn(i2, e2.modelPosition.offset);
            }, {priority: "low"});
            this.on("viewToModelPosition", (t2, e2) => {
              if (e2.modelPosition) {
                return;
              }
              const i2 = this.findMappedViewAncestor(e2.viewPosition);
              const n2 = this._viewToModelMapping.get(i2);
              const o2 = this._toModelOffset(e2.viewPosition.parent, e2.viewPosition.offset, i2);
              e2.modelPosition = Uh._createAt(n2, o2);
            }, {priority: "low"});
          }
          bindElements(t2, e2) {
            this._modelToViewMapping.set(t2, e2);
            this._viewToModelMapping.set(e2, t2);
          }
          unbindViewElement(t2) {
            const e2 = this.toModelElement(t2);
            this._viewToModelMapping.delete(t2);
            if (this._elementToMarkerNames.has(t2)) {
              for (const e3 of this._elementToMarkerNames.get(t2)) {
                this._unboundMarkerNames.add(e3);
              }
            }
            if (this._modelToViewMapping.get(e2) == t2) {
              this._modelToViewMapping.delete(e2);
            }
          }
          unbindModelElement(t2) {
            const e2 = this.toViewElement(t2);
            this._modelToViewMapping.delete(t2);
            if (this._viewToModelMapping.get(e2) == t2) {
              this._viewToModelMapping.delete(e2);
            }
          }
          bindElementToMarker(t2, e2) {
            const i2 = this._markerNameToElements.get(e2) || new Set();
            i2.add(t2);
            const n2 = this._elementToMarkerNames.get(t2) || new Set();
            n2.add(e2);
            this._markerNameToElements.set(e2, i2);
            this._elementToMarkerNames.set(t2, n2);
          }
          unbindElementFromMarkerName(t2, e2) {
            const i2 = this._markerNameToElements.get(e2);
            if (i2) {
              i2.delete(t2);
              if (i2.size == 0) {
                this._markerNameToElements.delete(e2);
              }
            }
            const n2 = this._elementToMarkerNames.get(t2);
            if (n2) {
              n2.delete(e2);
              if (n2.size == 0) {
                this._elementToMarkerNames.delete(t2);
              }
            }
          }
          flushUnboundMarkerNames() {
            const t2 = Array.from(this._unboundMarkerNames);
            this._unboundMarkerNames.clear();
            return t2;
          }
          clearBindings() {
            this._modelToViewMapping = new WeakMap();
            this._viewToModelMapping = new WeakMap();
            this._markerNameToElements = new Map();
            this._elementToMarkerNames = new Map();
            this._unboundMarkerNames = new Set();
          }
          toModelElement(t2) {
            return this._viewToModelMapping.get(t2);
          }
          toViewElement(t2) {
            return this._modelToViewMapping.get(t2);
          }
          toModelRange(t2) {
            return new $h(this.toModelPosition(t2.start), this.toModelPosition(t2.end));
          }
          toViewRange(t2) {
            return new ul(this.toViewPosition(t2.start), this.toViewPosition(t2.end));
          }
          toModelPosition(t2) {
            const e2 = {viewPosition: t2, mapper: this};
            this.fire("viewToModelPosition", e2);
            return e2.modelPosition;
          }
          toViewPosition(t2, e2 = {isPhantom: false}) {
            const i2 = {modelPosition: t2, mapper: this, isPhantom: e2.isPhantom};
            this.fire("modelToViewPosition", i2);
            return i2.viewPosition;
          }
          markerNameToElements(t2) {
            const e2 = this._markerNameToElements.get(t2);
            if (!e2) {
              return null;
            }
            const i2 = new Set();
            for (const t3 of e2) {
              if (t3.is("attributeElement")) {
                for (const e3 of t3.getElementsWithSameId()) {
                  i2.add(e3);
                }
              } else {
                i2.add(t3);
              }
            }
            return i2;
          }
          registerViewToModelLength(t2, e2) {
            this._viewToModelLengthCallbacks.set(t2, e2);
          }
          findMappedViewAncestor(t2) {
            let e2 = t2.parent;
            while (!this._viewToModelMapping.has(e2)) {
              e2 = e2.parent;
            }
            return e2;
          }
          _toModelOffset(t2, e2, i2) {
            if (i2 != t2) {
              const n3 = this._toModelOffset(t2.parent, t2.index, i2);
              const o2 = this._toModelOffset(t2, e2, t2);
              return n3 + o2;
            }
            if (t2.is("text")) {
              return e2;
            }
            let n2 = 0;
            for (let i3 = 0; i3 < e2; i3++) {
              n2 += this.getModelLength(t2.getChild(i3));
            }
            return n2;
          }
          getModelLength(t2) {
            if (this._viewToModelLengthCallbacks.get(t2.name)) {
              const e2 = this._viewToModelLengthCallbacks.get(t2.name);
              return e2(t2);
            } else if (this._viewToModelMapping.has(t2)) {
              return 1;
            } else if (t2.is("text")) {
              return t2.data.length;
            } else if (t2.is("uiElement")) {
              return 0;
            } else {
              let e2 = 0;
              for (const i2 of t2.getChildren()) {
                e2 += this.getModelLength(i2);
              }
              return e2;
            }
          }
          _findPositionIn(t2, e2) {
            let i2;
            let n2 = 0;
            let o2 = 0;
            let r2 = 0;
            if (t2.is("text")) {
              return new dl(t2, e2);
            }
            while (o2 < e2) {
              i2 = t2.getChild(r2);
              n2 = this.getModelLength(i2);
              o2 += n2;
              r2++;
            }
            if (o2 == e2) {
              return this._moveViewPositionToTextNode(new dl(t2, r2));
            } else {
              return this._findPositionIn(i2, e2 - (o2 - n2));
            }
          }
          _moveViewPositionToTextNode(t2) {
            const e2 = t2.nodeBefore;
            const i2 = t2.nodeAfter;
            if (e2 instanceof Ls) {
              return new dl(e2, e2.data.length);
            } else if (i2 instanceof Ls) {
              return new dl(i2, 0);
            }
            return t2;
          }
        }
        vs(Gh, ds);
        class Kh {
          constructor() {
            this._consumable = new Map();
            this._textProxyRegistry = new Map();
          }
          add(t2, e2) {
            e2 = Jh(e2);
            if (t2 instanceof Fh) {
              t2 = this._getSymbolForTextProxy(t2);
            }
            if (!this._consumable.has(t2)) {
              this._consumable.set(t2, new Map());
            }
            this._consumable.get(t2).set(e2, true);
          }
          consume(t2, e2) {
            e2 = Jh(e2);
            if (t2 instanceof Fh) {
              t2 = this._getSymbolForTextProxy(t2);
            }
            if (this.test(t2, e2)) {
              this._consumable.get(t2).set(e2, false);
              return true;
            } else {
              return false;
            }
          }
          test(t2, e2) {
            e2 = Jh(e2);
            if (t2 instanceof Fh) {
              t2 = this._getSymbolForTextProxy(t2);
            }
            const i2 = this._consumable.get(t2);
            if (i2 === void 0) {
              return null;
            }
            const n2 = i2.get(e2);
            if (n2 === void 0) {
              return null;
            }
            return n2;
          }
          revert(t2, e2) {
            e2 = Jh(e2);
            if (t2 instanceof Fh) {
              t2 = this._getSymbolForTextProxy(t2);
            }
            const i2 = this.test(t2, e2);
            if (i2 === false) {
              this._consumable.get(t2).set(e2, true);
              return true;
            } else if (i2 === true) {
              return false;
            }
            return null;
          }
          _getSymbolForTextProxy(t2) {
            let e2 = null;
            const i2 = this._textProxyRegistry.get(t2.startOffset);
            if (i2) {
              const n2 = i2.get(t2.endOffset);
              if (n2) {
                e2 = n2.get(t2.parent);
              }
            }
            if (!e2) {
              e2 = this._addSymbolForTextProxy(t2.startOffset, t2.endOffset, t2.parent);
            }
            return e2;
          }
          _addSymbolForTextProxy(t2, e2, i2) {
            const n2 = Symbol("textProxySymbol");
            let o2, r2;
            o2 = this._textProxyRegistry.get(t2);
            if (!o2) {
              o2 = new Map();
              this._textProxyRegistry.set(t2, o2);
            }
            r2 = o2.get(e2);
            if (!r2) {
              r2 = new Map();
              o2.set(e2, r2);
            }
            r2.set(i2, n2);
            return n2;
          }
        }
        function Jh(t2) {
          const e2 = t2.split(":");
          return e2.length > 1 ? e2[0] + ":" + e2[1] : e2[0];
        }
        class Yh {
          constructor(t2) {
            this.conversionApi = qc({dispatcher: this}, t2);
          }
          convertChanges(t2, e2, i2) {
            for (const e3 of t2.getMarkersToRemove()) {
              this.convertMarkerRemove(e3.name, e3.range, i2);
            }
            for (const e3 of t2.getChanges()) {
              if (e3.type == "insert") {
                this.convertInsert($h._createFromPositionAndShift(e3.position, e3.length), i2);
              } else if (e3.type == "remove") {
                this.convertRemove(e3.position, e3.length, e3.name, i2);
              } else {
                this.convertAttribute(e3.range, e3.attributeKey, e3.attributeOldValue, e3.attributeNewValue, i2);
              }
            }
            for (const t3 of this.conversionApi.mapper.flushUnboundMarkerNames()) {
              const n2 = e2.get(t3).getRange();
              this.convertMarkerRemove(t3, n2, i2);
              this.convertMarkerAdd(t3, n2, i2);
            }
            for (const e3 of t2.getMarkersToAdd()) {
              this.convertMarkerAdd(e3.name, e3.range, i2);
            }
          }
          convertInsert(t2, e2) {
            this.conversionApi.writer = e2;
            this.conversionApi.consumable = this._createInsertConsumable(t2);
            for (const e3 of t2) {
              const t3 = e3.item;
              const i2 = $h._createFromPositionAndShift(e3.previousPosition, e3.length);
              const n2 = {item: t3, range: i2};
              this._testAndFire("insert", n2);
              for (const e4 of t3.getAttributeKeys()) {
                n2.attributeKey = e4;
                n2.attributeOldValue = null;
                n2.attributeNewValue = t3.getAttribute(e4);
                this._testAndFire(`attribute:${e4}`, n2);
              }
            }
            this._clearConversionApi();
          }
          convertRemove(t2, e2, i2, n2) {
            this.conversionApi.writer = n2;
            this.fire("remove:" + i2, {position: t2, length: e2}, this.conversionApi);
            this._clearConversionApi();
          }
          convertAttribute(t2, e2, i2, n2, o2) {
            this.conversionApi.writer = o2;
            this.conversionApi.consumable = this._createConsumableForRange(t2, `attribute:${e2}`);
            for (const o3 of t2) {
              const t3 = o3.item;
              const r2 = $h._createFromPositionAndShift(o3.previousPosition, o3.length);
              const s2 = {item: t3, range: r2, attributeKey: e2, attributeOldValue: i2, attributeNewValue: n2};
              this._testAndFire(`attribute:${e2}`, s2);
            }
            this._clearConversionApi();
          }
          convertSelection(t2, e2, i2) {
            const n2 = Array.from(e2.getMarkersAtPosition(t2.getFirstPosition()));
            this.conversionApi.writer = i2;
            this.conversionApi.consumable = this._createSelectionConsumable(t2, n2);
            this.fire("selection", {selection: t2}, this.conversionApi);
            if (!t2.isCollapsed) {
              return;
            }
            for (const e3 of n2) {
              const i3 = e3.getRange();
              if (!Qh(t2.getFirstPosition(), e3, this.conversionApi.mapper)) {
                continue;
              }
              const n3 = {item: t2, markerName: e3.name, markerRange: i3};
              if (this.conversionApi.consumable.test(t2, "addMarker:" + e3.name)) {
                this.fire("addMarker:" + e3.name, n3, this.conversionApi);
              }
            }
            for (const e3 of t2.getAttributeKeys()) {
              const i3 = {
                item: t2,
                range: t2.getFirstRange(),
                attributeKey: e3,
                attributeOldValue: null,
                attributeNewValue: t2.getAttribute(e3)
              };
              if (this.conversionApi.consumable.test(t2, "attribute:" + i3.attributeKey)) {
                this.fire("attribute:" + i3.attributeKey + ":$text", i3, this.conversionApi);
              }
            }
            this._clearConversionApi();
          }
          convertMarkerAdd(t2, e2, i2) {
            if (!e2.root.document || e2.root.rootName == "$graveyard") {
              return;
            }
            this.conversionApi.writer = i2;
            const n2 = "addMarker:" + t2;
            const o2 = new Kh();
            o2.add(e2, n2);
            this.conversionApi.consumable = o2;
            this.fire(n2, {markerName: t2, markerRange: e2}, this.conversionApi);
            if (!o2.test(e2, n2)) {
              return;
            }
            this.conversionApi.consumable = this._createConsumableForRange(e2, n2);
            for (const i3 of e2.getItems()) {
              if (!this.conversionApi.consumable.test(i3, n2)) {
                continue;
              }
              const o3 = {item: i3, range: $h._createOn(i3), markerName: t2, markerRange: e2};
              this.fire(n2, o3, this.conversionApi);
            }
            this._clearConversionApi();
          }
          convertMarkerRemove(t2, e2, i2) {
            if (!e2.root.document || e2.root.rootName == "$graveyard") {
              return;
            }
            this.conversionApi.writer = i2;
            this.fire("removeMarker:" + t2, {markerName: t2, markerRange: e2}, this.conversionApi);
            this._clearConversionApi();
          }
          _createInsertConsumable(t2) {
            const e2 = new Kh();
            for (const i2 of t2) {
              const t3 = i2.item;
              e2.add(t3, "insert");
              for (const i3 of t3.getAttributeKeys()) {
                e2.add(t3, "attribute:" + i3);
              }
            }
            return e2;
          }
          _createConsumableForRange(t2, e2) {
            const i2 = new Kh();
            for (const n2 of t2.getItems()) {
              i2.add(n2, e2);
            }
            return i2;
          }
          _createSelectionConsumable(t2, e2) {
            const i2 = new Kh();
            i2.add(t2, "selection");
            for (const n2 of e2) {
              i2.add(t2, "addMarker:" + n2.name);
            }
            for (const e3 of t2.getAttributeKeys()) {
              i2.add(t2, "attribute:" + e3);
            }
            return i2;
          }
          _testAndFire(t2, e2) {
            if (!this.conversionApi.consumable.test(e2.item, t2)) {
              return;
            }
            const i2 = e2.item.name || "$text";
            this.fire(t2 + ":" + i2, e2, this.conversionApi);
          }
          _clearConversionApi() {
            delete this.conversionApi.writer;
            delete this.conversionApi.consumable;
          }
        }
        vs(Yh, ds);
        function Qh(t2, e2, i2) {
          const n2 = e2.getRange();
          const o2 = Array.from(t2.getAncestors());
          o2.shift();
          o2.reverse();
          const r2 = o2.some((t3) => {
            if (n2.containsItem(t3)) {
              const e3 = i2.toViewElement(t3);
              return !!e3.getCustomProperty("addHighlight");
            }
          });
          return !r2;
        }
        class Xh {
          constructor(t2, e2, i2) {
            this._lastRangeBackward = false;
            this._ranges = [];
            this._attrs = new Map();
            if (t2) {
              this.setTo(t2, e2, i2);
            }
          }
          get anchor() {
            if (this._ranges.length > 0) {
              const t2 = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t2.end : t2.start;
            }
            return null;
          }
          get focus() {
            if (this._ranges.length > 0) {
              const t2 = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t2.start : t2.end;
            }
            return null;
          }
          get isCollapsed() {
            const t2 = this._ranges.length;
            if (t2 === 1) {
              return this._ranges[0].isCollapsed;
            } else {
              return false;
            }
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          isEqual(t2) {
            if (this.rangeCount != t2.rangeCount) {
              return false;
            } else if (this.rangeCount === 0) {
              return true;
            }
            if (!this.anchor.isEqual(t2.anchor) || !this.focus.isEqual(t2.focus)) {
              return false;
            }
            for (const e2 of this._ranges) {
              let i2 = false;
              for (const n2 of t2._ranges) {
                if (e2.isEqual(n2)) {
                  i2 = true;
                  break;
                }
              }
              if (!i2) {
                return false;
              }
            }
            return true;
          }
          *getRanges() {
            for (const t2 of this._ranges) {
              yield new $h(t2.start, t2.end);
            }
          }
          getFirstRange() {
            let t2 = null;
            for (const e2 of this._ranges) {
              if (!t2 || e2.start.isBefore(t2.start)) {
                t2 = e2;
              }
            }
            return t2 ? new $h(t2.start, t2.end) : null;
          }
          getLastRange() {
            let t2 = null;
            for (const e2 of this._ranges) {
              if (!t2 || e2.end.isAfter(t2.end)) {
                t2 = e2;
              }
            }
            return t2 ? new $h(t2.start, t2.end) : null;
          }
          getFirstPosition() {
            const t2 = this.getFirstRange();
            return t2 ? t2.start.clone() : null;
          }
          getLastPosition() {
            const t2 = this.getLastRange();
            return t2 ? t2.end.clone() : null;
          }
          setTo(t2, e2, i2) {
            if (t2 === null) {
              this._setRanges([]);
            } else if (t2 instanceof Xh) {
              this._setRanges(t2.getRanges(), t2.isBackward);
            } else if (t2 && typeof t2.getRanges == "function") {
              this._setRanges(t2.getRanges(), t2.isBackward);
            } else if (t2 instanceof $h) {
              this._setRanges([t2], !!e2 && !!e2.backward);
            } else if (t2 instanceof Uh) {
              this._setRanges([new $h(t2)]);
            } else if (t2 instanceof zh) {
              const n2 = !!i2 && !!i2.backward;
              let o2;
              if (e2 == "in") {
                o2 = $h._createIn(t2);
              } else if (e2 == "on") {
                o2 = $h._createOn(t2);
              } else if (e2 !== void 0) {
                o2 = new $h(Uh._createAt(t2, e2));
              } else {
                throw new ss["b"]("model-selection-setTo-required-second-parameter: selection.setTo requires the second parameter when the first parameter is a node.", [this, t2]);
              }
              this._setRanges([o2], n2);
            } else if (js(t2)) {
              this._setRanges(t2, e2 && !!e2.backward);
            } else {
              throw new ss["b"]("model-selection-setTo-not-selectable: Cannot set the selection to the given place.", [this, t2]);
            }
          }
          _setRanges(t2, e2 = false) {
            t2 = Array.from(t2);
            const i2 = t2.some((e3) => {
              if (!(e3 instanceof $h)) {
                throw new ss["b"]("model-selection-set-ranges-not-range: Selection range set to an object that is not an instance of model.Range.", [this, t2]);
              }
              return this._ranges.every((t3) => !t3.isEqual(e3));
            });
            if (t2.length === this._ranges.length && !i2) {
              return;
            }
            this._removeAllRanges();
            for (const e3 of t2) {
              this._pushRange(e3);
            }
            this._lastRangeBackward = !!e2;
            this.fire("change:range", {directChange: true});
          }
          setFocus(t2, e2) {
            if (this.anchor === null) {
              throw new ss["b"]("model-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.", [this, t2]);
            }
            const i2 = Uh._createAt(t2, e2);
            if (i2.compareWith(this.focus) == "same") {
              return;
            }
            const n2 = this.anchor;
            if (this._ranges.length) {
              this._popRange();
            }
            if (i2.compareWith(n2) == "before") {
              this._pushRange(new $h(i2, n2));
              this._lastRangeBackward = true;
            } else {
              this._pushRange(new $h(n2, i2));
              this._lastRangeBackward = false;
            }
            this.fire("change:range", {directChange: true});
          }
          getAttribute(t2) {
            return this._attrs.get(t2);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          hasAttribute(t2) {
            return this._attrs.has(t2);
          }
          removeAttribute(t2) {
            if (this.hasAttribute(t2)) {
              this._attrs.delete(t2);
              this.fire("change:attribute", {attributeKeys: [t2], directChange: true});
            }
          }
          setAttribute(t2, e2) {
            if (this.getAttribute(t2) !== e2) {
              this._attrs.set(t2, e2);
              this.fire("change:attribute", {attributeKeys: [t2], directChange: true});
            }
          }
          getSelectedElement() {
            if (this.rangeCount !== 1) {
              return null;
            }
            return this.getFirstRange().getContainedElement();
          }
          is(t2) {
            return t2 == "selection" || t2 == "model:selection";
          }
          *getSelectedBlocks() {
            const t2 = new WeakSet();
            for (const e2 of this.getRanges()) {
              const i2 = ef(e2.start, t2);
              if (i2 && nf(i2, e2)) {
                yield i2;
              }
              for (const i3 of e2.getWalker()) {
                const n3 = i3.item;
                if (i3.type == "elementEnd" && tf(n3, t2, e2)) {
                  yield n3;
                }
              }
              const n2 = ef(e2.end, t2);
              if (n2 && !e2.end.isTouching(Uh._createAt(n2, 0)) && nf(n2, e2)) {
                yield n2;
              }
            }
          }
          containsEntireContent(t2 = this.anchor.root) {
            const e2 = Uh._createAt(t2, 0);
            const i2 = Uh._createAt(t2, "end");
            return e2.isTouching(this.getFirstPosition()) && i2.isTouching(this.getLastPosition());
          }
          _pushRange(t2) {
            this._checkRange(t2);
            this._ranges.push(new $h(t2.start, t2.end));
          }
          _checkRange(t2) {
            for (let e2 = 0; e2 < this._ranges.length; e2++) {
              if (t2.isIntersecting(this._ranges[e2])) {
                throw new ss["b"]("model-selection-range-intersects: Trying to add a range that intersects with another range in the selection.", [this, t2], {
                  addedRange: t2,
                  intersectingRange: this._ranges[e2]
                });
              }
            }
          }
          _removeAllRanges() {
            while (this._ranges.length > 0) {
              this._popRange();
            }
          }
          _popRange() {
            this._ranges.pop();
          }
        }
        vs(Xh, ds);
        function Zh(t2, e2) {
          if (e2.has(t2)) {
            return false;
          }
          e2.add(t2);
          return t2.root.document.model.schema.isBlock(t2) && t2.parent;
        }
        function tf(t2, e2, i2) {
          return Zh(t2, e2) && nf(t2, i2);
        }
        function ef(t2, e2) {
          const i2 = t2.parent;
          const n2 = i2.root.document.model.schema;
          const o2 = t2.parent.getAncestors({parentFirst: true, includeSelf: true});
          let r2 = false;
          const s2 = o2.find((t3) => {
            if (r2) {
              return false;
            }
            r2 = n2.isLimit(t3);
            return !r2 && Zh(t3, e2);
          });
          o2.forEach((t3) => e2.add(t3));
          return s2;
        }
        function nf(t2, e2) {
          const i2 = of(t2);
          if (!i2) {
            return true;
          }
          const n2 = e2.containsRange($h._createOn(i2), true);
          return !n2;
        }
        function of(t2) {
          const e2 = t2.root.document.model.schema;
          let i2 = t2.parent;
          while (i2) {
            if (e2.isBlock(i2)) {
              return i2;
            }
            i2 = i2.parent;
          }
        }
        class rf extends $h {
          constructor(t2, e2) {
            super(t2, e2);
            sf.call(this);
          }
          detach() {
            this.stopListening();
          }
          is(t2) {
            return t2 == "liveRange" || t2 == "model:liveRange" || super.is(t2);
          }
          toRange() {
            return new $h(this.start, this.end);
          }
          static fromRange(t2) {
            return new rf(t2.start, t2.end);
          }
        }
        function sf() {
          this.listenTo(this.root.document.model, "applyOperation", (t2, e2) => {
            const i2 = e2[0];
            if (!i2.isDocumentOperation) {
              return;
            }
            af.call(this, i2);
          }, {priority: "low"});
        }
        function af(t2) {
          const e2 = this.getTransformedByOperation(t2);
          const i2 = $h._createFromRanges(e2);
          const n2 = !i2.isEqual(this);
          const o2 = cf(this, t2);
          let r2 = null;
          if (n2) {
            if (i2.root.rootName == "$graveyard") {
              if (t2.type == "remove") {
                r2 = t2.sourcePosition;
              } else {
                r2 = t2.deletionPosition;
              }
            }
            const e3 = this.toRange();
            this.start = i2.start;
            this.end = i2.end;
            this.fire("change:range", e3, {deletionPosition: r2});
          } else if (o2) {
            this.fire("change:content", this.toRange(), {deletionPosition: r2});
          }
        }
        function cf(t2, e2) {
          switch (e2.type) {
            case "insert":
              return t2.containsPosition(e2.position);
            case "move":
            case "remove":
            case "reinsert":
            case "merge":
              return t2.containsPosition(e2.sourcePosition) || t2.start.isEqual(e2.sourcePosition) || t2.containsPosition(e2.targetPosition);
            case "split":
              return t2.containsPosition(e2.splitPosition) || t2.containsPosition(e2.insertionPosition);
          }
          return false;
        }
        vs(rf, ds);
        const lf = "selection:";
        class df {
          constructor(t2) {
            this._selection = new uf(t2);
            this._selection.delegate("change:range").to(this);
            this._selection.delegate("change:attribute").to(this);
            this._selection.delegate("change:marker").to(this);
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get hasOwnRange() {
            return this._selection.hasOwnRange;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get isGravityOverridden() {
            return this._selection.isGravityOverridden;
          }
          get markers() {
            return this._selection.markers;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          getRanges() {
            return this._selection.getRanges();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getSelectedBlocks() {
            return this._selection.getSelectedBlocks();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          containsEntireContent(t2) {
            return this._selection.containsEntireContent(t2);
          }
          destroy() {
            this._selection.destroy();
          }
          getAttributeKeys() {
            return this._selection.getAttributeKeys();
          }
          getAttributes() {
            return this._selection.getAttributes();
          }
          getAttribute(t2) {
            return this._selection.getAttribute(t2);
          }
          hasAttribute(t2) {
            return this._selection.hasAttribute(t2);
          }
          refresh() {
            this._selection._updateMarkers();
            this._selection._updateAttributes(false);
          }
          is(t2) {
            return t2 == "selection" || t2 == "model:selection" || t2 == "documentSelection" || t2 == "model:documentSelection";
          }
          _setFocus(t2, e2) {
            this._selection.setFocus(t2, e2);
          }
          _setTo(t2, e2, i2) {
            this._selection.setTo(t2, e2, i2);
          }
          _setAttribute(t2, e2) {
            this._selection.setAttribute(t2, e2);
          }
          _removeAttribute(t2) {
            this._selection.removeAttribute(t2);
          }
          _getStoredAttributes() {
            return this._selection._getStoredAttributes();
          }
          _overrideGravity() {
            return this._selection.overrideGravity();
          }
          _restoreGravity(t2) {
            this._selection.restoreGravity(t2);
          }
          static _getStoreAttributeKey(t2) {
            return lf + t2;
          }
          static _isStoreAttributeKey(t2) {
            return t2.startsWith(lf);
          }
        }
        vs(df, ds);
        class uf extends Xh {
          constructor(t2) {
            super();
            this.markers = new ys({idProperty: "name"});
            this._model = t2.model;
            this._document = t2;
            this._attributePriority = new Map();
            this._fixGraveyardRangesData = [];
            this._hasChangedRange = false;
            this._overriddenGravityRegister = new Set();
            this.listenTo(this._model, "applyOperation", (t3, e2) => {
              const i2 = e2[0];
              if (!i2.isDocumentOperation || i2.type == "marker" || i2.type == "rename" || i2.type == "noop") {
                return;
              }
              while (this._fixGraveyardRangesData.length) {
                const {liveRange: t4, sourcePosition: e3} = this._fixGraveyardRangesData.shift();
                this._fixGraveyardSelection(t4, e3);
              }
              if (this._hasChangedRange) {
                this._hasChangedRange = false;
                this.fire("change:range", {directChange: false});
              }
            }, {priority: "lowest"});
            this.on("change:range", () => {
              for (const t3 of this.getRanges()) {
                if (!this._document._validateSelectionRange(t3)) {
                  throw new ss["b"]("document-selection-wrong-position: Range from document selection starts or ends at incorrect position.", this, {range: t3});
                }
              }
            });
            this.listenTo(this._model.markers, "update", () => this._updateMarkers());
            this.listenTo(this._document, "change", (t3, e2) => {
              ff(this._model, e2);
            });
          }
          get isCollapsed() {
            const t2 = this._ranges.length;
            return t2 === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
          }
          get anchor() {
            return super.anchor || this._document._getDefaultRange().start;
          }
          get focus() {
            return super.focus || this._document._getDefaultRange().end;
          }
          get rangeCount() {
            return this._ranges.length ? this._ranges.length : 1;
          }
          get hasOwnRange() {
            return this._ranges.length > 0;
          }
          get isGravityOverridden() {
            return !!this._overriddenGravityRegister.size;
          }
          destroy() {
            for (let t2 = 0; t2 < this._ranges.length; t2++) {
              this._ranges[t2].detach();
            }
            this.stopListening();
          }
          *getRanges() {
            if (this._ranges.length) {
              yield* super.getRanges();
            } else {
              yield this._document._getDefaultRange();
            }
          }
          getFirstRange() {
            return super.getFirstRange() || this._document._getDefaultRange();
          }
          getLastRange() {
            return super.getLastRange() || this._document._getDefaultRange();
          }
          setTo(t2, e2, i2) {
            super.setTo(t2, e2, i2);
            this._updateAttributes(true);
            this._updateMarkers();
          }
          setFocus(t2, e2) {
            super.setFocus(t2, e2);
            this._updateAttributes(true);
            this._updateMarkers();
          }
          setAttribute(t2, e2) {
            if (this._setAttribute(t2, e2)) {
              const e3 = [t2];
              this.fire("change:attribute", {attributeKeys: e3, directChange: true});
            }
          }
          removeAttribute(t2) {
            if (this._removeAttribute(t2)) {
              const e2 = [t2];
              this.fire("change:attribute", {attributeKeys: e2, directChange: true});
            }
          }
          overrideGravity() {
            const t2 = is();
            this._overriddenGravityRegister.add(t2);
            if (this._overriddenGravityRegister.size === 1) {
              this._updateAttributes(true);
            }
            return t2;
          }
          restoreGravity(t2) {
            if (!this._overriddenGravityRegister.has(t2)) {
              throw new ss["b"]("document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.", this, {uid: t2});
            }
            this._overriddenGravityRegister.delete(t2);
            if (!this.isGravityOverridden) {
              this._updateAttributes(true);
            }
          }
          _popRange() {
            this._ranges.pop().detach();
          }
          _pushRange(t2) {
            const e2 = this._prepareRange(t2);
            if (e2) {
              this._ranges.push(e2);
            }
          }
          _prepareRange(t2) {
            this._checkRange(t2);
            if (t2.root == this._document.graveyard) {
              return;
            }
            const e2 = rf.fromRange(t2);
            e2.on("change:range", (t3, i2, n2) => {
              this._hasChangedRange = true;
              if (e2.root == this._document.graveyard) {
                this._fixGraveyardRangesData.push({liveRange: e2, sourcePosition: n2.deletionPosition});
              }
            });
            return e2;
          }
          _updateMarkers() {
            const t2 = [];
            let e2 = false;
            for (const e3 of this._model.markers) {
              const i3 = e3.getRange();
              for (const n2 of this.getRanges()) {
                if (i3.containsRange(n2, !n2.isCollapsed)) {
                  t2.push(e3);
                }
              }
            }
            const i2 = Array.from(this.markers);
            for (const i3 of t2) {
              if (!this.markers.has(i3)) {
                this.markers.add(i3);
                e2 = true;
              }
            }
            for (const i3 of Array.from(this.markers)) {
              if (!t2.includes(i3)) {
                this.markers.remove(i3);
                e2 = true;
              }
            }
            if (e2) {
              this.fire("change:marker", {oldMarkers: i2, directChange: false});
            }
          }
          _updateAttributes(t2) {
            const e2 = Hs(this._getSurroundingAttributes());
            const i2 = Hs(this.getAttributes());
            if (t2) {
              this._attributePriority = new Map();
              this._attrs = new Map();
            } else {
              for (const [t3, e3] of this._attributePriority) {
                if (e3 == "low") {
                  this._attrs.delete(t3);
                  this._attributePriority.delete(t3);
                }
              }
            }
            this._setAttributesTo(e2);
            const n2 = [];
            for (const [t3, e3] of this.getAttributes()) {
              if (!i2.has(t3) || i2.get(t3) !== e3) {
                n2.push(t3);
              }
            }
            for (const [t3] of i2) {
              if (!this.hasAttribute(t3)) {
                n2.push(t3);
              }
            }
            if (n2.length > 0) {
              this.fire("change:attribute", {attributeKeys: n2, directChange: false});
            }
          }
          _setAttribute(t2, e2, i2 = true) {
            const n2 = i2 ? "normal" : "low";
            if (n2 == "low" && this._attributePriority.get(t2) == "normal") {
              return false;
            }
            const o2 = super.getAttribute(t2);
            if (o2 === e2) {
              return false;
            }
            this._attrs.set(t2, e2);
            this._attributePriority.set(t2, n2);
            return true;
          }
          _removeAttribute(t2, e2 = true) {
            const i2 = e2 ? "normal" : "low";
            if (i2 == "low" && this._attributePriority.get(t2) == "normal") {
              return false;
            }
            this._attributePriority.set(t2, i2);
            if (!super.hasAttribute(t2)) {
              return false;
            }
            this._attrs.delete(t2);
            return true;
          }
          _setAttributesTo(t2) {
            const e2 = new Set();
            for (const [e3, i2] of this.getAttributes()) {
              if (t2.get(e3) === i2) {
                continue;
              }
              this._removeAttribute(e3, false);
            }
            for (const [i2, n2] of t2) {
              const t3 = this._setAttribute(i2, n2, false);
              if (t3) {
                e2.add(i2);
              }
            }
            return e2;
          }
          *_getStoredAttributes() {
            const t2 = this.getFirstPosition().parent;
            if (this.isCollapsed && t2.isEmpty) {
              for (const e2 of t2.getAttributeKeys()) {
                if (e2.startsWith(lf)) {
                  const i2 = e2.substr(lf.length);
                  yield [i2, t2.getAttribute(e2)];
                }
              }
            }
          }
          _getSurroundingAttributes() {
            const t2 = this.getFirstPosition();
            const e2 = this._model.schema;
            let i2 = null;
            if (!this.isCollapsed) {
              const t3 = this.getFirstRange();
              for (const n2 of t3) {
                if (n2.item.is("element") && e2.isObject(n2.item)) {
                  break;
                }
                if (n2.type == "text") {
                  i2 = n2.item.getAttributes();
                  break;
                }
              }
            } else {
              const e3 = t2.textNode ? t2.textNode : t2.nodeBefore;
              const n2 = t2.textNode ? t2.textNode : t2.nodeAfter;
              if (!this.isGravityOverridden) {
                i2 = hf(e3);
              }
              if (!i2) {
                i2 = hf(n2);
              }
              if (!this.isGravityOverridden && !i2) {
                let t3 = e3;
                while (t3 && !i2) {
                  t3 = t3.previousSibling;
                  i2 = hf(t3);
                }
              }
              if (!i2) {
                let t3 = n2;
                while (t3 && !i2) {
                  t3 = t3.nextSibling;
                  i2 = hf(t3);
                }
              }
              if (!i2) {
                i2 = this._getStoredAttributes();
              }
            }
            return i2;
          }
          _fixGraveyardSelection(t2, e2) {
            const i2 = e2.clone();
            const n2 = this._model.schema.getNearestSelectionRange(i2);
            const o2 = this._ranges.indexOf(t2);
            this._ranges.splice(o2, 1);
            t2.detach();
            if (n2) {
              const t3 = this._prepareRange(n2);
              this._ranges.splice(o2, 0, t3);
            }
          }
        }
        function hf(t2) {
          if (t2 instanceof Fh || t2 instanceof Lh) {
            return t2.getAttributes();
          }
          return null;
        }
        function ff(t2, e2) {
          const i2 = t2.document.differ;
          for (const n2 of i2.getChanges()) {
            if (n2.type != "insert") {
              continue;
            }
            const i3 = n2.position.parent;
            const o2 = n2.length === i3.maxOffset;
            if (o2) {
              t2.enqueueChange(e2, (t3) => {
                const e3 = Array.from(i3.getAttributeKeys()).filter((t4) => t4.startsWith(lf));
                for (const n3 of e3) {
                  t3.removeAttribute(n3, i3);
                }
              });
            }
          }
        }
        class gf {
          constructor(t2) {
            this._dispatchers = t2;
          }
          add(t2) {
            for (const e2 of this._dispatchers) {
              t2(e2);
            }
            return this;
          }
        }
        var mf = 1, pf = 4;
        function bf(t2) {
          return Hr(t2, mf | pf);
        }
        var wf = bf;
        class kf extends gf {
          elementToElement(t2) {
            return this.add(Nf(t2));
          }
          attributeToElement(t2) {
            return this.add(Mf(t2));
          }
          attributeToAttribute(t2) {
            return this.add(Bf(t2));
          }
          markerToElement(t2) {
            return this.add(zf(t2));
          }
          markerToHighlight(t2) {
            return this.add(Lf(t2));
          }
        }
        function _f() {
          return (t2, e2, i2) => {
            if (!i2.consumable.consume(e2.item, "insert")) {
              return;
            }
            const n2 = i2.writer;
            const o2 = i2.mapper.toViewPosition(e2.range.start);
            const r2 = n2.createText(e2.item.data);
            n2.insert(o2, r2);
          };
        }
        function vf() {
          return (t2, e2, i2) => {
            const n2 = i2.mapper.toViewPosition(e2.position);
            const o2 = e2.position.getShiftedBy(e2.length);
            const r2 = i2.mapper.toViewPosition(o2, {isPhantom: true});
            const s2 = i2.writer.createRange(n2, r2);
            const a2 = i2.writer.remove(s2.getTrimmed());
            for (const t3 of i2.writer.createRangeIn(a2).getItems()) {
              i2.mapper.unbindViewElement(t3);
            }
          };
        }
        function yf(t2, e2) {
          const i2 = t2.createAttributeElement("span", e2.attributes);
          if (e2.classes) {
            i2._addClass(e2.classes);
          }
          if (e2.priority) {
            i2._priority = e2.priority;
          }
          i2._id = e2.id;
          return i2;
        }
        function xf() {
          return (t2, e2, i2) => {
            const n2 = e2.selection;
            if (n2.isCollapsed) {
              return;
            }
            if (!i2.consumable.consume(n2, "selection")) {
              return;
            }
            const o2 = [];
            for (const t3 of n2.getRanges()) {
              const e3 = i2.mapper.toViewRange(t3);
              o2.push(e3);
            }
            i2.writer.setSelection(o2, {backward: n2.isBackward});
          };
        }
        function Cf() {
          return (t2, e2, i2) => {
            const n2 = e2.selection;
            if (!n2.isCollapsed) {
              return;
            }
            if (!i2.consumable.consume(n2, "selection")) {
              return;
            }
            const o2 = i2.writer;
            const r2 = n2.getFirstPosition();
            const s2 = i2.mapper.toViewPosition(r2);
            const a2 = o2.breakAttributes(s2);
            o2.setSelection(a2);
          };
        }
        function Af() {
          return (t2, e2, i2) => {
            const n2 = i2.writer;
            const o2 = n2.document.selection;
            for (const t3 of o2.getRanges()) {
              if (t3.isCollapsed) {
                if (t3.end.parent.isAttached()) {
                  i2.writer.mergeAttributes(t3.start);
                }
              }
            }
            n2.setSelection(null);
          };
        }
        function Tf(t2) {
          return (e2, i2, n2) => {
            const o2 = t2(i2.attributeOldValue, n2.writer);
            const r2 = t2(i2.attributeNewValue, n2.writer);
            if (!o2 && !r2) {
              return;
            }
            if (!n2.consumable.consume(i2.item, e2.name)) {
              return;
            }
            const s2 = n2.writer;
            const a2 = s2.document.selection;
            if (i2.item instanceof Xh || i2.item instanceof df) {
              s2.wrap(a2.getFirstRange(), r2);
            } else {
              let t3 = n2.mapper.toViewRange(i2.range);
              if (i2.attributeOldValue !== null && o2) {
                t3 = s2.unwrap(t3, o2);
              }
              if (i2.attributeNewValue !== null && r2) {
                s2.wrap(t3, r2);
              }
            }
          };
        }
        function Pf(t2) {
          return (e2, i2, n2) => {
            const o2 = t2(i2.item, n2.writer);
            if (!o2) {
              return;
            }
            if (!n2.consumable.consume(i2.item, "insert")) {
              return;
            }
            const r2 = n2.mapper.toViewPosition(i2.range.start);
            n2.mapper.bindElements(i2.item, o2);
            n2.writer.insert(r2, o2);
          };
        }
        function Sf(t2) {
          return (e2, i2, n2) => {
            i2.isOpening = true;
            const o2 = t2(i2, n2.writer);
            i2.isOpening = false;
            const r2 = t2(i2, n2.writer);
            if (!o2 || !r2) {
              return;
            }
            const s2 = i2.markerRange;
            if (s2.isCollapsed && !n2.consumable.consume(s2, e2.name)) {
              return;
            }
            for (const t3 of s2) {
              if (!n2.consumable.consume(t3.item, e2.name)) {
                return;
              }
            }
            const a2 = n2.mapper;
            const c2 = n2.writer;
            c2.insert(a2.toViewPosition(s2.start), o2);
            n2.mapper.bindElementToMarker(o2, i2.markerName);
            if (!s2.isCollapsed) {
              c2.insert(a2.toViewPosition(s2.end), r2);
              n2.mapper.bindElementToMarker(r2, i2.markerName);
            }
            e2.stop();
          };
        }
        function Ef() {
          return (t2, e2, i2) => {
            const n2 = i2.mapper.markerNameToElements(e2.markerName);
            if (!n2) {
              return;
            }
            for (const t3 of n2) {
              i2.mapper.unbindElementFromMarkerName(t3, e2.markerName);
              i2.writer.clear(i2.writer.createRangeOn(t3), t3);
            }
            i2.writer.clearClonedElementsGroup(e2.markerName);
            t2.stop();
          };
        }
        function Rf(t2) {
          return (e2, i2, n2) => {
            const o2 = t2(i2.attributeOldValue, i2);
            const r2 = t2(i2.attributeNewValue, i2);
            if (!o2 && !r2) {
              return;
            }
            if (!n2.consumable.consume(i2.item, e2.name)) {
              return;
            }
            const s2 = n2.mapper.toViewElement(i2.item);
            const a2 = n2.writer;
            if (!s2) {
              throw new ss["b"]("conversion-attribute-to-attribute-on-text: Trying to convert text node's attribute with attribute-to-attribute converter.", [i2, n2]);
            }
            if (i2.attributeOldValue !== null && o2) {
              if (o2.key == "class") {
                const t3 = Array.isArray(o2.value) ? o2.value : [o2.value];
                for (const e3 of t3) {
                  a2.removeClass(e3, s2);
                }
              } else if (o2.key == "style") {
                const t3 = Object.keys(o2.value);
                for (const e3 of t3) {
                  a2.removeStyle(e3, s2);
                }
              } else {
                a2.removeAttribute(o2.key, s2);
              }
            }
            if (i2.attributeNewValue !== null && r2) {
              if (r2.key == "class") {
                const t3 = Array.isArray(r2.value) ? r2.value : [r2.value];
                for (const e3 of t3) {
                  a2.addClass(e3, s2);
                }
              } else if (r2.key == "style") {
                const t3 = Object.keys(r2.value);
                for (const e3 of t3) {
                  a2.setStyle(e3, r2.value[e3], s2);
                }
              } else {
                a2.setAttribute(r2.key, r2.value, s2);
              }
            }
          };
        }
        function Of(t2) {
          return (e2, i2, n2) => {
            if (!i2.item) {
              return;
            }
            if (!(i2.item instanceof Xh || i2.item instanceof df) && !i2.item.is("textProxy")) {
              return;
            }
            const o2 = Wf(t2, i2, n2);
            if (!o2) {
              return;
            }
            if (!n2.consumable.consume(i2.item, e2.name)) {
              return;
            }
            const r2 = n2.writer;
            const s2 = yf(r2, o2);
            const a2 = r2.document.selection;
            if (i2.item instanceof Xh || i2.item instanceof df) {
              r2.wrap(a2.getFirstRange(), s2, a2);
            } else {
              const t3 = n2.mapper.toViewRange(i2.range);
              const e3 = r2.wrap(t3, s2);
              for (const t4 of e3.getItems()) {
                if (t4.is("attributeElement") && t4.isSimilar(s2)) {
                  n2.mapper.bindElementToMarker(t4, i2.markerName);
                  break;
                }
              }
            }
          };
        }
        function If(t2) {
          return (e2, i2, n2) => {
            if (!i2.item) {
              return;
            }
            if (!(i2.item instanceof jh)) {
              return;
            }
            const o2 = Wf(t2, i2, n2);
            if (!o2) {
              return;
            }
            if (!n2.consumable.test(i2.item, e2.name)) {
              return;
            }
            const r2 = n2.mapper.toViewElement(i2.item);
            if (r2 && r2.getCustomProperty("addHighlight")) {
              n2.consumable.consume(i2.item, e2.name);
              for (const t3 of $h._createIn(i2.item)) {
                n2.consumable.consume(t3.item, e2.name);
              }
              r2.getCustomProperty("addHighlight")(r2, o2, n2.writer);
              n2.mapper.bindElementToMarker(r2, i2.markerName);
            }
          };
        }
        function Vf(t2) {
          return (e2, i2, n2) => {
            if (i2.markerRange.isCollapsed) {
              return;
            }
            const o2 = Wf(t2, i2, n2);
            if (!o2) {
              return;
            }
            const r2 = yf(n2.writer, o2);
            const s2 = n2.mapper.markerNameToElements(i2.markerName);
            if (!s2) {
              return;
            }
            for (const t3 of s2) {
              n2.mapper.unbindElementFromMarkerName(t3, i2.markerName);
              if (t3.is("attributeElement")) {
                n2.writer.unwrap(n2.writer.createRangeOn(t3), r2);
              } else {
                t3.getCustomProperty("removeHighlight")(t3, o2.id, n2.writer);
              }
            }
            n2.writer.clearClonedElementsGroup(i2.markerName);
            e2.stop();
          };
        }
        function Nf(t2) {
          t2 = wf(t2);
          t2.view = Ff(t2.view, "container");
          return (e2) => {
            e2.on("insert:" + t2.model, Pf(t2.view), {priority: t2.converterPriority || "normal"});
          };
        }
        function Mf(t2) {
          t2 = wf(t2);
          const e2 = t2.model.key ? t2.model.key : t2.model;
          let i2 = "attribute:" + e2;
          if (t2.model.name) {
            i2 += ":" + t2.model.name;
          }
          if (t2.model.values) {
            for (const e3 of t2.model.values) {
              t2.view[e3] = Ff(t2.view[e3], "attribute");
            }
          } else {
            t2.view = Ff(t2.view, "attribute");
          }
          const n2 = jf(t2);
          return (e3) => {
            e3.on(i2, Tf(n2), {priority: t2.converterPriority || "normal"});
          };
        }
        function Bf(t2) {
          t2 = wf(t2);
          const e2 = t2.model.key ? t2.model.key : t2.model;
          let i2 = "attribute:" + e2;
          if (t2.model.name) {
            i2 += ":" + t2.model.name;
          }
          if (t2.model.values) {
            for (const e3 of t2.model.values) {
              t2.view[e3] = Hf(t2.view[e3]);
            }
          } else {
            t2.view = Hf(t2.view);
          }
          const n2 = jf(t2);
          return (e3) => {
            e3.on(i2, Rf(n2), {priority: t2.converterPriority || "normal"});
          };
        }
        function zf(t2) {
          t2 = wf(t2);
          t2.view = Ff(t2.view, "ui");
          return (e2) => {
            e2.on("addMarker:" + t2.model, Sf(t2.view), {priority: t2.converterPriority || "normal"});
            e2.on("removeMarker:" + t2.model, Ef(t2.view), {priority: t2.converterPriority || "normal"});
          };
        }
        function Lf(t2) {
          return (e2) => {
            e2.on("addMarker:" + t2.model, Of(t2.view), {priority: t2.converterPriority || "normal"});
            e2.on("addMarker:" + t2.model, If(t2.view), {priority: t2.converterPriority || "normal"});
            e2.on("removeMarker:" + t2.model, Vf(t2.view), {priority: t2.converterPriority || "normal"});
          };
        }
        function Ff(t2, e2) {
          if (typeof t2 == "function") {
            return t2;
          }
          return (i2, n2) => Df(t2, n2, e2);
        }
        function Df(t2, e2, i2) {
          if (typeof t2 == "string") {
            t2 = {name: t2};
          }
          let n2;
          const o2 = Object.assign({}, t2.attributes);
          if (i2 == "container") {
            n2 = e2.createContainerElement(t2.name, o2);
          } else if (i2 == "attribute") {
            const i3 = {priority: t2.priority || wl.DEFAULT_PRIORITY};
            n2 = e2.createAttributeElement(t2.name, o2, i3);
          } else {
            n2 = e2.createUIElement(t2.name, o2);
          }
          if (t2.styles) {
            const i3 = Object.keys(t2.styles);
            for (const o3 of i3) {
              e2.setStyle(o3, t2.styles[o3], n2);
            }
          }
          if (t2.classes) {
            const i3 = t2.classes;
            if (typeof i3 == "string") {
              e2.addClass(i3, n2);
            } else {
              for (const t3 of i3) {
                e2.addClass(t3, n2);
              }
            }
          }
          return n2;
        }
        function jf(t2) {
          if (t2.model.values) {
            return (e2, i2) => {
              const n2 = t2.view[e2];
              if (n2) {
                return n2(e2, i2);
              }
              return null;
            };
          } else {
            return t2.view;
          }
        }
        function Hf(t2) {
          if (typeof t2 == "string") {
            return (e2) => ({key: t2, value: e2});
          } else if (typeof t2 == "object") {
            if (t2.value) {
              return () => t2;
            } else {
              return (e2) => ({key: t2.key, value: e2});
            }
          } else {
            return t2;
          }
        }
        function Wf(t2, e2, i2) {
          const n2 = typeof t2 == "function" ? t2(e2, i2) : t2;
          if (!n2) {
            return null;
          }
          if (!n2.priority) {
            n2.priority = 10;
          }
          if (!n2.id) {
            n2.id = e2.markerName;
          }
          return n2;
        }
        class qf extends gf {
          elementToElement(t2) {
            return this.add(Kf(t2));
          }
          elementToAttribute(t2) {
            return this.add(Jf(t2));
          }
          attributeToAttribute(t2) {
            return this.add(Yf(t2));
          }
          elementToMarker(t2) {
            return this.add(Qf(t2));
          }
        }
        function Uf() {
          return (t2, e2, i2) => {
            if (!e2.modelRange && i2.consumable.consume(e2.viewItem, {name: true})) {
              const {modelRange: t3, modelCursor: n2} = i2.convertChildren(e2.viewItem, e2.modelCursor);
              e2.modelRange = t3;
              e2.modelCursor = n2;
            }
          };
        }
        function $f() {
          return (t2, e2, i2) => {
            if (i2.schema.checkChild(e2.modelCursor, "$text")) {
              if (i2.consumable.consume(e2.viewItem)) {
                const t3 = i2.writer.createText(e2.viewItem.data);
                i2.writer.insert(t3, e2.modelCursor);
                e2.modelRange = $h._createFromPositionAndShift(e2.modelCursor, t3.offsetSize);
                e2.modelCursor = e2.modelRange.end;
              }
            }
          };
        }
        function Gf(t2, e2) {
          return (i2, n2) => {
            const o2 = n2.newSelection;
            const r2 = new Xh();
            const s2 = [];
            for (const t3 of o2.getRanges()) {
              s2.push(e2.toModelRange(t3));
            }
            r2.setTo(s2, {backward: o2.isBackward});
            if (!r2.isEqual(t2.document.selection)) {
              t2.change((t3) => {
                t3.setSelection(r2);
              });
            }
          };
        }
        function Kf(t2) {
          t2 = wf(t2);
          const e2 = Zf(t2);
          const i2 = Xf(t2.view);
          const n2 = i2 ? "element:" + i2 : "element";
          return (i3) => {
            i3.on(n2, e2, {priority: t2.converterPriority || "normal"});
          };
        }
        function Jf(t2) {
          t2 = wf(t2);
          ig(t2);
          const e2 = ng(t2, false);
          const i2 = Xf(t2.view);
          const n2 = i2 ? "element:" + i2 : "element";
          return (i3) => {
            i3.on(n2, e2, {priority: t2.converterPriority || "low"});
          };
        }
        function Yf(t2) {
          t2 = wf(t2);
          let e2 = null;
          if (typeof t2.view == "string" || t2.view.key) {
            e2 = eg(t2);
          }
          ig(t2, e2);
          const i2 = ng(t2, true);
          return (e3) => {
            e3.on("element", i2, {priority: t2.converterPriority || "low"});
          };
        }
        function Qf(t2) {
          t2 = wf(t2);
          sg(t2);
          return Kf(t2);
        }
        function Xf(t2) {
          if (typeof t2 == "string") {
            return t2;
          }
          if (typeof t2 == "object" && typeof t2.name == "string") {
            return t2.name;
          }
          return null;
        }
        function Zf(t2) {
          const e2 = t2.view ? new Ws(t2.view) : null;
          return (i2, n2, o2) => {
            let r2 = {};
            if (e2) {
              const t3 = e2.match(n2.viewItem);
              if (!t3) {
                return;
              }
              r2 = t3.match;
            }
            r2.name = true;
            const s2 = tg(t2.model, n2.viewItem, o2.writer);
            if (!s2) {
              return;
            }
            if (!o2.consumable.test(n2.viewItem, r2)) {
              return;
            }
            const a2 = o2.splitToAllowedParent(s2, n2.modelCursor);
            if (!a2) {
              return;
            }
            o2.writer.insert(s2, a2.position);
            o2.convertChildren(n2.viewItem, o2.writer.createPositionAt(s2, 0));
            o2.consumable.consume(n2.viewItem, r2);
            const c2 = o2.getSplitParts(s2);
            n2.modelRange = new $h(o2.writer.createPositionBefore(s2), o2.writer.createPositionAfter(c2[c2.length - 1]));
            if (a2.cursorParent) {
              n2.modelCursor = o2.writer.createPositionAt(a2.cursorParent, 0);
            } else {
              n2.modelCursor = n2.modelRange.end;
            }
          };
        }
        function tg(t2, e2, i2) {
          if (t2 instanceof Function) {
            return t2(e2, i2);
          } else {
            return i2.createElement(t2);
          }
        }
        function eg(t2) {
          if (typeof t2.view == "string") {
            t2.view = {key: t2.view};
          }
          const e2 = t2.view.key;
          let i2;
          if (e2 == "class" || e2 == "style") {
            const n2 = e2 == "class" ? "classes" : "styles";
            i2 = {[n2]: t2.view.value};
          } else {
            const n2 = typeof t2.view.value == "undefined" ? /[\s\S]*/ : t2.view.value;
            i2 = {attributes: {[e2]: n2}};
          }
          if (t2.view.name) {
            i2.name = t2.view.name;
          }
          t2.view = i2;
          return e2;
        }
        function ig(t2, e2 = null) {
          const i2 = e2 === null ? true : (t3) => t3.getAttribute(e2);
          const n2 = typeof t2.model != "object" ? t2.model : t2.model.key;
          const o2 = typeof t2.model != "object" || typeof t2.model.value == "undefined" ? i2 : t2.model.value;
          t2.model = {key: n2, value: o2};
        }
        function ng(t2, e2) {
          const i2 = new Ws(t2.view);
          return (n2, o2, r2) => {
            const s2 = i2.match(o2.viewItem);
            if (!s2) {
              return;
            }
            const a2 = t2.model.key;
            const c2 = typeof t2.model.value == "function" ? t2.model.value(o2.viewItem) : t2.model.value;
            if (c2 === null) {
              return;
            }
            if (og(t2.view, o2.viewItem)) {
              s2.match.name = true;
            } else {
              delete s2.match.name;
            }
            if (!r2.consumable.test(o2.viewItem, s2.match)) {
              return;
            }
            if (!o2.modelRange) {
              o2 = Object.assign(o2, r2.convertChildren(o2.viewItem, o2.modelCursor));
            }
            const l2 = rg(o2.modelRange, {key: a2, value: c2}, e2, r2);
            if (l2) {
              r2.consumable.consume(o2.viewItem, s2.match);
            }
          };
        }
        function og(t2, e2) {
          const i2 = typeof t2 == "function" ? t2(e2) : t2;
          if (typeof i2 == "object" && !Xf(i2)) {
            return false;
          }
          return !i2.classes && !i2.attributes && !i2.styles;
        }
        function rg(t2, e2, i2, n2) {
          let o2 = false;
          for (const r2 of Array.from(t2.getItems({shallow: i2}))) {
            if (n2.schema.checkAttribute(r2, e2.key)) {
              n2.writer.setAttribute(e2.key, e2.value, r2);
              o2 = true;
            }
          }
          return o2;
        }
        function sg(t2) {
          const e2 = t2.model;
          t2.model = (t3, i2) => {
            const n2 = typeof e2 == "string" ? e2 : e2(t3);
            return i2.createElement("$marker", {"data-name": n2});
          };
        }
        class ag {
          constructor(t2, e2) {
            this.model = t2;
            this.view = new Bh(e2);
            this.mapper = new Gh();
            this.downcastDispatcher = new Yh({mapper: this.mapper});
            const i2 = this.model.document;
            const n2 = i2.selection;
            const o2 = this.model.markers;
            this.listenTo(this.model, "_beforeChanges", () => {
              this.view._disableRendering(true);
            }, {priority: "highest"});
            this.listenTo(this.model, "_afterChanges", () => {
              this.view._disableRendering(false);
            }, {priority: "lowest"});
            this.listenTo(i2, "change", () => {
              this.view.change((t3) => {
                this.downcastDispatcher.convertChanges(i2.differ, o2, t3);
                this.downcastDispatcher.convertSelection(n2, o2, t3);
              });
            }, {priority: "low"});
            this.listenTo(this.view.document, "selectionChange", Gf(this.model, this.mapper));
            this.downcastDispatcher.on("insert:$text", _f(), {priority: "lowest"});
            this.downcastDispatcher.on("remove", vf(), {priority: "low"});
            this.downcastDispatcher.on("selection", Af(), {priority: "low"});
            this.downcastDispatcher.on("selection", xf(), {priority: "low"});
            this.downcastDispatcher.on("selection", Cf(), {priority: "low"});
            this.view.document.roots.bindTo(this.model.document.roots).using((t3) => {
              if (t3.rootName == "$graveyard") {
                return null;
              }
              const e3 = new cl(this.view.document, t3.name);
              e3.rootName = t3.rootName;
              this.mapper.bindElements(t3, e3);
              return e3;
            });
          }
          destroy() {
            this.view.destroy();
            this.stopListening();
          }
        }
        vs(ag, Jc);
        class cg {
          constructor() {
            this._commands = new Map();
          }
          add(t2, e2) {
            this._commands.set(t2, e2);
          }
          get(t2) {
            return this._commands.get(t2);
          }
          execute(t2, ...e2) {
            const i2 = this.get(t2);
            if (!i2) {
              throw new ss["b"]("commandcollection-command-not-found: Command does not exist.", this, {commandName: t2});
            }
            i2.execute(...e2);
          }
          *names() {
            yield* this._commands.keys();
          }
          *commands() {
            yield* this._commands.values();
          }
          [Symbol.iterator]() {
            return this._commands[Symbol.iterator]();
          }
          destroy() {
            for (const t2 of this.commands()) {
              t2.destroy();
            }
          }
        }
        class lg {
          constructor() {
            this._consumables = new Map();
          }
          add(t2, e2) {
            let i2;
            if (t2.is("text") || t2.is("documentFragment")) {
              this._consumables.set(t2, true);
              return;
            }
            if (!this._consumables.has(t2)) {
              i2 = new dg(t2);
              this._consumables.set(t2, i2);
            } else {
              i2 = this._consumables.get(t2);
            }
            i2.add(e2);
          }
          test(t2, e2) {
            const i2 = this._consumables.get(t2);
            if (i2 === void 0) {
              return null;
            }
            if (t2.is("text") || t2.is("documentFragment")) {
              return i2;
            }
            return i2.test(e2);
          }
          consume(t2, e2) {
            if (this.test(t2, e2)) {
              if (t2.is("text") || t2.is("documentFragment")) {
                this._consumables.set(t2, false);
              } else {
                this._consumables.get(t2).consume(e2);
              }
              return true;
            }
            return false;
          }
          revert(t2, e2) {
            const i2 = this._consumables.get(t2);
            if (i2 !== void 0) {
              if (t2.is("text") || t2.is("documentFragment")) {
                this._consumables.set(t2, true);
              } else {
                i2.revert(e2);
              }
            }
          }
          static consumablesFromElement(t2) {
            const e2 = {element: t2, name: true, attributes: [], classes: [], styles: []};
            const i2 = t2.getAttributeKeys();
            for (const t3 of i2) {
              if (t3 == "style" || t3 == "class") {
                continue;
              }
              e2.attributes.push(t3);
            }
            const n2 = t2.getClassNames();
            for (const t3 of n2) {
              e2.classes.push(t3);
            }
            const o2 = t2.getStyleNames();
            for (const t3 of o2) {
              e2.styles.push(t3);
            }
            return e2;
          }
          static createFrom(t2, e2) {
            if (!e2) {
              e2 = new lg(t2);
            }
            if (t2.is("text")) {
              e2.add(t2);
              return e2;
            }
            if (t2.is("element")) {
              e2.add(t2, lg.consumablesFromElement(t2));
            }
            if (t2.is("documentFragment")) {
              e2.add(t2);
            }
            for (const i2 of t2.getChildren()) {
              e2 = lg.createFrom(i2, e2);
            }
            return e2;
          }
        }
        class dg {
          constructor(t2) {
            this.element = t2;
            this._canConsumeName = null;
            this._consumables = {attributes: new Map(), styles: new Map(), classes: new Map()};
          }
          add(t2) {
            if (t2.name) {
              this._canConsumeName = true;
            }
            for (const e2 in this._consumables) {
              if (e2 in t2) {
                this._add(e2, t2[e2]);
              }
            }
          }
          test(t2) {
            if (t2.name && !this._canConsumeName) {
              return this._canConsumeName;
            }
            for (const e2 in this._consumables) {
              if (e2 in t2) {
                const i2 = this._test(e2, t2[e2]);
                if (i2 !== true) {
                  return i2;
                }
              }
            }
            return true;
          }
          consume(t2) {
            if (t2.name) {
              this._canConsumeName = false;
            }
            for (const e2 in this._consumables) {
              if (e2 in t2) {
                this._consume(e2, t2[e2]);
              }
            }
          }
          revert(t2) {
            if (t2.name) {
              this._canConsumeName = true;
            }
            for (const e2 in this._consumables) {
              if (e2 in t2) {
                this._revert(e2, t2[e2]);
              }
            }
          }
          _add(t2, e2) {
            const i2 = Je(e2) ? e2 : [e2];
            const n2 = this._consumables[t2];
            for (const e3 of i2) {
              if (t2 === "attributes" && (e3 === "class" || e3 === "style")) {
                throw new ss["b"]("viewconsumable-invalid-attribute: Classes and styles should be handled separately.", this);
              }
              n2.set(e3, true);
              if (t2 === "styles") {
                for (const t3 of this.element.document.stylesProcessor.getRelatedStyles(e3)) {
                  n2.set(t3, true);
                }
              }
            }
          }
          _test(t2, e2) {
            const i2 = Je(e2) ? e2 : [e2];
            const n2 = this._consumables[t2];
            for (const e3 of i2) {
              if (t2 === "attributes" && (e3 === "class" || e3 === "style")) {
                const t3 = e3 == "class" ? "classes" : "styles";
                const i3 = this._test(t3, [...this._consumables[t3].keys()]);
                if (i3 !== true) {
                  return i3;
                }
              } else {
                const t3 = n2.get(e3);
                if (t3 === void 0) {
                  return null;
                }
                if (!t3) {
                  return false;
                }
              }
            }
            return true;
          }
          _consume(t2, e2) {
            const i2 = Je(e2) ? e2 : [e2];
            const n2 = this._consumables[t2];
            for (const e3 of i2) {
              if (t2 === "attributes" && (e3 === "class" || e3 === "style")) {
                const t3 = e3 == "class" ? "classes" : "styles";
                this._consume(t3, [...this._consumables[t3].keys()]);
              } else {
                n2.set(e3, false);
                if (t2 == "styles") {
                  for (const t3 of this.element.document.stylesProcessor.getRelatedStyles(e3)) {
                    n2.set(t3, false);
                  }
                }
              }
            }
          }
          _revert(t2, e2) {
            const i2 = Je(e2) ? e2 : [e2];
            const n2 = this._consumables[t2];
            for (const e3 of i2) {
              if (t2 === "attributes" && (e3 === "class" || e3 === "style")) {
                const t3 = e3 == "class" ? "classes" : "styles";
                this._revert(t3, [...this._consumables[t3].keys()]);
              } else {
                const t3 = n2.get(e3);
                if (t3 === false) {
                  n2.set(e3, true);
                }
              }
            }
          }
        }
        class ug {
          constructor() {
            this._sourceDefinitions = {};
            this._attributeProperties = {};
            this.decorate("checkChild");
            this.decorate("checkAttribute");
            this.on("checkAttribute", (t2, e2) => {
              e2[0] = new hg(e2[0]);
            }, {priority: "highest"});
            this.on("checkChild", (t2, e2) => {
              e2[0] = new hg(e2[0]);
              e2[1] = this.getDefinition(e2[1]);
            }, {priority: "highest"});
          }
          register(t2, e2) {
            if (this._sourceDefinitions[t2]) {
              throw new ss["b"]("schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.", this, {itemName: t2});
            }
            this._sourceDefinitions[t2] = [Object.assign({}, e2)];
            this._clearCache();
          }
          extend(t2, e2) {
            if (!this._sourceDefinitions[t2]) {
              throw new ss["b"]("schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.", this, {itemName: t2});
            }
            this._sourceDefinitions[t2].push(Object.assign({}, e2));
            this._clearCache();
          }
          getDefinitions() {
            if (!this._compiledDefinitions) {
              this._compile();
            }
            return this._compiledDefinitions;
          }
          getDefinition(t2) {
            let e2;
            if (typeof t2 == "string") {
              e2 = t2;
            } else if (t2.is && (t2.is("text") || t2.is("textProxy"))) {
              e2 = "$text";
            } else {
              e2 = t2.name;
            }
            return this.getDefinitions()[e2];
          }
          isRegistered(t2) {
            return !!this.getDefinition(t2);
          }
          isBlock(t2) {
            const e2 = this.getDefinition(t2);
            return !!(e2 && e2.isBlock);
          }
          isLimit(t2) {
            const e2 = this.getDefinition(t2);
            if (!e2) {
              return false;
            }
            return !!(e2.isLimit || e2.isObject);
          }
          isObject(t2) {
            const e2 = this.getDefinition(t2);
            return !!(e2 && e2.isObject);
          }
          isInline(t2) {
            const e2 = this.getDefinition(t2);
            return !!(e2 && e2.isInline);
          }
          checkChild(t2, e2) {
            if (!e2) {
              return false;
            }
            return this._checkContextMatch(e2, t2);
          }
          checkAttribute(t2, e2) {
            const i2 = this.getDefinition(t2.last);
            if (!i2) {
              return false;
            }
            return i2.allowAttributes.includes(e2);
          }
          checkMerge(t2, e2 = null) {
            if (t2 instanceof Uh) {
              const e3 = t2.nodeBefore;
              const i2 = t2.nodeAfter;
              if (!(e3 instanceof jh)) {
                throw new ss["b"]("schema-check-merge-no-element-before: The node before the merge position must be an element.", this);
              }
              if (!(i2 instanceof jh)) {
                throw new ss["b"]("schema-check-merge-no-element-after: The node after the merge position must be an element.", this);
              }
              return this.checkMerge(e3, i2);
            }
            for (const i2 of e2.getChildren()) {
              if (!this.checkChild(t2, i2)) {
                return false;
              }
            }
            return true;
          }
          addChildCheck(t2) {
            this.on("checkChild", (e2, [i2, n2]) => {
              if (!n2) {
                return;
              }
              const o2 = t2(i2, n2);
              if (typeof o2 == "boolean") {
                e2.stop();
                e2.return = o2;
              }
            }, {priority: "high"});
          }
          addAttributeCheck(t2) {
            this.on("checkAttribute", (e2, [i2, n2]) => {
              const o2 = t2(i2, n2);
              if (typeof o2 == "boolean") {
                e2.stop();
                e2.return = o2;
              }
            }, {priority: "high"});
          }
          setAttributeProperties(t2, e2) {
            this._attributeProperties[t2] = Object.assign(this.getAttributeProperties(t2), e2);
          }
          getAttributeProperties(t2) {
            return this._attributeProperties[t2] || {};
          }
          getLimitElement(t2) {
            let e2;
            if (t2 instanceof Uh) {
              e2 = t2.parent;
            } else {
              const i2 = t2 instanceof $h ? [t2] : Array.from(t2.getRanges());
              e2 = i2.reduce((t3, e3) => {
                const i3 = e3.getCommonAncestor();
                if (!t3) {
                  return i3;
                }
                return t3.getCommonAncestor(i3, {includeSelf: true});
              }, null);
            }
            while (!this.isLimit(e2)) {
              if (e2.parent) {
                e2 = e2.parent;
              } else {
                break;
              }
            }
            return e2;
          }
          checkAttributeInSelection(t2, e2) {
            if (t2.isCollapsed) {
              const i2 = t2.getFirstPosition();
              const n2 = [...i2.getAncestors(), new Lh("", t2.getAttributes())];
              return this.checkAttribute(n2, e2);
            } else {
              const i2 = t2.getRanges();
              for (const t3 of i2) {
                for (const i3 of t3) {
                  if (this.checkAttribute(i3.item, e2)) {
                    return true;
                  }
                }
              }
            }
            return false;
          }
          *getValidRanges(t2, e2) {
            t2 = Pg(t2);
            for (const i2 of t2) {
              yield* this._getValidRangesForRange(i2, e2);
            }
          }
          getNearestSelectionRange(t2, e2 = "both") {
            if (this.checkChild(t2, "$text")) {
              return new $h(t2);
            }
            let i2, n2;
            const o2 = t2.getAncestors().reverse().find((t3) => this.isLimit(t3)) || t2.root;
            if (e2 == "both" || e2 == "backward") {
              i2 = new Wh({boundaries: $h._createIn(o2), startPosition: t2, direction: "backward"});
            }
            if (e2 == "both" || e2 == "forward") {
              n2 = new Wh({boundaries: $h._createIn(o2), startPosition: t2});
            }
            for (const t3 of Tg(i2, n2)) {
              const e3 = t3.walker == i2 ? "elementEnd" : "elementStart";
              const n3 = t3.value;
              if (n3.type == e3 && this.isObject(n3.item)) {
                return $h._createOn(n3.item);
              }
              if (this.checkChild(n3.nextPosition, "$text")) {
                return new $h(n3.nextPosition);
              }
            }
            return null;
          }
          findAllowedParent(t2, e2) {
            let i2 = t2.parent;
            while (i2) {
              if (this.checkChild(i2, e2)) {
                return i2;
              }
              if (this.isLimit(i2)) {
                return null;
              }
              i2 = i2.parent;
            }
            return null;
          }
          removeDisallowedAttributes(t2, e2) {
            for (const i2 of t2) {
              if (i2.is("text")) {
                Sg(this, i2, e2);
              } else {
                const t3 = $h._createIn(i2);
                const n2 = t3.getPositions();
                for (const t4 of n2) {
                  const i3 = t4.nodeBefore || t4.parent;
                  Sg(this, i3, e2);
                }
              }
            }
          }
          createContext(t2) {
            return new hg(t2);
          }
          _clearCache() {
            this._compiledDefinitions = null;
          }
          _compile() {
            const t2 = {};
            const e2 = this._sourceDefinitions;
            const i2 = Object.keys(e2);
            for (const n2 of i2) {
              t2[n2] = fg(e2[n2], n2);
            }
            for (const e3 of i2) {
              gg(t2, e3);
            }
            for (const e3 of i2) {
              mg(t2, e3);
            }
            for (const e3 of i2) {
              pg(t2, e3);
              bg(t2, e3);
            }
            for (const e3 of i2) {
              wg(t2, e3);
              kg(t2, e3);
            }
            this._compiledDefinitions = t2;
          }
          _checkContextMatch(t2, e2, i2 = e2.length - 1) {
            const n2 = e2.getItem(i2);
            if (t2.allowIn.includes(n2.name)) {
              if (i2 == 0) {
                return true;
              } else {
                const t3 = this.getDefinition(n2);
                return this._checkContextMatch(t3, e2, i2 - 1);
              }
            } else {
              return false;
            }
          }
          *_getValidRangesForRange(t2, e2) {
            let i2 = t2.start;
            let n2 = t2.start;
            for (const o2 of t2.getItems({shallow: true})) {
              if (o2.is("element")) {
                yield* this._getValidRangesForRange($h._createIn(o2), e2);
              }
              if (!this.checkAttribute(o2, e2)) {
                if (!i2.isEqual(n2)) {
                  yield new $h(i2, n2);
                }
                i2 = Uh._createAfter(o2);
              }
              n2 = Uh._createAfter(o2);
            }
            if (!i2.isEqual(n2)) {
              yield new $h(i2, n2);
            }
          }
        }
        vs(ug, Jc);
        class hg {
          constructor(t2) {
            if (t2 instanceof hg) {
              return t2;
            }
            if (typeof t2 == "string") {
              t2 = [t2];
            } else if (!Array.isArray(t2)) {
              t2 = t2.getAncestors({includeSelf: true});
            }
            if (t2[0] && typeof t2[0] != "string" && t2[0].is("documentFragment")) {
              t2.shift();
            }
            this._items = t2.map(Ag);
          }
          get length() {
            return this._items.length;
          }
          get last() {
            return this._items[this._items.length - 1];
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
          push(t2) {
            const e2 = new hg([t2]);
            e2._items = [...this._items, ...e2._items];
            return e2;
          }
          getItem(t2) {
            return this._items[t2];
          }
          *getNames() {
            yield* this._items.map((t2) => t2.name);
          }
          endsWith(t2) {
            return Array.from(this.getNames()).join(" ").endsWith(t2);
          }
          startsWith(t2) {
            return Array.from(this.getNames()).join(" ").startsWith(t2);
          }
        }
        function fg(t2, e2) {
          const i2 = {
            name: e2,
            allowIn: [],
            allowContentOf: [],
            allowWhere: [],
            allowAttributes: [],
            allowAttributesOf: [],
            inheritTypesFrom: []
          };
          _g(t2, i2);
          vg(t2, i2, "allowIn");
          vg(t2, i2, "allowContentOf");
          vg(t2, i2, "allowWhere");
          vg(t2, i2, "allowAttributes");
          vg(t2, i2, "allowAttributesOf");
          vg(t2, i2, "inheritTypesFrom");
          yg(t2, i2);
          return i2;
        }
        function gg(t2, e2) {
          for (const i2 of t2[e2].allowContentOf) {
            if (t2[i2]) {
              const n2 = xg(t2, i2);
              n2.forEach((t3) => {
                t3.allowIn.push(e2);
              });
            }
          }
          delete t2[e2].allowContentOf;
        }
        function mg(t2, e2) {
          for (const i2 of t2[e2].allowWhere) {
            const n2 = t2[i2];
            if (n2) {
              const i3 = n2.allowIn;
              t2[e2].allowIn.push(...i3);
            }
          }
          delete t2[e2].allowWhere;
        }
        function pg(t2, e2) {
          for (const i2 of t2[e2].allowAttributesOf) {
            const n2 = t2[i2];
            if (n2) {
              const i3 = n2.allowAttributes;
              t2[e2].allowAttributes.push(...i3);
            }
          }
          delete t2[e2].allowAttributesOf;
        }
        function bg(t2, e2) {
          const i2 = t2[e2];
          for (const e3 of i2.inheritTypesFrom) {
            const n2 = t2[e3];
            if (n2) {
              const t3 = Object.keys(n2).filter((t4) => t4.startsWith("is"));
              for (const e4 of t3) {
                if (!(e4 in i2)) {
                  i2[e4] = n2[e4];
                }
              }
            }
          }
          delete i2.inheritTypesFrom;
        }
        function wg(t2, e2) {
          const i2 = t2[e2];
          const n2 = i2.allowIn.filter((e3) => t2[e3]);
          i2.allowIn = Array.from(new Set(n2));
        }
        function kg(t2, e2) {
          const i2 = t2[e2];
          i2.allowAttributes = Array.from(new Set(i2.allowAttributes));
        }
        function _g(t2, e2) {
          for (const i2 of t2) {
            const t3 = Object.keys(i2).filter((t4) => t4.startsWith("is"));
            for (const n2 of t3) {
              e2[n2] = i2[n2];
            }
          }
        }
        function vg(t2, e2, i2) {
          for (const n2 of t2) {
            if (typeof n2[i2] == "string") {
              e2[i2].push(n2[i2]);
            } else if (Array.isArray(n2[i2])) {
              e2[i2].push(...n2[i2]);
            }
          }
        }
        function yg(t2, e2) {
          for (const i2 of t2) {
            const t3 = i2.inheritAllFrom;
            if (t3) {
              e2.allowContentOf.push(t3);
              e2.allowWhere.push(t3);
              e2.allowAttributesOf.push(t3);
              e2.inheritTypesFrom.push(t3);
            }
          }
        }
        function xg(t2, e2) {
          const i2 = t2[e2];
          return Cg(t2).filter((t3) => t3.allowIn.includes(i2.name));
        }
        function Cg(t2) {
          return Object.keys(t2).map((e2) => t2[e2]);
        }
        function Ag(t2) {
          if (typeof t2 == "string") {
            return {
              name: t2,
              *getAttributeKeys() {
              },
              getAttribute() {
              }
            };
          } else {
            return {
              name: t2.is("element") ? t2.name : "$text",
              *getAttributeKeys() {
                yield* t2.getAttributeKeys();
              },
              getAttribute(e2) {
                return t2.getAttribute(e2);
              }
            };
          }
        }
        function* Tg(t2, e2) {
          let i2 = false;
          while (!i2) {
            i2 = true;
            if (t2) {
              const e3 = t2.next();
              if (!e3.done) {
                i2 = false;
                yield {walker: t2, value: e3.value};
              }
            }
            if (e2) {
              const t3 = e2.next();
              if (!t3.done) {
                i2 = false;
                yield {walker: e2, value: t3.value};
              }
            }
          }
        }
        function* Pg(t2) {
          for (const e2 of t2) {
            yield* e2.getMinimalFlatRanges();
          }
        }
        function Sg(t2, e2, i2) {
          for (const n2 of e2.getAttributeKeys()) {
            if (!t2.checkAttribute(e2, n2)) {
              i2.removeAttribute(n2, e2);
            }
          }
        }
        class Eg {
          constructor(t2 = {}) {
            this._splitParts = new Map();
            this._modelCursor = null;
            this.conversionApi = Object.assign({}, t2);
            this.conversionApi.convertItem = this._convertItem.bind(this);
            this.conversionApi.convertChildren = this._convertChildren.bind(this);
            this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this);
            this.conversionApi.getSplitParts = this._getSplitParts.bind(this);
          }
          convert(t2, e2, i2 = ["$root"]) {
            this.fire("viewCleanup", t2);
            this._modelCursor = Og(i2, e2);
            this.conversionApi.writer = e2;
            this.conversionApi.consumable = lg.createFrom(t2);
            this.conversionApi.store = {};
            const {modelRange: n2} = this._convertItem(t2, this._modelCursor);
            const o2 = e2.createDocumentFragment();
            if (n2) {
              this._removeEmptyElements();
              for (const t3 of Array.from(this._modelCursor.parent.getChildren())) {
                e2.append(t3, o2);
              }
              o2.markers = Rg(o2, e2);
            }
            this._modelCursor = null;
            this._splitParts.clear();
            this.conversionApi.writer = null;
            this.conversionApi.store = null;
            return o2;
          }
          _convertItem(t2, e2) {
            const i2 = Object.assign({viewItem: t2, modelCursor: e2, modelRange: null});
            if (t2.is("element")) {
              this.fire("element:" + t2.name, i2, this.conversionApi);
            } else if (t2.is("text")) {
              this.fire("text", i2, this.conversionApi);
            } else {
              this.fire("documentFragment", i2, this.conversionApi);
            }
            if (i2.modelRange && !(i2.modelRange instanceof $h)) {
              throw new ss["b"]("view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.", this);
            }
            return {modelRange: i2.modelRange, modelCursor: i2.modelCursor};
          }
          _convertChildren(t2, e2) {
            const i2 = new $h(e2);
            let n2 = e2;
            for (const e3 of Array.from(t2.getChildren())) {
              const t3 = this._convertItem(e3, n2);
              if (t3.modelRange instanceof $h) {
                i2.end = t3.modelRange.end;
                n2 = t3.modelCursor;
              }
            }
            return {modelRange: i2, modelCursor: n2};
          }
          _splitToAllowedParent(t2, e2) {
            const i2 = this.conversionApi.schema.findAllowedParent(e2, t2);
            if (!i2) {
              return null;
            }
            if (i2 === e2.parent) {
              return {position: e2};
            }
            if (this._modelCursor.parent.getAncestors().includes(i2)) {
              return null;
            }
            const n2 = this.conversionApi.writer.split(e2, i2);
            const o2 = [];
            for (const t3 of n2.range.getWalker()) {
              if (t3.type == "elementEnd") {
                o2.push(t3.item);
              } else {
                const e3 = o2.pop();
                const i3 = t3.item;
                this._registerSplitPair(e3, i3);
              }
            }
            return {position: n2.position, cursorParent: n2.range.end.parent};
          }
          _registerSplitPair(t2, e2) {
            if (!this._splitParts.has(t2)) {
              this._splitParts.set(t2, [t2]);
            }
            const i2 = this._splitParts.get(t2);
            this._splitParts.set(e2, i2);
            i2.push(e2);
          }
          _getSplitParts(t2) {
            let e2;
            if (!this._splitParts.has(t2)) {
              e2 = [t2];
            } else {
              e2 = this._splitParts.get(t2);
            }
            return e2;
          }
          _removeEmptyElements() {
            let t2 = false;
            for (const e2 of this._splitParts.keys()) {
              if (e2.isEmpty) {
                this.conversionApi.writer.remove(e2);
                this._splitParts.delete(e2);
                t2 = true;
              }
            }
            if (t2) {
              this._removeEmptyElements();
            }
          }
        }
        vs(Eg, ds);
        function Rg(t2, e2) {
          const i2 = new Set();
          const n2 = new Map();
          const o2 = $h._createIn(t2).getItems();
          for (const t3 of o2) {
            if (t3.name == "$marker") {
              i2.add(t3);
            }
          }
          for (const t3 of i2) {
            const i3 = t3.getAttribute("data-name");
            const o3 = e2.createPositionBefore(t3);
            if (!n2.has(i3)) {
              n2.set(i3, new $h(o3.clone()));
            } else {
              n2.get(i3).end = o3.clone();
            }
            e2.remove(t3);
          }
          return n2;
        }
        function Og(t2, e2) {
          let i2;
          for (const n2 of new hg(t2)) {
            const t3 = {};
            for (const e3 of n2.getAttributeKeys()) {
              t3[e3] = n2.getAttribute(e3);
            }
            const o2 = e2.createElement(n2.name, t3);
            if (i2) {
              e2.append(o2, i2);
            }
            i2 = Uh._createAt(o2, 0);
          }
          return i2;
        }
        class Ig {
          constructor(t2, e2) {
            this.model = t2;
            this.stylesProcessor = e2;
            this.processor;
            this.mapper = new Gh();
            this.downcastDispatcher = new Yh({mapper: this.mapper});
            this.downcastDispatcher.on("insert:$text", _f(), {priority: "lowest"});
            this.upcastDispatcher = new Eg({schema: t2.schema});
            this.viewDocument = new pl(e2);
            this._viewWriter = new $l(this.viewDocument);
            this.upcastDispatcher.on("text", $f(), {priority: "lowest"});
            this.upcastDispatcher.on("element", Uf(), {priority: "lowest"});
            this.upcastDispatcher.on("documentFragment", Uf(), {priority: "lowest"});
            this.decorate("init");
            this.on("init", () => {
              this.fire("ready");
            }, {priority: "lowest"});
          }
          get(t2) {
            const {rootName: e2 = "main", trim: i2 = "empty"} = t2 || {};
            if (!this._checkIfRootsExists([e2])) {
              throw new ss["b"]("datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.", this);
            }
            const n2 = this.model.document.getRoot(e2);
            if (i2 === "empty" && !this.model.hasContent(n2, {ignoreWhitespaces: true})) {
              return "";
            }
            return this.stringify(n2);
          }
          stringify(t2) {
            const e2 = this.toView(t2);
            return this.processor.toData(e2);
          }
          toView(t2) {
            const e2 = this.viewDocument;
            const i2 = this._viewWriter;
            this.mapper.clearBindings();
            const n2 = $h._createIn(t2);
            const o2 = new ql(e2);
            this.mapper.bindElements(t2, o2);
            this.downcastDispatcher.convertInsert(n2, i2);
            if (!t2.is("documentFragment")) {
              const e3 = Vg(t2);
              for (const [t3, n3] of e3) {
                this.downcastDispatcher.convertMarkerAdd(t3, n3, i2);
              }
            }
            return o2;
          }
          init(t2) {
            if (this.model.document.version) {
              throw new ss["b"]("datacontroller-init-document-not-empty: Trying to set initial data to not empty document.", this);
            }
            let e2 = {};
            if (typeof t2 === "string") {
              e2.main = t2;
            } else {
              e2 = t2;
            }
            if (!this._checkIfRootsExists(Object.keys(e2))) {
              throw new ss["b"]("datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.", this);
            }
            this.model.enqueueChange("transparent", (t3) => {
              for (const i2 of Object.keys(e2)) {
                const n2 = this.model.document.getRoot(i2);
                t3.insert(this.parse(e2[i2], n2), n2, 0);
              }
            });
            return Promise.resolve();
          }
          set(t2) {
            let e2 = {};
            if (typeof t2 === "string") {
              e2.main = t2;
            } else {
              e2 = t2;
            }
            if (!this._checkIfRootsExists(Object.keys(e2))) {
              throw new ss["b"]("datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.", this);
            }
            this.model.enqueueChange("transparent", (t3) => {
              t3.setSelection(null);
              t3.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
              for (const i2 of Object.keys(e2)) {
                const n2 = this.model.document.getRoot(i2);
                t3.remove(t3.createRangeIn(n2));
                t3.insert(this.parse(e2[i2], n2), n2, 0);
              }
            });
          }
          parse(t2, e2 = "$root") {
            const i2 = this.processor.toView(t2);
            return this.toModel(i2, e2);
          }
          toModel(t2, e2 = "$root") {
            return this.model.change((i2) => this.upcastDispatcher.convert(t2, i2, e2));
          }
          addStyleProcessorRules(t2) {
            t2(this.stylesProcessor);
          }
          destroy() {
            this.stopListening();
          }
          _checkIfRootsExists(t2) {
            for (const e2 of t2) {
              if (!this.model.document.getRootNames().includes(e2)) {
                return false;
              }
            }
            return true;
          }
        }
        vs(Ig, Jc);
        function Vg(t2) {
          const e2 = [];
          const i2 = t2.root.document;
          if (!i2) {
            return [];
          }
          const n2 = $h._createIn(t2);
          for (const t3 of i2.model.markers) {
            const i3 = n2.getIntersection(t3.getRange());
            if (i3) {
              e2.push([t3.name, i3]);
            }
          }
          return e2;
        }
        class Ng {
          constructor(t2, e2) {
            this._helpers = new Map();
            this._downcast = Array.isArray(t2) ? t2 : [t2];
            this._createConversionHelpers({name: "downcast", dispatchers: this._downcast, isDowncast: true});
            this._upcast = Array.isArray(e2) ? e2 : [e2];
            this._createConversionHelpers({name: "upcast", dispatchers: this._upcast, isDowncast: false});
          }
          addAlias(t2, e2) {
            const i2 = this._downcast.includes(e2);
            const n2 = this._upcast.includes(e2);
            if (!n2 && !i2) {
              throw new ss["b"]("conversion-add-alias-dispatcher-not-registered: Trying to register and alias for a dispatcher that nas not been registered.", this);
            }
            this._createConversionHelpers({name: t2, dispatchers: [e2], isDowncast: i2});
          }
          for(t2) {
            if (!this._helpers.has(t2)) {
              throw new ss["b"]("conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.", this);
            }
            return this._helpers.get(t2);
          }
          elementToElement(t2) {
            this.for("downcast").elementToElement(t2);
            for (const {model: e2, view: i2} of Mg(t2)) {
              this.for("upcast").elementToElement({model: e2, view: i2, converterPriority: t2.converterPriority});
            }
          }
          attributeToElement(t2) {
            this.for("downcast").attributeToElement(t2);
            for (const {model: e2, view: i2} of Mg(t2)) {
              this.for("upcast").elementToAttribute({view: i2, model: e2, converterPriority: t2.converterPriority});
            }
          }
          attributeToAttribute(t2) {
            this.for("downcast").attributeToAttribute(t2);
            for (const {model: e2, view: i2} of Mg(t2)) {
              this.for("upcast").attributeToAttribute({view: i2, model: e2});
            }
          }
          _createConversionHelpers({name: t2, dispatchers: e2, isDowncast: i2}) {
            if (this._helpers.has(t2)) {
              throw new ss["b"]("conversion-group-exists: Trying to register a group name that has already been registered.", this);
            }
            const n2 = i2 ? new kf(e2) : new qf(e2);
            this._helpers.set(t2, n2);
          }
        }
        function* Mg(t2) {
          if (t2.model.values) {
            for (const e2 of t2.model.values) {
              const i2 = {key: t2.model.key, value: e2};
              const n2 = t2.view[e2];
              const o2 = t2.upcastAlso ? t2.upcastAlso[e2] : void 0;
              yield* Bg(i2, n2, o2);
            }
          } else {
            yield* Bg(t2.model, t2.view, t2.upcastAlso);
          }
        }
        function* Bg(t2, e2, i2) {
          yield {model: t2, view: e2};
          if (i2) {
            i2 = Array.isArray(i2) ? i2 : [i2];
            for (const e3 of i2) {
              yield {model: t2, view: e3};
            }
          }
        }
        class zg {
          constructor(t2 = "default") {
            this.operations = [];
            this.type = t2;
          }
          get baseVersion() {
            for (const t2 of this.operations) {
              if (t2.baseVersion !== null) {
                return t2.baseVersion;
              }
            }
            return null;
          }
          addOperation(t2) {
            t2.batch = this;
            this.operations.push(t2);
            return t2;
          }
        }
        class Lg {
          constructor(t2) {
            this.baseVersion = t2;
            this.isDocumentOperation = this.baseVersion !== null;
            this.batch = null;
          }
          _validate() {
          }
          toJSON() {
            const t2 = Object.assign({}, this);
            t2.__className = this.constructor.className;
            delete t2.batch;
            delete t2.isDocumentOperation;
            return t2;
          }
          static get className() {
            return "Operation";
          }
          static fromJSON(t2) {
            return new this(t2.baseVersion);
          }
        }
        class Fg {
          constructor(t2) {
            this.markers = new Map();
            this._children = new Dh();
            if (t2) {
              this._insertChild(0, t2);
            }
          }
          [Symbol.iterator]() {
            return this.getChildren();
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return this.childCount === 0;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          is(t2) {
            return t2 == "documentFragment" || t2 == "model:documentFragment";
          }
          getChild(t2) {
            return this._children.getNode(t2);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t2) {
            return this._children.getNodeIndex(t2);
          }
          getChildStartOffset(t2) {
            return this._children.getNodeStartOffset(t2);
          }
          getPath() {
            return [];
          }
          getNodeByPath(t2) {
            let e2 = this;
            for (const i2 of t2) {
              e2 = e2.getChild(e2.offsetToIndex(i2));
            }
            return e2;
          }
          offsetToIndex(t2) {
            return this._children.offsetToIndex(t2);
          }
          toJSON() {
            const t2 = [];
            for (const e2 of this._children) {
              t2.push(e2.toJSON());
            }
            return t2;
          }
          static fromJSON(t2) {
            const e2 = [];
            for (const i2 of t2) {
              if (i2.name) {
                e2.push(jh.fromJSON(i2));
              } else {
                e2.push(Lh.fromJSON(i2));
              }
            }
            return new Fg(e2);
          }
          _appendChild(t2) {
            this._insertChild(this.childCount, t2);
          }
          _insertChild(t2, e2) {
            const i2 = Dg(e2);
            for (const t3 of i2) {
              if (t3.parent !== null) {
                t3._remove();
              }
              t3.parent = this;
            }
            this._children._insertNodes(t2, i2);
          }
          _removeChildren(t2, e2 = 1) {
            const i2 = this._children._removeNodes(t2, e2);
            for (const t3 of i2) {
              t3.parent = null;
            }
            return i2;
          }
        }
        function Dg(t2) {
          if (typeof t2 == "string") {
            return [new Lh(t2)];
          }
          if (!js(t2)) {
            t2 = [t2];
          }
          return Array.from(t2).map((t3) => {
            if (typeof t3 == "string") {
              return new Lh(t3);
            }
            if (t3 instanceof Fh) {
              return new Lh(t3.data, t3.getAttributes());
            }
            return t3;
          });
        }
        function jg(t2, e2) {
          e2 = Ug(e2);
          const i2 = e2.reduce((t3, e3) => t3 + e3.offsetSize, 0);
          const n2 = t2.parent;
          Gg(t2);
          const o2 = t2.index;
          n2._insertChild(o2, e2);
          $g(n2, o2 + e2.length);
          $g(n2, o2);
          return new $h(t2, t2.getShiftedBy(i2));
        }
        function Hg(t2) {
          if (!t2.isFlat) {
            throw new ss["b"]("operation-utils-remove-range-not-flat: Trying to remove a range which starts and ends in different element.", this);
          }
          const e2 = t2.start.parent;
          Gg(t2.start);
          Gg(t2.end);
          const i2 = e2._removeChildren(t2.start.index, t2.end.index - t2.start.index);
          $g(e2, t2.start.index);
          return i2;
        }
        function Wg(t2, e2) {
          if (!t2.isFlat) {
            throw new ss["b"]("operation-utils-move-range-not-flat: Trying to move a range which starts and ends in different element.", this);
          }
          const i2 = Hg(t2);
          e2 = e2._getTransformedByDeletion(t2.start, t2.end.offset - t2.start.offset);
          return jg(e2, i2);
        }
        function qg(t2, e2, i2) {
          Gg(t2.start);
          Gg(t2.end);
          for (const n2 of t2.getItems({shallow: true})) {
            const t3 = n2.is("textProxy") ? n2.textNode : n2;
            if (i2 !== null) {
              t3._setAttribute(e2, i2);
            } else {
              t3._removeAttribute(e2);
            }
            $g(t3.parent, t3.index);
          }
          $g(t2.end.parent, t2.end.index);
        }
        function Ug(t2) {
          const e2 = [];
          if (!(t2 instanceof Array)) {
            t2 = [t2];
          }
          for (let i2 = 0; i2 < t2.length; i2++) {
            if (typeof t2[i2] == "string") {
              e2.push(new Lh(t2[i2]));
            } else if (t2[i2] instanceof Fh) {
              e2.push(new Lh(t2[i2].data, t2[i2].getAttributes()));
            } else if (t2[i2] instanceof Fg || t2[i2] instanceof Dh) {
              for (const n2 of t2[i2]) {
                e2.push(n2);
              }
            } else if (t2[i2] instanceof zh) {
              e2.push(t2[i2]);
            }
          }
          for (let t3 = 1; t3 < e2.length; t3++) {
            const i2 = e2[t3];
            const n2 = e2[t3 - 1];
            if (i2 instanceof Lh && n2 instanceof Lh && Kg(i2, n2)) {
              e2.splice(t3 - 1, 2, new Lh(n2.data + i2.data, n2.getAttributes()));
              t3--;
            }
          }
          return e2;
        }
        function $g(t2, e2) {
          const i2 = t2.getChild(e2 - 1);
          const n2 = t2.getChild(e2);
          if (i2 && n2 && i2.is("text") && n2.is("text") && Kg(i2, n2)) {
            const o2 = new Lh(i2.data + n2.data, i2.getAttributes());
            t2._removeChildren(e2 - 1, 2);
            t2._insertChild(e2 - 1, o2);
          }
        }
        function Gg(t2) {
          const e2 = t2.textNode;
          const i2 = t2.parent;
          if (e2) {
            const n2 = t2.offset - e2.startOffset;
            const o2 = e2.index;
            i2._removeChildren(o2, 1);
            const r2 = new Lh(e2.data.substr(0, n2), e2.getAttributes());
            const s2 = new Lh(e2.data.substr(n2), e2.getAttributes());
            i2._insertChild(o2, [r2, s2]);
          }
        }
        function Kg(t2, e2) {
          const i2 = t2.getAttributes();
          const n2 = e2.getAttributes();
          for (const t3 of i2) {
            if (t3[1] !== e2.getAttribute(t3[0])) {
              return false;
            }
            n2.next();
          }
          return n2.next().done;
        }
        function Jg(t2, e2) {
          return qu(t2, e2);
        }
        var Yg = Jg;
        class Qg extends Lg {
          constructor(t2, e2, i2, n2, o2) {
            super(o2);
            this.range = t2.clone();
            this.key = e2;
            this.oldValue = i2 === void 0 ? null : i2;
            this.newValue = n2 === void 0 ? null : n2;
          }
          get type() {
            if (this.oldValue === null) {
              return "addAttribute";
            } else if (this.newValue === null) {
              return "removeAttribute";
            } else {
              return "changeAttribute";
            }
          }
          clone() {
            return new Qg(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new Qg(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.range = this.range.toJSON();
            return t2;
          }
          _validate() {
            if (!this.range.isFlat) {
              throw new ss["b"]("attribute-operation-range-not-flat: The range to change is not flat.", this);
            }
            for (const t2 of this.range.getItems({shallow: true})) {
              if (this.oldValue !== null && !Yg(t2.getAttribute(this.key), this.oldValue)) {
                throw new ss["b"]("attribute-operation-wrong-old-value: Changed node has different attribute value than operation's old attribute value.", this, {
                  item: t2,
                  key: this.key,
                  value: this.oldValue
                });
              }
              if (this.oldValue === null && this.newValue !== null && t2.hasAttribute(this.key)) {
                throw new ss["b"]("attribute-operation-attribute-exists: The attribute with given key already exists.", this, {
                  node: t2,
                  key: this.key
                });
              }
            }
          }
          _execute() {
            if (!Yg(this.oldValue, this.newValue)) {
              qg(this.range, this.key, this.newValue);
            }
          }
          static get className() {
            return "AttributeOperation";
          }
          static fromJSON(t2, e2) {
            return new Qg($h.fromJSON(t2.range, e2), t2.key, t2.oldValue, t2.newValue, t2.baseVersion);
          }
        }
        class Xg extends Lg {
          constructor(t2, e2) {
            super(null);
            this.sourcePosition = t2.clone();
            this.howMany = e2;
          }
          get type() {
            return "detach";
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.sourcePosition = this.sourcePosition.toJSON();
            return t2;
          }
          _validate() {
            if (this.sourcePosition.root.document) {
              throw new ss["b"]("detach-operation-on-document-node: Cannot detach document node.", this);
            }
          }
          _execute() {
            Hg($h._createFromPositionAndShift(this.sourcePosition, this.howMany));
          }
          static get className() {
            return "DetachOperation";
          }
        }
        class Zg extends Lg {
          constructor(t2, e2, i2, n2) {
            super(n2);
            this.sourcePosition = t2.clone();
            this.sourcePosition.stickiness = "toNext";
            this.howMany = e2;
            this.targetPosition = i2.clone();
            this.targetPosition.stickiness = "toNone";
          }
          get type() {
            if (this.targetPosition.root.rootName == "$graveyard") {
              return "remove";
            } else if (this.sourcePosition.root.rootName == "$graveyard") {
              return "reinsert";
            }
            return "move";
          }
          clone() {
            return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
          }
          getMovedRangeStart() {
            return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
          }
          getReversed() {
            const t2 = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
            return new this.constructor(this.getMovedRangeStart(), this.howMany, t2, this.baseVersion + 1);
          }
          _validate() {
            const t2 = this.sourcePosition.parent;
            const e2 = this.targetPosition.parent;
            const i2 = this.sourcePosition.offset;
            const n2 = this.targetPosition.offset;
            if (i2 + this.howMany > t2.maxOffset) {
              throw new ss["b"]("move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.", this);
            } else if (t2 === e2 && i2 < n2 && n2 < i2 + this.howMany) {
              throw new ss["b"]("move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.", this);
            } else if (this.sourcePosition.root == this.targetPosition.root) {
              if (Vs(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
                const t3 = this.sourcePosition.path.length - 1;
                if (this.targetPosition.path[t3] >= i2 && this.targetPosition.path[t3] < i2 + this.howMany) {
                  throw new ss["b"]("move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.", this);
                }
              }
            }
          }
          _execute() {
            Wg($h._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.sourcePosition = this.sourcePosition.toJSON();
            t2.targetPosition = this.targetPosition.toJSON();
            return t2;
          }
          static get className() {
            return "MoveOperation";
          }
          static fromJSON(t2, e2) {
            const i2 = Uh.fromJSON(t2.sourcePosition, e2);
            const n2 = Uh.fromJSON(t2.targetPosition, e2);
            return new this(i2, t2.howMany, n2, t2.baseVersion);
          }
        }
        class tm extends Lg {
          constructor(t2, e2, i2) {
            super(i2);
            this.position = t2.clone();
            this.position.stickiness = "toNone";
            this.nodes = new Dh(Ug(e2));
            this.shouldReceiveAttributes = false;
          }
          get type() {
            return "insert";
          }
          get howMany() {
            return this.nodes.maxOffset;
          }
          clone() {
            const t2 = new Dh([...this.nodes].map((t3) => t3._clone(true)));
            const e2 = new tm(this.position, t2, this.baseVersion);
            e2.shouldReceiveAttributes = this.shouldReceiveAttributes;
            return e2;
          }
          getReversed() {
            const t2 = this.position.root.document.graveyard;
            const e2 = new Uh(t2, [0]);
            return new Zg(this.position, this.nodes.maxOffset, e2, this.baseVersion + 1);
          }
          _validate() {
            const t2 = this.position.parent;
            if (!t2 || t2.maxOffset < this.position.offset) {
              throw new ss["b"]("insert-operation-position-invalid: Insertion position is invalid.", this);
            }
          }
          _execute() {
            const t2 = this.nodes;
            this.nodes = new Dh([...t2].map((t3) => t3._clone(true)));
            jg(this.position, t2);
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.position = this.position.toJSON();
            t2.nodes = this.nodes.toJSON();
            return t2;
          }
          static get className() {
            return "InsertOperation";
          }
          static fromJSON(t2, e2) {
            const i2 = [];
            for (const e3 of t2.nodes) {
              if (e3.name) {
                i2.push(jh.fromJSON(e3));
              } else {
                i2.push(Lh.fromJSON(e3));
              }
            }
            const n2 = new tm(Uh.fromJSON(t2.position, e2), i2, t2.baseVersion);
            n2.shouldReceiveAttributes = t2.shouldReceiveAttributes;
            return n2;
          }
        }
        class em extends Lg {
          constructor(t2, e2, i2, n2, o2, r2) {
            super(r2);
            this.name = t2;
            this.oldRange = e2 ? e2.clone() : null;
            this.newRange = i2 ? i2.clone() : null;
            this.affectsData = o2;
            this._markers = n2;
          }
          get type() {
            return "marker";
          }
          clone() {
            return new em(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
          }
          getReversed() {
            return new em(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
          }
          _execute() {
            const t2 = this.newRange ? "_set" : "_remove";
            this._markers[t2](this.name, this.newRange, true, this.affectsData);
          }
          toJSON() {
            const t2 = super.toJSON();
            if (this.oldRange) {
              t2.oldRange = this.oldRange.toJSON();
            }
            if (this.newRange) {
              t2.newRange = this.newRange.toJSON();
            }
            delete t2._markers;
            return t2;
          }
          static get className() {
            return "MarkerOperation";
          }
          static fromJSON(t2, e2) {
            return new em(t2.name, t2.oldRange ? $h.fromJSON(t2.oldRange, e2) : null, t2.newRange ? $h.fromJSON(t2.newRange, e2) : null, e2.model.markers, t2.affectsData, t2.baseVersion);
          }
        }
        class im extends Lg {
          constructor(t2, e2, i2, n2) {
            super(n2);
            this.position = t2;
            this.position.stickiness = "toNext";
            this.oldName = e2;
            this.newName = i2;
          }
          get type() {
            return "rename";
          }
          clone() {
            return new im(this.position.clone(), this.oldName, this.newName, this.baseVersion);
          }
          getReversed() {
            return new im(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
          }
          _validate() {
            const t2 = this.position.nodeAfter;
            if (!(t2 instanceof jh)) {
              throw new ss["b"]("rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.", this);
            } else if (t2.name !== this.oldName) {
              throw new ss["b"]("rename-operation-wrong-name: Element to change has different name than operation's old name.", this);
            }
          }
          _execute() {
            const t2 = this.position.nodeAfter;
            t2.name = this.newName;
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.position = this.position.toJSON();
            return t2;
          }
          static get className() {
            return "RenameOperation";
          }
          static fromJSON(t2, e2) {
            return new im(Uh.fromJSON(t2.position, e2), t2.oldName, t2.newName, t2.baseVersion);
          }
        }
        class nm extends Lg {
          constructor(t2, e2, i2, n2, o2) {
            super(o2);
            this.root = t2;
            this.key = e2;
            this.oldValue = i2;
            this.newValue = n2;
          }
          get type() {
            if (this.oldValue === null) {
              return "addRootAttribute";
            } else if (this.newValue === null) {
              return "removeRootAttribute";
            } else {
              return "changeRootAttribute";
            }
          }
          clone() {
            return new nm(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new nm(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          _validate() {
            if (this.root != this.root.root || this.root.is("documentFragment")) {
              throw new ss["b"]("rootattribute-operation-not-a-root: The element to change is not a root element.", this, {
                root: this.root,
                key: this.key
              });
            }
            if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
              throw new ss["b"]("rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation's old attribute value.", this, {
                root: this.root,
                key: this.key
              });
            }
            if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
              throw new ss["b"]("rootattribute-operation-attribute-exists: The attribute with given key already exists.", this, {
                root: this.root,
                key: this.key
              });
            }
          }
          _execute() {
            if (this.newValue !== null) {
              this.root._setAttribute(this.key, this.newValue);
            } else {
              this.root._removeAttribute(this.key);
            }
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.root = this.root.toJSON();
            return t2;
          }
          static get className() {
            return "RootAttributeOperation";
          }
          static fromJSON(t2, e2) {
            if (!e2.getRoot(t2.root)) {
              throw new ss["b"]("rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.", this, {rootName: t2.root});
            }
            return new nm(e2.getRoot(t2.root), t2.key, t2.oldValue, t2.newValue, t2.baseVersion);
          }
        }
        class om extends Lg {
          constructor(t2, e2, i2, n2, o2) {
            super(o2);
            this.sourcePosition = t2.clone();
            this.sourcePosition.stickiness = "toPrevious";
            this.howMany = e2;
            this.targetPosition = i2.clone();
            this.targetPosition.stickiness = "toNext";
            this.graveyardPosition = n2.clone();
          }
          get type() {
            return "merge";
          }
          get deletionPosition() {
            return new Uh(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
          }
          get movedRange() {
            const t2 = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new $h(this.sourcePosition, t2);
          }
          clone() {
            return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
          }
          getReversed() {
            const t2 = this.targetPosition._getTransformedByMergeOperation(this);
            const e2 = this.sourcePosition.path.slice(0, -1);
            const i2 = new Uh(this.sourcePosition.root, e2)._getTransformedByMergeOperation(this);
            const n2 = new rm(t2, this.howMany, this.graveyardPosition, this.baseVersion + 1);
            n2.insertionPosition = i2;
            return n2;
          }
          _validate() {
            const t2 = this.sourcePosition.parent;
            const e2 = this.targetPosition.parent;
            if (!t2.parent) {
              throw new ss["b"]("merge-operation-source-position-invalid: Merge source position is invalid.", this);
            } else if (!e2.parent) {
              throw new ss["b"]("merge-operation-target-position-invalid: Merge target position is invalid.", this);
            } else if (this.howMany != t2.maxOffset) {
              throw new ss["b"]("merge-operation-how-many-invalid: Merge operation specifies wrong number of nodes to move.", this);
            }
          }
          _execute() {
            const t2 = this.sourcePosition.parent;
            const e2 = $h._createIn(t2);
            Wg(e2, this.targetPosition);
            Wg($h._createOn(t2), this.graveyardPosition);
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.sourcePosition = t2.sourcePosition.toJSON();
            t2.targetPosition = t2.targetPosition.toJSON();
            t2.graveyardPosition = t2.graveyardPosition.toJSON();
            return t2;
          }
          static get className() {
            return "MergeOperation";
          }
          static fromJSON(t2, e2) {
            const i2 = Uh.fromJSON(t2.sourcePosition, e2);
            const n2 = Uh.fromJSON(t2.targetPosition, e2);
            const o2 = Uh.fromJSON(t2.graveyardPosition, e2);
            return new this(i2, t2.howMany, n2, o2, t2.baseVersion);
          }
        }
        class rm extends Lg {
          constructor(t2, e2, i2, n2) {
            super(n2);
            this.splitPosition = t2.clone();
            this.splitPosition.stickiness = "toNext";
            this.howMany = e2;
            this.insertionPosition = rm.getInsertionPosition(t2);
            this.insertionPosition.stickiness = "toNone";
            this.graveyardPosition = i2 ? i2.clone() : null;
            if (this.graveyardPosition) {
              this.graveyardPosition.stickiness = "toNext";
            }
          }
          get type() {
            return "split";
          }
          get moveTargetPosition() {
            const t2 = this.insertionPosition.path.slice();
            t2.push(0);
            return new Uh(this.insertionPosition.root, t2);
          }
          get movedRange() {
            const t2 = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new $h(this.splitPosition, t2);
          }
          clone() {
            const t2 = new this.constructor(this.splitPosition, this.howMany, this.graveyardPosition, this.baseVersion);
            t2.insertionPosition = this.insertionPosition;
            return t2;
          }
          getReversed() {
            const t2 = this.splitPosition.root.document.graveyard;
            const e2 = new Uh(t2, [0]);
            return new om(this.moveTargetPosition, this.howMany, this.splitPosition, e2, this.baseVersion + 1);
          }
          _validate() {
            const t2 = this.splitPosition.parent;
            const e2 = this.splitPosition.offset;
            if (!t2 || t2.maxOffset < e2) {
              throw new ss["b"]("split-operation-position-invalid: Split position is invalid.", this);
            } else if (!t2.parent) {
              throw new ss["b"]("split-operation-split-in-root: Cannot split root element.", this);
            } else if (this.howMany != t2.maxOffset - this.splitPosition.offset) {
              throw new ss["b"]("split-operation-how-many-invalid: Split operation specifies wrong number of nodes to move.", this);
            } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
              throw new ss["b"]("split-operation-graveyard-position-invalid: Graveyard position invalid.", this);
            }
          }
          _execute() {
            const t2 = this.splitPosition.parent;
            if (this.graveyardPosition) {
              Wg($h._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
            } else {
              const e3 = t2._clone();
              jg(this.insertionPosition, e3);
            }
            const e2 = new $h(Uh._createAt(t2, this.splitPosition.offset), Uh._createAt(t2, t2.maxOffset));
            Wg(e2, this.moveTargetPosition);
          }
          toJSON() {
            const t2 = super.toJSON();
            t2.splitPosition = this.splitPosition.toJSON();
            t2.insertionPosition = this.insertionPosition.toJSON();
            if (this.graveyardPosition) {
              t2.graveyardPosition = this.graveyardPosition.toJSON();
            }
            return t2;
          }
          static get className() {
            return "SplitOperation";
          }
          static getInsertionPosition(t2) {
            const e2 = t2.path.slice(0, -1);
            e2[e2.length - 1]++;
            return new Uh(t2.root, e2);
          }
          static fromJSON(t2, e2) {
            const i2 = Uh.fromJSON(t2.splitPosition, e2);
            const n2 = Uh.fromJSON(t2.insertionPosition, e2);
            const o2 = t2.graveyardPosition ? Uh.fromJSON(t2.graveyardPosition, e2) : null;
            const r2 = new this(i2, t2.howMany, o2, t2.baseVersion);
            r2.insertionPosition = n2;
            return r2;
          }
        }
        class sm extends jh {
          constructor(t2, e2, i2 = "main") {
            super(e2);
            this._document = t2;
            this.rootName = i2;
          }
          get document() {
            return this._document;
          }
          is(t2, e2) {
            const i2 = t2.replace("model:", "");
            if (!e2) {
              return i2 == "rootElement" || super.is(t2);
            } else {
              return i2 == "rootElement" && e2 == this.name || super.is(t2, e2);
            }
          }
          toJSON() {
            return this.rootName;
          }
        }
        class am {
          constructor(t2, e2) {
            this.model = t2;
            this.batch = e2;
          }
          createText(t2, e2) {
            return new Lh(t2, e2);
          }
          createElement(t2, e2) {
            return new jh(t2, e2);
          }
          createDocumentFragment() {
            return new Fg();
          }
          insert(t2, e2, i2 = 0) {
            this._assertWriterUsedCorrectly();
            if (t2 instanceof Lh && t2.data == "") {
              return;
            }
            const n2 = Uh._createAt(e2, i2);
            if (t2.parent) {
              if (hm(t2.root, n2.root)) {
                this.move($h._createOn(t2), n2);
                return;
              } else {
                if (t2.root.document) {
                  throw new ss["b"]("model-writer-insert-forbidden-move: Cannot move a node from a document to a different tree. It is forbidden to move a node that was already in a document outside of it.", this);
                } else {
                  this.remove(t2);
                }
              }
            }
            const o2 = n2.root.document ? n2.root.document.version : null;
            const r2 = new tm(n2, t2, o2);
            if (t2 instanceof Lh) {
              r2.shouldReceiveAttributes = true;
            }
            this.batch.addOperation(r2);
            this.model.applyOperation(r2);
            if (t2 instanceof Fg) {
              for (const [e3, i3] of t2.markers) {
                const t3 = Uh._createAt(i3.root, 0);
                const o3 = new $h(i3.start._getCombined(t3, n2), i3.end._getCombined(t3, n2));
                const r3 = {range: o3, usingOperation: true, affectsData: true};
                if (this.model.markers.has(e3)) {
                  this.updateMarker(e3, r3);
                } else {
                  this.addMarker(e3, r3);
                }
              }
            }
          }
          insertText(t2, e2, i2, n2) {
            if (e2 instanceof Fg || e2 instanceof jh || e2 instanceof Uh) {
              this.insert(this.createText(t2), e2, i2);
            } else {
              this.insert(this.createText(t2, e2), i2, n2);
            }
          }
          insertElement(t2, e2, i2, n2) {
            if (e2 instanceof Fg || e2 instanceof jh || e2 instanceof Uh) {
              this.insert(this.createElement(t2), e2, i2);
            } else {
              this.insert(this.createElement(t2, e2), i2, n2);
            }
          }
          append(t2, e2) {
            this.insert(t2, e2, "end");
          }
          appendText(t2, e2, i2) {
            if (e2 instanceof Fg || e2 instanceof jh) {
              this.insert(this.createText(t2), e2, "end");
            } else {
              this.insert(this.createText(t2, e2), i2, "end");
            }
          }
          appendElement(t2, e2, i2) {
            if (e2 instanceof Fg || e2 instanceof jh) {
              this.insert(this.createElement(t2), e2, "end");
            } else {
              this.insert(this.createElement(t2, e2), i2, "end");
            }
          }
          setAttribute(t2, e2, i2) {
            this._assertWriterUsedCorrectly();
            if (i2 instanceof $h) {
              const n2 = i2.getMinimalFlatRanges();
              for (const i3 of n2) {
                cm(this, t2, e2, i3);
              }
            } else {
              lm(this, t2, e2, i2);
            }
          }
          setAttributes(t2, e2) {
            for (const [i2, n2] of Hs(t2)) {
              this.setAttribute(i2, n2, e2);
            }
          }
          removeAttribute(t2, e2) {
            this._assertWriterUsedCorrectly();
            if (e2 instanceof $h) {
              const i2 = e2.getMinimalFlatRanges();
              for (const e3 of i2) {
                cm(this, t2, null, e3);
              }
            } else {
              lm(this, t2, null, e2);
            }
          }
          clearAttributes(t2) {
            this._assertWriterUsedCorrectly();
            const e2 = (t3) => {
              for (const e3 of t3.getAttributeKeys()) {
                this.removeAttribute(e3, t3);
              }
            };
            if (!(t2 instanceof $h)) {
              e2(t2);
            } else {
              for (const i2 of t2.getItems()) {
                e2(i2);
              }
            }
          }
          move(t2, e2, i2) {
            this._assertWriterUsedCorrectly();
            if (!(t2 instanceof $h)) {
              throw new ss["b"]("writer-move-invalid-range: Invalid range to move.", this);
            }
            if (!t2.isFlat) {
              throw new ss["b"]("writer-move-range-not-flat: Range to move is not flat.", this);
            }
            const n2 = Uh._createAt(e2, i2);
            if (n2.isEqual(t2.start)) {
              return;
            }
            this._addOperationForAffectedMarkers("move", t2);
            if (!hm(t2.root, n2.root)) {
              throw new ss["b"]("writer-move-different-document: Range is going to be moved between different documents.", this);
            }
            const o2 = t2.root.document ? t2.root.document.version : null;
            const r2 = new Zg(t2.start, t2.end.offset - t2.start.offset, n2, o2);
            this.batch.addOperation(r2);
            this.model.applyOperation(r2);
          }
          remove(t2) {
            this._assertWriterUsedCorrectly();
            const e2 = t2 instanceof $h ? t2 : $h._createOn(t2);
            const i2 = e2.getMinimalFlatRanges().reverse();
            for (const t3 of i2) {
              this._addOperationForAffectedMarkers("move", t3);
              um(t3.start, t3.end.offset - t3.start.offset, this.batch, this.model);
            }
          }
          merge(t2) {
            this._assertWriterUsedCorrectly();
            const e2 = t2.nodeBefore;
            const i2 = t2.nodeAfter;
            this._addOperationForAffectedMarkers("merge", t2);
            if (!(e2 instanceof jh)) {
              throw new ss["b"]("writer-merge-no-element-before: Node before merge position must be an element.", this);
            }
            if (!(i2 instanceof jh)) {
              throw new ss["b"]("writer-merge-no-element-after: Node after merge position must be an element.", this);
            }
            if (!t2.root.document) {
              this._mergeDetached(t2);
            } else {
              this._merge(t2);
            }
          }
          createPositionFromPath(t2, e2, i2) {
            return this.model.createPositionFromPath(t2, e2, i2);
          }
          createPositionAt(t2, e2) {
            return this.model.createPositionAt(t2, e2);
          }
          createPositionAfter(t2) {
            return this.model.createPositionAfter(t2);
          }
          createPositionBefore(t2) {
            return this.model.createPositionBefore(t2);
          }
          createRange(t2, e2) {
            return this.model.createRange(t2, e2);
          }
          createRangeIn(t2) {
            return this.model.createRangeIn(t2);
          }
          createRangeOn(t2) {
            return this.model.createRangeOn(t2);
          }
          createSelection(t2, e2, i2) {
            return this.model.createSelection(t2, e2, i2);
          }
          _mergeDetached(t2) {
            const e2 = t2.nodeBefore;
            const i2 = t2.nodeAfter;
            this.move($h._createIn(i2), Uh._createAt(e2, "end"));
            this.remove(i2);
          }
          _merge(t2) {
            const e2 = Uh._createAt(t2.nodeBefore, "end");
            const i2 = Uh._createAt(t2.nodeAfter, 0);
            const n2 = t2.root.document.graveyard;
            const o2 = new Uh(n2, [0]);
            const r2 = t2.root.document.version;
            const s2 = new om(i2, t2.nodeAfter.maxOffset, e2, o2, r2);
            this.batch.addOperation(s2);
            this.model.applyOperation(s2);
          }
          rename(t2, e2) {
            this._assertWriterUsedCorrectly();
            if (!(t2 instanceof jh)) {
              throw new ss["b"]("writer-rename-not-element-instance: Trying to rename an object which is not an instance of Element.", this);
            }
            const i2 = t2.root.document ? t2.root.document.version : null;
            const n2 = new im(Uh._createBefore(t2), t2.name, e2, i2);
            this.batch.addOperation(n2);
            this.model.applyOperation(n2);
          }
          split(t2, e2) {
            this._assertWriterUsedCorrectly();
            let i2 = t2.parent;
            if (!i2.parent) {
              throw new ss["b"]("writer-split-element-no-parent: Element with no parent can not be split.", this);
            }
            if (!e2) {
              e2 = i2.parent;
            }
            if (!t2.parent.getAncestors({includeSelf: true}).includes(e2)) {
              throw new ss["b"]("writer-split-invalid-limit-element: Limit element is not a position ancestor.", this);
            }
            let n2, o2;
            do {
              const e3 = i2.root.document ? i2.root.document.version : null;
              const r2 = i2.maxOffset - t2.offset;
              const s2 = new rm(t2, r2, null, e3);
              this.batch.addOperation(s2);
              this.model.applyOperation(s2);
              if (!n2 && !o2) {
                n2 = i2;
                o2 = t2.parent.nextSibling;
              }
              t2 = this.createPositionAfter(t2.parent);
              i2 = t2.parent;
            } while (i2 !== e2);
            return {position: t2, range: new $h(Uh._createAt(n2, "end"), Uh._createAt(o2, 0))};
          }
          wrap(t2, e2) {
            this._assertWriterUsedCorrectly();
            if (!t2.isFlat) {
              throw new ss["b"]("writer-wrap-range-not-flat: Range to wrap is not flat.", this);
            }
            const i2 = e2 instanceof jh ? e2 : new jh(e2);
            if (i2.childCount > 0) {
              throw new ss["b"]("writer-wrap-element-not-empty: Element to wrap with is not empty.", this);
            }
            if (i2.parent !== null) {
              throw new ss["b"]("writer-wrap-element-attached: Element to wrap with is already attached to tree model.", this);
            }
            this.insert(i2, t2.start);
            const n2 = new $h(t2.start.getShiftedBy(1), t2.end.getShiftedBy(1));
            this.move(n2, Uh._createAt(i2, 0));
          }
          unwrap(t2) {
            this._assertWriterUsedCorrectly();
            if (t2.parent === null) {
              throw new ss["b"]("writer-unwrap-element-no-parent: Trying to unwrap an element which has no parent.", this);
            }
            this.move($h._createIn(t2), this.createPositionAfter(t2));
            this.remove(t2);
          }
          addMarker(t2, e2) {
            this._assertWriterUsedCorrectly();
            if (!e2 || typeof e2.usingOperation != "boolean") {
              throw new ss["b"]("writer-addMarker-no-usingOperation: The options.usingOperation parameter is required when adding a new marker.", this);
            }
            const i2 = e2.usingOperation;
            const n2 = e2.range;
            const o2 = e2.affectsData === void 0 ? false : e2.affectsData;
            if (this.model.markers.has(t2)) {
              throw new ss["b"]("writer-addMarker-marker-exists: Marker with provided name already exists.", this);
            }
            if (!n2) {
              throw new ss["b"]("writer-addMarker-no-range: Range parameter is required when adding a new marker.", this);
            }
            if (!i2) {
              return this.model.markers._set(t2, n2, i2, o2);
            }
            dm(this, t2, null, n2, o2);
            return this.model.markers.get(t2);
          }
          updateMarker(t2, e2) {
            this._assertWriterUsedCorrectly();
            const i2 = typeof t2 == "string" ? t2 : t2.name;
            const n2 = this.model.markers.get(i2);
            if (!n2) {
              throw new ss["b"]("writer-updateMarker-marker-not-exists: Marker with provided name does not exists.", this);
            }
            if (!e2) {
              this.model.markers._refresh(n2);
              return;
            }
            const o2 = typeof e2.usingOperation == "boolean";
            const r2 = typeof e2.affectsData == "boolean";
            const s2 = r2 ? e2.affectsData : n2.affectsData;
            if (!o2 && !e2.range && !r2) {
              throw new ss["b"]("writer-updateMarker-wrong-options: One of the options is required - provide range, usingOperations or affectsData.", this);
            }
            const a2 = n2.getRange();
            const c2 = e2.range ? e2.range : a2;
            if (o2 && e2.usingOperation !== n2.managedUsingOperations) {
              if (e2.usingOperation) {
                dm(this, i2, null, c2, s2);
              } else {
                dm(this, i2, a2, null, s2);
                this.model.markers._set(i2, c2, void 0, s2);
              }
              return;
            }
            if (n2.managedUsingOperations) {
              dm(this, i2, a2, c2, s2);
            } else {
              this.model.markers._set(i2, c2, void 0, s2);
            }
          }
          removeMarker(t2) {
            this._assertWriterUsedCorrectly();
            const e2 = typeof t2 == "string" ? t2 : t2.name;
            if (!this.model.markers.has(e2)) {
              throw new ss["b"]("writer-removeMarker-no-marker: Trying to remove marker which does not exist.", this);
            }
            const i2 = this.model.markers.get(e2);
            if (!i2.managedUsingOperations) {
              this.model.markers._remove(e2);
              return;
            }
            const n2 = i2.getRange();
            dm(this, e2, n2, null, i2.affectsData);
          }
          setSelection(t2, e2, i2) {
            this._assertWriterUsedCorrectly();
            this.model.document.selection._setTo(t2, e2, i2);
          }
          setSelectionFocus(t2, e2) {
            this._assertWriterUsedCorrectly();
            this.model.document.selection._setFocus(t2, e2);
          }
          setSelectionAttribute(t2, e2) {
            this._assertWriterUsedCorrectly();
            if (typeof t2 === "string") {
              this._setSelectionAttribute(t2, e2);
            } else {
              for (const [e3, i2] of Hs(t2)) {
                this._setSelectionAttribute(e3, i2);
              }
            }
          }
          removeSelectionAttribute(t2) {
            this._assertWriterUsedCorrectly();
            if (typeof t2 === "string") {
              this._removeSelectionAttribute(t2);
            } else {
              for (const e2 of t2) {
                this._removeSelectionAttribute(e2);
              }
            }
          }
          overrideSelectionGravity() {
            return this.model.document.selection._overrideGravity();
          }
          restoreSelectionGravity(t2) {
            this.model.document.selection._restoreGravity(t2);
          }
          _setSelectionAttribute(t2, e2) {
            const i2 = this.model.document.selection;
            if (i2.isCollapsed && i2.anchor.parent.isEmpty) {
              const n2 = df._getStoreAttributeKey(t2);
              this.setAttribute(n2, e2, i2.anchor.parent);
            }
            i2._setAttribute(t2, e2);
          }
          _removeSelectionAttribute(t2) {
            const e2 = this.model.document.selection;
            if (e2.isCollapsed && e2.anchor.parent.isEmpty) {
              const i2 = df._getStoreAttributeKey(t2);
              this.removeAttribute(i2, e2.anchor.parent);
            }
            e2._removeAttribute(t2);
          }
          _assertWriterUsedCorrectly() {
            if (this.model._currentWriter !== this) {
              throw new ss["b"]("writer-incorrect-use: Trying to use a writer outside the change() block.", this);
            }
          }
          _addOperationForAffectedMarkers(t2, e2) {
            for (const i2 of this.model.markers) {
              if (!i2.managedUsingOperations) {
                continue;
              }
              const n2 = i2.getRange();
              let o2 = false;
              if (t2 == "move") {
                o2 = e2.containsPosition(n2.start) || e2.start.isEqual(n2.start) || e2.containsPosition(n2.end) || e2.end.isEqual(n2.end);
              } else {
                const t3 = e2.nodeBefore;
                const i3 = e2.nodeAfter;
                const r2 = n2.start.parent == t3 && n2.start.isAtEnd;
                const s2 = n2.end.parent == i3 && n2.end.offset == 0;
                const a2 = n2.end.nodeAfter == i3;
                const c2 = n2.start.nodeAfter == i3;
                o2 = r2 || s2 || a2 || c2;
              }
              if (o2) {
                this.updateMarker(i2.name, {range: n2});
              }
            }
          }
        }
        function cm(t2, e2, i2, n2) {
          const o2 = t2.model;
          const r2 = o2.document;
          let s2 = n2.start;
          let a2;
          let c2;
          let l2;
          for (const t3 of n2.getWalker({shallow: true})) {
            l2 = t3.item.getAttribute(e2);
            if (a2 && c2 != l2) {
              if (c2 != i2) {
                d2();
              }
              s2 = a2;
            }
            a2 = t3.nextPosition;
            c2 = l2;
          }
          if (a2 instanceof Uh && a2 != s2 && c2 != i2) {
            d2();
          }
          function d2() {
            const n3 = new $h(s2, a2);
            const l3 = n3.root.document ? r2.version : null;
            const d3 = new Qg(n3, e2, c2, i2, l3);
            t2.batch.addOperation(d3);
            o2.applyOperation(d3);
          }
        }
        function lm(t2, e2, i2, n2) {
          const o2 = t2.model;
          const r2 = o2.document;
          const s2 = n2.getAttribute(e2);
          let a2, c2;
          if (s2 != i2) {
            const l2 = n2.root === n2;
            if (l2) {
              const t3 = n2.document ? r2.version : null;
              c2 = new nm(n2, e2, s2, i2, t3);
            } else {
              a2 = new $h(Uh._createBefore(n2), t2.createPositionAfter(n2));
              const o3 = a2.root.document ? r2.version : null;
              c2 = new Qg(a2, e2, s2, i2, o3);
            }
            t2.batch.addOperation(c2);
            o2.applyOperation(c2);
          }
        }
        function dm(t2, e2, i2, n2, o2) {
          const r2 = t2.model;
          const s2 = r2.document;
          const a2 = new em(e2, i2, n2, r2.markers, o2, s2.version);
          t2.batch.addOperation(a2);
          r2.applyOperation(a2);
        }
        function um(t2, e2, i2, n2) {
          let o2;
          if (t2.root.document) {
            const i3 = n2.document;
            const r2 = new Uh(i3.graveyard, [0]);
            o2 = new Zg(t2, e2, r2, i3.version);
          } else {
            o2 = new Xg(t2, e2);
          }
          i2.addOperation(o2);
          n2.applyOperation(o2);
        }
        function hm(t2, e2) {
          if (t2 === e2) {
            return true;
          }
          if (t2 instanceof sm && e2 instanceof sm) {
            return true;
          }
          return false;
        }
        class fm {
          constructor(t2) {
            this._markerCollection = t2;
            this._changesInElement = new Map();
            this._elementSnapshots = new Map();
            this._changedMarkers = new Map();
            this._changeCount = 0;
            this._cachedChanges = null;
            this._cachedChangesWithGraveyard = null;
          }
          get isEmpty() {
            return this._changesInElement.size == 0 && this._changedMarkers.size == 0;
          }
          refreshItem(t2) {
            if (this._isInInsertedElement(t2.parent)) {
              return;
            }
            this._markRemove(t2.parent, t2.startOffset, t2.offsetSize);
            this._markInsert(t2.parent, t2.startOffset, t2.offsetSize);
            const e2 = $h._createOn(t2);
            for (const t3 of this._markerCollection.getMarkersIntersectingRange(e2)) {
              const e3 = t3.getRange();
              this.bufferMarkerChange(t3.name, e3, e3, t3.affectsData);
            }
            this._cachedChanges = null;
          }
          bufferOperation(t2) {
            switch (t2.type) {
              case "insert": {
                if (this._isInInsertedElement(t2.position.parent)) {
                  return;
                }
                this._markInsert(t2.position.parent, t2.position.offset, t2.nodes.maxOffset);
                break;
              }
              case "addAttribute":
              case "removeAttribute":
              case "changeAttribute": {
                for (const e2 of t2.range.getItems({shallow: true})) {
                  if (this._isInInsertedElement(e2.parent)) {
                    continue;
                  }
                  this._markAttribute(e2);
                }
                break;
              }
              case "remove":
              case "move":
              case "reinsert": {
                if (t2.sourcePosition.isEqual(t2.targetPosition) || t2.sourcePosition.getShiftedBy(t2.howMany).isEqual(t2.targetPosition)) {
                  return;
                }
                const e2 = this._isInInsertedElement(t2.sourcePosition.parent);
                const i2 = this._isInInsertedElement(t2.targetPosition.parent);
                if (!e2) {
                  this._markRemove(t2.sourcePosition.parent, t2.sourcePosition.offset, t2.howMany);
                }
                if (!i2) {
                  this._markInsert(t2.targetPosition.parent, t2.getMovedRangeStart().offset, t2.howMany);
                }
                break;
              }
              case "rename": {
                if (this._isInInsertedElement(t2.position.parent)) {
                  return;
                }
                this._markRemove(t2.position.parent, t2.position.offset, 1);
                this._markInsert(t2.position.parent, t2.position.offset, 1);
                const e2 = $h._createFromPositionAndShift(t2.position, 1);
                for (const t3 of this._markerCollection.getMarkersIntersectingRange(e2)) {
                  const e3 = t3.getRange();
                  this.bufferMarkerChange(t3.name, e3, e3, t3.affectsData);
                }
                break;
              }
              case "split": {
                const e2 = t2.splitPosition.parent;
                if (!this._isInInsertedElement(e2)) {
                  this._markRemove(e2, t2.splitPosition.offset, t2.howMany);
                }
                if (!this._isInInsertedElement(t2.insertionPosition.parent)) {
                  this._markInsert(t2.insertionPosition.parent, t2.insertionPosition.offset, 1);
                }
                if (t2.graveyardPosition) {
                  this._markRemove(t2.graveyardPosition.parent, t2.graveyardPosition.offset, 1);
                }
                break;
              }
              case "merge": {
                const e2 = t2.sourcePosition.parent;
                if (!this._isInInsertedElement(e2.parent)) {
                  this._markRemove(e2.parent, e2.startOffset, 1);
                }
                const i2 = t2.graveyardPosition.parent;
                this._markInsert(i2, t2.graveyardPosition.offset, 1);
                const n2 = t2.targetPosition.parent;
                if (!this._isInInsertedElement(n2)) {
                  this._markInsert(n2, t2.targetPosition.offset, e2.maxOffset);
                }
                break;
              }
            }
            this._cachedChanges = null;
          }
          bufferMarkerChange(t2, e2, i2, n2) {
            const o2 = this._changedMarkers.get(t2);
            if (!o2) {
              this._changedMarkers.set(t2, {oldRange: e2, newRange: i2, affectsData: n2});
            } else {
              o2.newRange = i2;
              o2.affectsData = n2;
              if (o2.oldRange == null && o2.newRange == null) {
                this._changedMarkers.delete(t2);
              }
            }
          }
          getMarkersToRemove() {
            const t2 = [];
            for (const [e2, i2] of this._changedMarkers) {
              if (i2.oldRange != null) {
                t2.push({name: e2, range: i2.oldRange});
              }
            }
            return t2;
          }
          getMarkersToAdd() {
            const t2 = [];
            for (const [e2, i2] of this._changedMarkers) {
              if (i2.newRange != null) {
                t2.push({name: e2, range: i2.newRange});
              }
            }
            return t2;
          }
          getChangedMarkers() {
            return Array.from(this._changedMarkers).map((t2) => ({
              name: t2[0],
              data: {oldRange: t2[1].oldRange, newRange: t2[1].newRange}
            }));
          }
          hasDataChanges() {
            for (const [, t2] of this._changedMarkers) {
              if (t2.affectsData) {
                return true;
              }
            }
            return this._changesInElement.size > 0;
          }
          getChanges(t2 = {includeChangesInGraveyard: false}) {
            if (this._cachedChanges) {
              if (t2.includeChangesInGraveyard) {
                return this._cachedChangesWithGraveyard.slice();
              } else {
                return this._cachedChanges.slice();
              }
            }
            const e2 = [];
            for (const t3 of this._changesInElement.keys()) {
              const i2 = this._changesInElement.get(t3).sort((t4, e3) => {
                if (t4.offset === e3.offset) {
                  if (t4.type != e3.type) {
                    return t4.type == "remove" ? -1 : 1;
                  }
                  return 0;
                }
                return t4.offset < e3.offset ? -1 : 1;
              });
              const n2 = this._elementSnapshots.get(t3);
              const o2 = gm(t3.getChildren());
              const r2 = mm(n2.length, i2);
              let s2 = 0;
              let a2 = 0;
              for (const i3 of r2) {
                if (i3 === "i") {
                  e2.push(this._getInsertDiff(t3, s2, o2[s2].name));
                  s2++;
                } else if (i3 === "r") {
                  e2.push(this._getRemoveDiff(t3, s2, n2[a2].name));
                  a2++;
                } else if (i3 === "a") {
                  const i4 = o2[s2].attributes;
                  const r3 = n2[a2].attributes;
                  let c2;
                  if (o2[s2].name == "$text") {
                    c2 = new $h(Uh._createAt(t3, s2), Uh._createAt(t3, s2 + 1));
                  } else {
                    const e3 = t3.offsetToIndex(s2);
                    c2 = new $h(Uh._createAt(t3, s2), Uh._createAt(t3.getChild(e3), 0));
                  }
                  e2.push(...this._getAttributesDiff(c2, r3, i4));
                  s2++;
                  a2++;
                } else {
                  s2++;
                  a2++;
                }
              }
            }
            e2.sort((t3, e3) => {
              if (t3.position.root != e3.position.root) {
                return t3.position.root.rootName < e3.position.root.rootName ? -1 : 1;
              }
              if (t3.position.isEqual(e3.position)) {
                return t3.changeCount - e3.changeCount;
              }
              return t3.position.isBefore(e3.position) ? -1 : 1;
            });
            for (let t3 = 1; t3 < e2.length; t3++) {
              const i2 = e2[t3 - 1];
              const n2 = e2[t3];
              const o2 = i2.type == "remove" && n2.type == "remove" && i2.name == "$text" && n2.name == "$text" && i2.position.isEqual(n2.position);
              const r2 = i2.type == "insert" && n2.type == "insert" && i2.name == "$text" && n2.name == "$text" && i2.position.parent == n2.position.parent && i2.position.offset + i2.length == n2.position.offset;
              const s2 = i2.type == "attribute" && n2.type == "attribute" && i2.position.parent == n2.position.parent && i2.range.isFlat && n2.range.isFlat && i2.position.offset + i2.length == n2.position.offset && i2.attributeKey == n2.attributeKey && i2.attributeOldValue == n2.attributeOldValue && i2.attributeNewValue == n2.attributeNewValue;
              if (o2 || r2 || s2) {
                e2[t3 - 1].length++;
                if (s2) {
                  e2[t3 - 1].range.end = e2[t3 - 1].range.end.getShiftedBy(1);
                }
                e2.splice(t3, 1);
                t3--;
              }
            }
            for (const t3 of e2) {
              delete t3.changeCount;
              if (t3.type == "attribute") {
                delete t3.position;
                delete t3.length;
              }
            }
            this._changeCount = 0;
            this._cachedChangesWithGraveyard = e2.slice();
            this._cachedChanges = e2.slice().filter(pm);
            if (t2.includeChangesInGraveyard) {
              return this._cachedChangesWithGraveyard;
            } else {
              return this._cachedChanges;
            }
          }
          reset() {
            this._changesInElement.clear();
            this._elementSnapshots.clear();
            this._changedMarkers.clear();
            this._cachedChanges = null;
          }
          _markInsert(t2, e2, i2) {
            const n2 = {type: "insert", offset: e2, howMany: i2, count: this._changeCount++};
            this._markChange(t2, n2);
          }
          _markRemove(t2, e2, i2) {
            const n2 = {type: "remove", offset: e2, howMany: i2, count: this._changeCount++};
            this._markChange(t2, n2);
            this._removeAllNestedChanges(t2, e2, i2);
          }
          _markAttribute(t2) {
            const e2 = {type: "attribute", offset: t2.startOffset, howMany: t2.offsetSize, count: this._changeCount++};
            this._markChange(t2.parent, e2);
          }
          _markChange(t2, e2) {
            this._makeSnapshot(t2);
            const i2 = this._getChangesForElement(t2);
            this._handleChange(e2, i2);
            i2.push(e2);
            for (let t3 = 0; t3 < i2.length; t3++) {
              if (i2[t3].howMany < 1) {
                i2.splice(t3, 1);
                t3--;
              }
            }
          }
          _getChangesForElement(t2) {
            let e2;
            if (this._changesInElement.has(t2)) {
              e2 = this._changesInElement.get(t2);
            } else {
              e2 = [];
              this._changesInElement.set(t2, e2);
            }
            return e2;
          }
          _makeSnapshot(t2) {
            if (!this._elementSnapshots.has(t2)) {
              this._elementSnapshots.set(t2, gm(t2.getChildren()));
            }
          }
          _handleChange(t2, e2) {
            t2.nodesToHandle = t2.howMany;
            for (const i2 of e2) {
              const n2 = t2.offset + t2.howMany;
              const o2 = i2.offset + i2.howMany;
              if (t2.type == "insert") {
                if (i2.type == "insert") {
                  if (t2.offset <= i2.offset) {
                    i2.offset += t2.howMany;
                  } else if (t2.offset < o2) {
                    i2.howMany += t2.nodesToHandle;
                    t2.nodesToHandle = 0;
                  }
                }
                if (i2.type == "remove") {
                  if (t2.offset < i2.offset) {
                    i2.offset += t2.howMany;
                  }
                }
                if (i2.type == "attribute") {
                  if (t2.offset <= i2.offset) {
                    i2.offset += t2.howMany;
                  } else if (t2.offset < o2) {
                    const o3 = i2.howMany;
                    i2.howMany = t2.offset - i2.offset;
                    e2.unshift({
                      type: "attribute",
                      offset: n2,
                      howMany: o3 - i2.howMany,
                      count: this._changeCount++
                    });
                  }
                }
              }
              if (t2.type == "remove") {
                if (i2.type == "insert") {
                  if (n2 <= i2.offset) {
                    i2.offset -= t2.howMany;
                  } else if (n2 <= o2) {
                    if (t2.offset < i2.offset) {
                      const e3 = n2 - i2.offset;
                      i2.offset = t2.offset;
                      i2.howMany -= e3;
                      t2.nodesToHandle -= e3;
                    } else {
                      i2.howMany -= t2.nodesToHandle;
                      t2.nodesToHandle = 0;
                    }
                  } else {
                    if (t2.offset <= i2.offset) {
                      t2.nodesToHandle -= i2.howMany;
                      i2.howMany = 0;
                    } else if (t2.offset < o2) {
                      const e3 = o2 - t2.offset;
                      i2.howMany -= e3;
                      t2.nodesToHandle -= e3;
                    }
                  }
                }
                if (i2.type == "remove") {
                  if (n2 <= i2.offset) {
                    i2.offset -= t2.howMany;
                  } else if (t2.offset < i2.offset) {
                    t2.nodesToHandle += i2.howMany;
                    i2.howMany = 0;
                  }
                }
                if (i2.type == "attribute") {
                  if (n2 <= i2.offset) {
                    i2.offset -= t2.howMany;
                  } else if (t2.offset < i2.offset) {
                    const e3 = n2 - i2.offset;
                    i2.offset = t2.offset;
                    i2.howMany -= e3;
                  } else if (t2.offset < o2) {
                    if (n2 <= o2) {
                      const n3 = i2.howMany;
                      i2.howMany = t2.offset - i2.offset;
                      const o3 = n3 - i2.howMany - t2.nodesToHandle;
                      e2.unshift({
                        type: "attribute",
                        offset: t2.offset,
                        howMany: o3,
                        count: this._changeCount++
                      });
                    } else {
                      i2.howMany -= o2 - t2.offset;
                    }
                  }
                }
              }
              if (t2.type == "attribute") {
                if (i2.type == "insert") {
                  if (t2.offset < i2.offset && n2 > i2.offset) {
                    if (n2 > o2) {
                      const t3 = {
                        type: "attribute",
                        offset: o2,
                        howMany: n2 - o2,
                        count: this._changeCount++
                      };
                      this._handleChange(t3, e2);
                      e2.push(t3);
                    }
                    t2.nodesToHandle = i2.offset - t2.offset;
                    t2.howMany = t2.nodesToHandle;
                  } else if (t2.offset >= i2.offset && t2.offset < o2) {
                    if (n2 > o2) {
                      t2.nodesToHandle = n2 - o2;
                      t2.offset = o2;
                    } else {
                      t2.nodesToHandle = 0;
                    }
                  }
                }
                if (i2.type == "remove") {
                  if (t2.offset < i2.offset && n2 > i2.offset) {
                    const o3 = {
                      type: "attribute",
                      offset: i2.offset,
                      howMany: n2 - i2.offset,
                      count: this._changeCount++
                    };
                    this._handleChange(o3, e2);
                    e2.push(o3);
                    t2.nodesToHandle = i2.offset - t2.offset;
                    t2.howMany = t2.nodesToHandle;
                  }
                }
                if (i2.type == "attribute") {
                  if (t2.offset >= i2.offset && n2 <= o2) {
                    t2.nodesToHandle = 0;
                    t2.howMany = 0;
                    t2.offset = 0;
                  } else if (t2.offset <= i2.offset && n2 >= o2) {
                    i2.howMany = 0;
                  }
                }
              }
            }
            t2.howMany = t2.nodesToHandle;
            delete t2.nodesToHandle;
          }
          _getInsertDiff(t2, e2, i2) {
            return {
              type: "insert",
              position: Uh._createAt(t2, e2),
              name: i2,
              length: 1,
              changeCount: this._changeCount++
            };
          }
          _getRemoveDiff(t2, e2, i2) {
            return {
              type: "remove",
              position: Uh._createAt(t2, e2),
              name: i2,
              length: 1,
              changeCount: this._changeCount++
            };
          }
          _getAttributesDiff(t2, e2, i2) {
            const n2 = [];
            i2 = new Map(i2);
            for (const [o2, r2] of e2) {
              const e3 = i2.has(o2) ? i2.get(o2) : null;
              if (e3 !== r2) {
                n2.push({
                  type: "attribute",
                  position: t2.start,
                  range: t2.clone(),
                  length: 1,
                  attributeKey: o2,
                  attributeOldValue: r2,
                  attributeNewValue: e3,
                  changeCount: this._changeCount++
                });
              }
              i2.delete(o2);
            }
            for (const [e3, o2] of i2) {
              n2.push({
                type: "attribute",
                position: t2.start,
                range: t2.clone(),
                length: 1,
                attributeKey: e3,
                attributeOldValue: null,
                attributeNewValue: o2,
                changeCount: this._changeCount++
              });
            }
            return n2;
          }
          _isInInsertedElement(t2) {
            const e2 = t2.parent;
            if (!e2) {
              return false;
            }
            const i2 = this._changesInElement.get(e2);
            const n2 = t2.startOffset;
            if (i2) {
              for (const t3 of i2) {
                if (t3.type == "insert" && n2 >= t3.offset && n2 < t3.offset + t3.howMany) {
                  return true;
                }
              }
            }
            return this._isInInsertedElement(e2);
          }
          _removeAllNestedChanges(t2, e2, i2) {
            const n2 = new $h(Uh._createAt(t2, e2), Uh._createAt(t2, e2 + i2));
            for (const t3 of n2.getItems({shallow: true})) {
              if (t3.is("element")) {
                this._elementSnapshots.delete(t3);
                this._changesInElement.delete(t3);
                this._removeAllNestedChanges(t3, 0, t3.maxOffset);
              }
            }
          }
        }
        function gm(t2) {
          const e2 = [];
          for (const i2 of t2) {
            if (i2.is("text")) {
              for (let t3 = 0; t3 < i2.data.length; t3++) {
                e2.push({name: "$text", attributes: new Map(i2.getAttributes())});
              }
            } else {
              e2.push({name: i2.name, attributes: new Map(i2.getAttributes())});
            }
          }
          return e2;
        }
        function mm(t2, e2) {
          const i2 = [];
          let n2 = 0;
          let o2 = 0;
          for (const t3 of e2) {
            if (t3.offset > n2) {
              for (let e3 = 0; e3 < t3.offset - n2; e3++) {
                i2.push("e");
              }
              o2 += t3.offset - n2;
            }
            if (t3.type == "insert") {
              for (let e3 = 0; e3 < t3.howMany; e3++) {
                i2.push("i");
              }
              n2 = t3.offset + t3.howMany;
            } else if (t3.type == "remove") {
              for (let e3 = 0; e3 < t3.howMany; e3++) {
                i2.push("r");
              }
              n2 = t3.offset;
              o2 += t3.howMany;
            } else {
              i2.push(..."a".repeat(t3.howMany).split(""));
              n2 = t3.offset + t3.howMany;
              o2 += t3.howMany;
            }
          }
          if (o2 < t2) {
            for (let e3 = 0; e3 < t2 - o2 - n2; e3++) {
              i2.push("e");
            }
          }
          return i2;
        }
        function pm(t2) {
          const e2 = t2.position && t2.position.root.rootName == "$graveyard";
          const i2 = t2.range && t2.range.root.rootName == "$graveyard";
          return !e2 && !i2;
        }
        class bm {
          constructor() {
            this._operations = [];
            this._undoPairs = new Map();
            this._undoneOperations = new Set();
          }
          addOperation(t2) {
            if (this._operations.includes(t2)) {
              return;
            }
            this._operations.push(t2);
          }
          getOperations(t2 = 0, e2 = Number.POSITIVE_INFINITY) {
            if (t2 < 0) {
              return [];
            }
            return this._operations.slice(t2, e2);
          }
          getOperation(t2) {
            return this._operations[t2];
          }
          setOperationAsUndone(t2, e2) {
            this._undoPairs.set(e2, t2);
            this._undoneOperations.add(t2);
          }
          isUndoingOperation(t2) {
            return this._undoPairs.has(t2);
          }
          isUndoneOperation(t2) {
            return this._undoneOperations.has(t2);
          }
          getUndoneOperation(t2) {
            return this._undoPairs.get(t2);
          }
        }
        function wm(t2) {
          return !!t2 && t2.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t2);
        }
        function km(t2) {
          return !!t2 && t2.length == 1 && /[\ud800-\udbff]/.test(t2);
        }
        function _m(t2) {
          return !!t2 && t2.length == 1 && /[\udc00-\udfff]/.test(t2);
        }
        function vm(t2, e2) {
          return km(t2.charAt(e2 - 1)) && _m(t2.charAt(e2));
        }
        function ym(t2, e2) {
          return wm(t2.charAt(e2));
        }
        const xm = "$graveyard";
        class Cm {
          constructor(t2) {
            this.model = t2;
            this.version = 0;
            this.history = new bm(this);
            this.selection = new df(this);
            this.roots = new ys({idProperty: "rootName"});
            this.differ = new fm(t2.markers);
            this._postFixers = new Set();
            this._hasSelectionChangedFromTheLastChangeBlock = false;
            this.createRoot("$root", xm);
            this.listenTo(t2, "applyOperation", (t3, e2) => {
              const i2 = e2[0];
              if (i2.isDocumentOperation && i2.baseVersion !== this.version) {
                throw new ss["b"]("model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.", this, {operation: i2});
              }
            }, {priority: "highest"});
            this.listenTo(t2, "applyOperation", (t3, e2) => {
              const i2 = e2[0];
              if (i2.isDocumentOperation) {
                this.differ.bufferOperation(i2);
              }
            }, {priority: "high"});
            this.listenTo(t2, "applyOperation", (t3, e2) => {
              const i2 = e2[0];
              if (i2.isDocumentOperation) {
                this.version++;
                this.history.addOperation(i2);
              }
            }, {priority: "low"});
            this.listenTo(this.selection, "change", () => {
              this._hasSelectionChangedFromTheLastChangeBlock = true;
            });
            this.listenTo(t2.markers, "update", (t3, e2, i2, n2) => {
              this.differ.bufferMarkerChange(e2.name, i2, n2, e2.affectsData);
              if (i2 === null) {
                e2.on("change", (t4, i3) => {
                  this.differ.bufferMarkerChange(e2.name, i3, e2.getRange(), e2.affectsData);
                });
              }
            });
          }
          get graveyard() {
            return this.getRoot(xm);
          }
          createRoot(t2 = "$root", e2 = "main") {
            if (this.roots.get(e2)) {
              throw new ss["b"]("model-document-createRoot-name-exists: Root with specified name already exists.", this, {name: e2});
            }
            const i2 = new sm(this, t2, e2);
            this.roots.add(i2);
            return i2;
          }
          destroy() {
            this.selection.destroy();
            this.stopListening();
          }
          getRoot(t2 = "main") {
            return this.roots.get(t2);
          }
          getRootNames() {
            return Array.from(this.roots, (t2) => t2.rootName).filter((t2) => t2 != xm);
          }
          registerPostFixer(t2) {
            this._postFixers.add(t2);
          }
          toJSON() {
            const t2 = Bs(this);
            t2.selection = "[engine.model.DocumentSelection]";
            t2.model = "[engine.model.Model]";
            return t2;
          }
          _handleChangeBlock(t2) {
            if (this._hasDocumentChangedFromTheLastChangeBlock()) {
              this._callPostFixers(t2);
              this.selection.refresh();
              if (this.differ.hasDataChanges()) {
                this.fire("change:data", t2.batch);
              } else {
                this.fire("change", t2.batch);
              }
              this.selection.refresh();
              this.differ.reset();
            }
            this._hasSelectionChangedFromTheLastChangeBlock = false;
          }
          _hasDocumentChangedFromTheLastChangeBlock() {
            return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
          }
          _getDefaultRoot() {
            for (const t2 of this.roots) {
              if (t2 !== this.graveyard) {
                return t2;
              }
            }
            return this.graveyard;
          }
          _getDefaultRange() {
            const t2 = this._getDefaultRoot();
            const e2 = this.model;
            const i2 = e2.schema;
            const n2 = e2.createPositionFromPath(t2, [0]);
            const o2 = i2.getNearestSelectionRange(n2);
            return o2 || e2.createRange(n2);
          }
          _validateSelectionRange(t2) {
            return Am(t2.start) && Am(t2.end);
          }
          _callPostFixers(t2) {
            let e2 = false;
            do {
              for (const i2 of this._postFixers) {
                this.selection.refresh();
                e2 = i2(t2);
                if (e2) {
                  break;
                }
              }
            } while (e2);
          }
        }
        vs(Cm, ds);
        function Am(t2) {
          const e2 = t2.textNode;
          if (e2) {
            const i2 = e2.data;
            const n2 = t2.offset - e2.startOffset;
            return !vm(i2, n2) && !ym(i2, n2);
          }
          return true;
        }
        class Tm {
          constructor() {
            this._markers = new Map();
          }
          [Symbol.iterator]() {
            return this._markers.values();
          }
          has(t2) {
            return this._markers.has(t2);
          }
          get(t2) {
            return this._markers.get(t2) || null;
          }
          _set(t2, e2, i2 = false, n2 = false) {
            const o2 = t2 instanceof Pm ? t2.name : t2;
            const r2 = this._markers.get(o2);
            if (r2) {
              const t3 = r2.getRange();
              let s3 = false;
              if (!t3.isEqual(e2)) {
                r2._attachLiveRange(rf.fromRange(e2));
                s3 = true;
              }
              if (i2 != r2.managedUsingOperations) {
                r2._managedUsingOperations = i2;
                s3 = true;
              }
              if (typeof n2 === "boolean" && n2 != r2.affectsData) {
                r2._affectsData = n2;
                s3 = true;
              }
              if (s3) {
                this.fire("update:" + o2, r2, t3, e2);
              }
              return r2;
            }
            const s2 = rf.fromRange(e2);
            const a2 = new Pm(o2, s2, i2, n2);
            this._markers.set(o2, a2);
            this.fire("update:" + o2, a2, null, e2);
            return a2;
          }
          _remove(t2) {
            const e2 = t2 instanceof Pm ? t2.name : t2;
            const i2 = this._markers.get(e2);
            if (i2) {
              this._markers.delete(e2);
              this.fire("update:" + e2, i2, i2.getRange(), null);
              this._destroyMarker(i2);
              return true;
            }
            return false;
          }
          _refresh(t2) {
            const e2 = t2 instanceof Pm ? t2.name : t2;
            const i2 = this._markers.get(e2);
            if (!i2) {
              throw new ss["b"]("markercollection-refresh-marker-not-exists: Marker with provided name does not exists.", this);
            }
            const n2 = i2.getRange();
            this.fire("update:" + e2, i2, n2, n2, i2.managedUsingOperations, i2.affectsData);
          }
          *getMarkersAtPosition(t2) {
            for (const e2 of this) {
              if (e2.getRange().containsPosition(t2)) {
                yield e2;
              }
            }
          }
          *getMarkersIntersectingRange(t2) {
            for (const e2 of this) {
              if (e2.getRange().getIntersection(t2) !== null) {
                yield e2;
              }
            }
          }
          destroy() {
            for (const t2 of this._markers.values()) {
              this._destroyMarker(t2);
            }
            this._markers = null;
            this.stopListening();
          }
          *getMarkersGroup(t2) {
            for (const e2 of this._markers.values()) {
              if (e2.name.startsWith(t2 + ":")) {
                yield e2;
              }
            }
          }
          _destroyMarker(t2) {
            t2.stopListening();
            t2._detachLiveRange();
          }
        }
        vs(Tm, ds);
        class Pm {
          constructor(t2, e2, i2, n2) {
            this.name = t2;
            this._liveRange = this._attachLiveRange(e2);
            this._managedUsingOperations = i2;
            this._affectsData = n2;
          }
          get managedUsingOperations() {
            if (!this._liveRange) {
              throw new ss["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this);
            }
            return this._managedUsingOperations;
          }
          get affectsData() {
            if (!this._liveRange) {
              throw new ss["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this);
            }
            return this._affectsData;
          }
          getStart() {
            if (!this._liveRange) {
              throw new ss["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this);
            }
            return this._liveRange.start.clone();
          }
          getEnd() {
            if (!this._liveRange) {
              throw new ss["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this);
            }
            return this._liveRange.end.clone();
          }
          getRange() {
            if (!this._liveRange) {
              throw new ss["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this);
            }
            return this._liveRange.toRange();
          }
          is(t2) {
            return t2 == "marker" || t2 == "model:marker";
          }
          _attachLiveRange(t2) {
            if (this._liveRange) {
              this._detachLiveRange();
            }
            t2.delegate("change:range").to(this);
            t2.delegate("change:content").to(this);
            this._liveRange = t2;
            return t2;
          }
          _detachLiveRange() {
            this._liveRange.stopDelegating("change:range", this);
            this._liveRange.stopDelegating("change:content", this);
            this._liveRange.detach();
            this._liveRange = null;
          }
        }
        vs(Pm, ds);
        class Sm extends Lg {
          get type() {
            return "noop";
          }
          clone() {
            return new Sm(this.baseVersion);
          }
          getReversed() {
            return new Sm(this.baseVersion + 1);
          }
          _execute() {
          }
          static get className() {
            return "NoOperation";
          }
        }
        const Em = {};
        Em[Qg.className] = Qg;
        Em[tm.className] = tm;
        Em[em.className] = em;
        Em[Zg.className] = Zg;
        Em[Sm.className] = Sm;
        Em[Lg.className] = Lg;
        Em[im.className] = im;
        Em[nm.className] = nm;
        Em[rm.className] = rm;
        Em[om.className] = om;
        class Rm {
          static fromJSON(t2, e2) {
            return Em[t2.__className].fromJSON(t2, e2);
          }
        }
        class Om extends Uh {
          constructor(t2, e2, i2 = "toNone") {
            super(t2, e2, i2);
            if (!this.root.is("rootElement")) {
              throw new ss["b"]("model-liveposition-root-not-rootelement: LivePosition's root has to be an instance of RootElement.", t2);
            }
            Im.call(this);
          }
          detach() {
            this.stopListening();
          }
          is(t2) {
            return t2 == "livePosition" || t2 == "model:livePosition" || super.is(t2);
          }
          toPosition() {
            return new Uh(this.root, this.path.slice(), this.stickiness);
          }
          static fromPosition(t2, e2) {
            return new this(t2.root, t2.path.slice(), e2 ? e2 : t2.stickiness);
          }
        }
        function Im() {
          this.listenTo(this.root.document.model, "applyOperation", (t2, e2) => {
            const i2 = e2[0];
            if (!i2.isDocumentOperation) {
              return;
            }
            Vm.call(this, i2);
          }, {priority: "low"});
        }
        function Vm(t2) {
          const e2 = this.getTransformedByOperation(t2);
          if (!this.isEqual(e2)) {
            const t3 = this.toPosition();
            this.path = e2.path;
            this.root = e2.root;
            this.fire("change", t3);
          }
        }
        vs(Om, ds);
        function Nm(t2, e2, i2, n2) {
          return t2.change((o2) => {
            let r2;
            if (!i2) {
              r2 = t2.document.selection;
            } else if (i2 instanceof Xh || i2 instanceof df) {
              r2 = i2;
            } else {
              r2 = o2.createSelection(i2, n2);
            }
            if (!r2.isCollapsed) {
              t2.deleteContent(r2, {doNotAutoparagraph: true});
            }
            const s2 = new Mm(t2, o2, r2.anchor);
            let a2;
            if (e2.is("documentFragment")) {
              a2 = e2.getChildren();
            } else {
              a2 = [e2];
            }
            s2.handleNodes(a2, {isFirst: true, isLast: true});
            const c2 = s2.getSelectionRange();
            if (c2) {
              if (r2 instanceof df) {
                o2.setSelection(c2);
              } else {
                r2.setTo(c2);
              }
            } else {
            }
            const l2 = s2.getAffectedRange() || t2.createRange(r2.anchor);
            s2.destroy();
            return l2;
          });
        }
        class Mm {
          constructor(t2, e2, i2) {
            this.model = t2;
            this.writer = e2;
            this.position = i2;
            this.canMergeWith = new Set([this.position.parent]);
            this.schema = t2.schema;
            this._filterAttributesOf = [];
            this._affectedStart = null;
            this._affectedEnd = null;
          }
          handleNodes(t2, e2) {
            t2 = Array.from(t2);
            for (let i2 = 0; i2 < t2.length; i2++) {
              const n2 = t2[i2];
              this._handleNode(n2, {isFirst: i2 === 0 && e2.isFirst, isLast: i2 === t2.length - 1 && e2.isLast});
            }
            this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
            this._filterAttributesOf = [];
          }
          getSelectionRange() {
            if (this.nodeToSelect) {
              return $h._createOn(this.nodeToSelect);
            }
            return this.model.schema.getNearestSelectionRange(this.position);
          }
          getAffectedRange() {
            if (!this._affectedStart) {
              return null;
            }
            return new $h(this._affectedStart, this._affectedEnd);
          }
          destroy() {
            if (this._affectedStart) {
              this._affectedStart.detach();
            }
            if (this._affectedEnd) {
              this._affectedEnd.detach();
            }
          }
          _handleNode(t2, e2) {
            if (this.schema.isObject(t2)) {
              this._handleObject(t2, e2);
              return;
            }
            const i2 = this._checkAndSplitToAllowedPosition(t2, e2);
            if (!i2) {
              this._handleDisallowedNode(t2, e2);
              return;
            }
            this._insert(t2);
            this._mergeSiblingsOf(t2, e2);
          }
          _handleObject(t2, e2) {
            if (this._checkAndSplitToAllowedPosition(t2)) {
              this._insert(t2);
            } else {
              this._tryAutoparagraphing(t2, e2);
            }
          }
          _handleDisallowedNode(t2, e2) {
            if (t2.is("element")) {
              this.handleNodes(t2.getChildren(), e2);
            } else {
              this._tryAutoparagraphing(t2, e2);
            }
          }
          _insert(t2) {
            if (!this.schema.checkChild(this.position, t2)) {
              throw new ss["b"]("insertcontent-wrong-position: Given node cannot be inserted on the given position.", this, {
                node: t2,
                position: this.position
              });
            }
            const e2 = Om.fromPosition(this.position, "toNext");
            this._setAffectedBoundaries(this.position);
            this.writer.insert(t2, this.position);
            this.position = e2.toPosition();
            e2.detach();
            if (this.schema.isObject(t2) && !this.schema.checkChild(this.position, "$text")) {
              this.nodeToSelect = t2;
            } else {
              this.nodeToSelect = null;
            }
            this._filterAttributesOf.push(t2);
          }
          _setAffectedBoundaries(t2) {
            if (!this._affectedStart) {
              this._affectedStart = Om.fromPosition(t2, "toPrevious");
            }
            if (!this._affectedEnd || this._affectedEnd.isBefore(t2)) {
              if (this._affectedEnd) {
                this._affectedEnd.detach();
              }
              this._affectedEnd = Om.fromPosition(t2, "toNext");
            }
          }
          _mergeSiblingsOf(t2, e2) {
            if (!(t2 instanceof jh)) {
              return;
            }
            const i2 = this._canMergeLeft(t2, e2);
            const n2 = this._canMergeRight(t2, e2);
            const o2 = Om._createBefore(t2);
            o2.stickiness = "toNext";
            const r2 = Om._createAfter(t2);
            r2.stickiness = "toNext";
            if (i2) {
              const t3 = Om.fromPosition(this.position);
              t3.stickiness = "toNext";
              if (this._affectedStart.isEqual(o2)) {
                this._affectedStart.detach();
                this._affectedStart = Om._createAt(o2.nodeBefore, "end", "toPrevious");
              }
              this.writer.merge(o2);
              if (o2.isEqual(this._affectedEnd) && e2.isLast) {
                this._affectedEnd.detach();
                this._affectedEnd = Om._createAt(o2.nodeBefore, "end", "toNext");
              }
              this.position = t3.toPosition();
              t3.detach();
            }
            if (n2) {
              if (!this.position.isEqual(r2)) {
                throw new ss["b"]("insertcontent-invalid-insertion-position", this);
              }
              this.position = Uh._createAt(r2.nodeBefore, "end");
              const t3 = Om.fromPosition(this.position, "toPrevious");
              if (this._affectedEnd.isEqual(r2)) {
                this._affectedEnd.detach();
                this._affectedEnd = Om._createAt(r2.nodeBefore, "end", "toNext");
              }
              this.writer.merge(r2);
              if (r2.getShiftedBy(-1).isEqual(this._affectedStart) && e2.isFirst) {
                this._affectedStart.detach();
                this._affectedStart = Om._createAt(r2.nodeBefore, 0, "toPrevious");
              }
              this.position = t3.toPosition();
              t3.detach();
            }
            if (i2 || n2) {
              this._filterAttributesOf.push(this.position.parent);
            }
            o2.detach();
            r2.detach();
          }
          _canMergeLeft(t2, e2) {
            const i2 = t2.previousSibling;
            return e2.isFirst && i2 instanceof jh && this.canMergeWith.has(i2) && this.model.schema.checkMerge(i2, t2);
          }
          _canMergeRight(t2, e2) {
            const i2 = t2.nextSibling;
            return e2.isLast && i2 instanceof jh && this.canMergeWith.has(i2) && this.model.schema.checkMerge(t2, i2);
          }
          _tryAutoparagraphing(t2, e2) {
            const i2 = this.writer.createElement("paragraph");
            if (this._getAllowedIn(i2, this.position.parent) && this.schema.checkChild(i2, t2)) {
              i2._appendChild(t2);
              this._handleNode(i2, e2);
            }
          }
          _checkAndSplitToAllowedPosition(t2) {
            const e2 = this._getAllowedIn(t2, this.position.parent);
            if (!e2) {
              return false;
            }
            while (e2 != this.position.parent) {
              if (this.schema.isLimit(this.position.parent)) {
                return false;
              }
              if (this.position.isAtStart) {
                const t3 = this.position.parent;
                this.position = this.writer.createPositionBefore(t3);
                if (t3.isEmpty && t3.parent === e2) {
                  this.writer.remove(t3);
                }
              } else if (this.position.isAtEnd) {
                this.position = this.writer.createPositionAfter(this.position.parent);
              } else {
                const t3 = this.writer.createPositionAfter(this.position.parent);
                this._setAffectedBoundaries(this.position);
                this.writer.split(this.position);
                this.position = t3;
                this.canMergeWith.add(this.position.nodeAfter);
              }
            }
            return true;
          }
          _getAllowedIn(t2, e2) {
            if (this.schema.checkChild(e2, t2)) {
              return e2;
            }
            if (e2.parent) {
              return this._getAllowedIn(t2, e2.parent);
            }
            return null;
          }
        }
        function Bm(t2, e2, i2 = {}) {
          if (e2.isCollapsed) {
            return;
          }
          const n2 = e2.getFirstRange();
          if (n2.root.rootName == "$graveyard") {
            return;
          }
          const o2 = t2.schema;
          t2.change((t3) => {
            if (!i2.doNotResetEntireContent && Hm(o2, e2)) {
              jm(t3, e2, o2);
              return;
            }
            const r2 = n2.start;
            const s2 = Om.fromPosition(n2.end, "toNext");
            if (!n2.start.isTouching(n2.end)) {
              t3.remove(n2);
            }
            if (!i2.leaveUnmerged) {
              zm(t3, r2, s2);
              o2.removeDisallowedAttributes(r2.parent.getChildren(), t3);
            }
            Wm(t3, e2, r2);
            if (!i2.doNotAutoparagraph && Lm(o2, r2)) {
              Dm(t3, r2, e2);
            }
            s2.detach();
          });
        }
        function zm(t2, e2, i2) {
          const n2 = e2.parent;
          const o2 = i2.parent;
          if (n2 == o2) {
            return;
          }
          if (t2.model.schema.isLimit(n2) || t2.model.schema.isLimit(o2)) {
            return;
          }
          if (!Fm(e2, i2, t2.model.schema)) {
            return;
          }
          e2 = t2.createPositionAfter(n2);
          i2 = t2.createPositionBefore(o2);
          if (!i2.isEqual(e2)) {
            t2.insert(o2, e2);
          }
          t2.merge(e2);
          while (i2.parent.isEmpty) {
            const e3 = i2.parent;
            i2 = t2.createPositionBefore(e3);
            t2.remove(e3);
          }
          zm(t2, e2, i2);
        }
        function Lm(t2, e2) {
          const i2 = t2.checkChild(e2, "$text");
          const n2 = t2.checkChild(e2, "paragraph");
          return !i2 && n2;
        }
        function Fm(t2, e2, i2) {
          const n2 = new $h(t2, e2);
          for (const t3 of n2.getWalker()) {
            if (i2.isLimit(t3.item)) {
              return false;
            }
          }
          return true;
        }
        function Dm(t2, e2, i2) {
          const n2 = t2.createElement("paragraph");
          t2.insert(n2, e2);
          Wm(t2, i2, t2.createPositionAt(n2, 0));
        }
        function jm(t2, e2) {
          const i2 = t2.model.schema.getLimitElement(e2);
          t2.remove(t2.createRangeIn(i2));
          Dm(t2, t2.createPositionAt(i2, 0), e2);
        }
        function Hm(t2, e2) {
          const i2 = t2.getLimitElement(e2);
          if (!e2.containsEntireContent(i2)) {
            return false;
          }
          const n2 = e2.getFirstRange();
          if (n2.start.parent == n2.end.parent) {
            return false;
          }
          return t2.checkChild(i2, "paragraph");
        }
        function Wm(t2, e2, i2) {
          if (e2 instanceof df) {
            t2.setSelection(i2);
          } else {
            e2.setTo(i2);
          }
        }
        const qm = ' ,.?!:;"-()';
        function Um(t2, e2, i2 = {}) {
          const n2 = t2.schema;
          const o2 = i2.direction != "backward";
          const r2 = i2.unit ? i2.unit : "character";
          const s2 = e2.focus;
          const a2 = new Wh({boundaries: Jm(s2, o2), singleCharacters: true, direction: o2 ? "forward" : "backward"});
          const c2 = {walker: a2, schema: n2, isForward: o2, unit: r2};
          let l2;
          while (l2 = a2.next()) {
            if (l2.done) {
              return;
            }
            const i3 = $m(c2, l2.value);
            if (i3) {
              if (e2 instanceof df) {
                t2.change((t3) => {
                  t3.setSelectionFocus(i3);
                });
              } else {
                e2.setFocus(i3);
              }
              return;
            }
          }
        }
        function $m(t2, e2) {
          if (e2.type == "text") {
            if (t2.unit === "word") {
              return Km(t2.walker, t2.isForward);
            }
            return Gm(t2.walker, t2.unit, t2.isForward);
          }
          if (e2.type == (t2.isForward ? "elementStart" : "elementEnd")) {
            if (t2.schema.isObject(e2.item)) {
              return Uh._createAt(e2.item, t2.isForward ? "after" : "before");
            }
            if (t2.schema.checkChild(e2.nextPosition, "$text")) {
              return e2.nextPosition;
            }
          } else {
            if (t2.schema.isLimit(e2.item)) {
              t2.walker.skip(() => true);
              return;
            }
            if (t2.schema.checkChild(e2.nextPosition, "$text")) {
              return e2.nextPosition;
            }
          }
        }
        function Gm(t2, e2) {
          const i2 = t2.position.textNode;
          if (i2) {
            const n2 = i2.data;
            let o2 = t2.position.offset - i2.startOffset;
            while (vm(n2, o2) || e2 == "character" && ym(n2, o2)) {
              t2.next();
              o2 = t2.position.offset - i2.startOffset;
            }
          }
          return t2.position;
        }
        function Km(t2, e2) {
          let i2 = t2.position.textNode;
          if (i2) {
            let n2 = t2.position.offset - i2.startOffset;
            while (!Ym(i2.data, n2, e2) && !Qm(i2, n2, e2)) {
              t2.next();
              const o2 = e2 ? t2.position.nodeAfter : t2.position.nodeBefore;
              if (o2 && o2.is("text")) {
                const n3 = o2.data.charAt(e2 ? 0 : o2.data.length - 1);
                if (!qm.includes(n3)) {
                  t2.next();
                  i2 = t2.position.textNode;
                }
              }
              n2 = t2.position.offset - i2.startOffset;
            }
          }
          return t2.position;
        }
        function Jm(t2, e2) {
          const i2 = t2.root;
          const n2 = Uh._createAt(i2, e2 ? "end" : 0);
          if (e2) {
            return new $h(t2, n2);
          } else {
            return new $h(n2, t2);
          }
        }
        function Ym(t2, e2, i2) {
          const n2 = e2 + (i2 ? 0 : -1);
          return qm.includes(t2.charAt(n2));
        }
        function Qm(t2, e2, i2) {
          return e2 === (i2 ? t2.endOffset : 0);
        }
        function Xm(t2, e2) {
          return t2.change((t3) => {
            const i2 = t3.createDocumentFragment();
            const n2 = e2.getFirstRange();
            if (!n2 || n2.isCollapsed) {
              return i2;
            }
            const o2 = n2.start.root;
            const r2 = n2.start.getCommonPath(n2.end);
            const s2 = o2.getNodeByPath(r2);
            let a2;
            if (n2.start.parent == n2.end.parent) {
              a2 = n2;
            } else {
              a2 = t3.createRange(t3.createPositionAt(s2, n2.start.path[r2.length]), t3.createPositionAt(s2, n2.end.path[r2.length] + 1));
            }
            const c2 = a2.end.offset - a2.start.offset;
            for (const e3 of a2.getItems({shallow: true})) {
              if (e3.is("textProxy")) {
                t3.appendText(e3.data, e3.getAttributes(), i2);
              } else {
                t3.append(e3._clone(true), i2);
              }
            }
            if (a2 != n2) {
              const e3 = n2._getTransformedByMove(a2.start, t3.createPositionAt(i2, 0), c2)[0];
              const o3 = t3.createRange(t3.createPositionAt(i2, 0), e3.start);
              const r3 = t3.createRange(e3.end, t3.createPositionAt(i2, "end"));
              Zm(r3, t3);
              Zm(o3, t3);
            }
            return i2;
          });
        }
        function Zm(t2, e2) {
          const i2 = [];
          Array.from(t2.getItems({direction: "backward"})).map((t3) => e2.createRangeOn(t3)).filter((e3) => {
            const i3 = (e3.start.isAfter(t2.start) || e3.start.isEqual(t2.start)) && (e3.end.isBefore(t2.end) || e3.end.isEqual(t2.end));
            return i3;
          }).forEach((t3) => {
            i2.push(t3.start.parent);
            e2.remove(t3);
          });
          i2.forEach((t3) => {
            let i3 = t3;
            while (i3.parent && i3.isEmpty) {
              const t4 = e2.createRangeOn(i3);
              i3 = i3.parent;
              e2.remove(t4);
            }
          });
        }
        function tp(t2) {
          t2.document.registerPostFixer((e2) => ep(e2, t2));
        }
        function ep(t2, e2) {
          const i2 = e2.document.selection;
          const n2 = e2.schema;
          const o2 = [];
          let r2 = false;
          for (const t3 of i2.getRanges()) {
            const e3 = ip(t3, n2);
            if (e3) {
              o2.push(e3);
              r2 = true;
            } else {
              o2.push(t3);
            }
          }
          if (r2) {
            t2.setSelection(ap(o2), {backward: i2.isBackward});
          }
        }
        function ip(t2, e2) {
          if (t2.isCollapsed) {
            return np(t2, e2);
          }
          return op(t2, e2);
        }
        function np(t2, e2) {
          const i2 = t2.start;
          const n2 = e2.getNearestSelectionRange(i2);
          if (!n2) {
            return null;
          }
          if (!n2.isCollapsed) {
            return n2;
          }
          const o2 = n2.start;
          if (i2.isEqual(o2)) {
            return null;
          }
          return new $h(o2);
        }
        function op(t2, e2) {
          const i2 = t2.start;
          const n2 = t2.end;
          const o2 = e2.checkChild(i2, "$text");
          const r2 = e2.checkChild(n2, "$text");
          const s2 = e2.getLimitElement(i2);
          const a2 = e2.getLimitElement(n2);
          if (s2 === a2) {
            if (o2 && r2) {
              return null;
            }
            if (sp(i2, n2, e2)) {
              const t3 = i2.nodeAfter && e2.isObject(i2.nodeAfter);
              const o3 = t3 ? null : e2.getNearestSelectionRange(i2, "forward");
              const r3 = n2.nodeBefore && e2.isObject(n2.nodeBefore);
              const s3 = r3 ? null : e2.getNearestSelectionRange(n2, "backward");
              const a3 = o3 ? o3.start : i2;
              const c3 = s3 ? s3.start : n2;
              return new $h(a3, c3);
            }
          }
          const c2 = s2 && !s2.is("rootElement");
          const l2 = a2 && !a2.is("rootElement");
          if (c2 || l2) {
            const t3 = i2.nodeAfter && n2.nodeBefore && i2.nodeAfter.parent === n2.nodeBefore.parent;
            const o3 = c2 && (!t3 || !cp(i2.nodeAfter, e2));
            const r3 = l2 && (!t3 || !cp(n2.nodeBefore, e2));
            let d2 = i2;
            let u2 = n2;
            if (o3) {
              d2 = Uh._createBefore(rp(s2, e2));
            }
            if (r3) {
              u2 = Uh._createAfter(rp(a2, e2));
            }
            return new $h(d2, u2);
          }
          return null;
        }
        function rp(t2, e2) {
          let i2 = t2;
          let n2 = i2;
          while (e2.isLimit(n2) && n2.parent) {
            i2 = n2;
            n2 = n2.parent;
          }
          return i2;
        }
        function sp(t2, e2, i2) {
          const n2 = t2.nodeAfter && !i2.isLimit(t2.nodeAfter) || i2.checkChild(t2, "$text");
          const o2 = e2.nodeBefore && !i2.isLimit(e2.nodeBefore) || i2.checkChild(e2, "$text");
          return n2 || o2;
        }
        function ap(t2) {
          const e2 = [];
          e2.push(t2.shift());
          for (const i2 of t2) {
            const t3 = e2.pop();
            if (i2.isIntersecting(t3)) {
              const n2 = t3.start.isAfter(i2.start) ? i2.start : t3.start;
              const o2 = t3.end.isAfter(i2.end) ? t3.end : i2.end;
              const r2 = new $h(n2, o2);
              e2.push(r2);
            } else {
              e2.push(t3);
              e2.push(i2);
            }
          }
          return e2;
        }
        function cp(t2, e2) {
          return t2 && e2.isObject(t2);
        }
        class lp {
          constructor() {
            this.markers = new Tm();
            this.document = new Cm(this);
            this.schema = new ug();
            this._pendingChanges = [];
            this._currentWriter = null;
            ["insertContent", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t2) => this.decorate(t2));
            this.on("applyOperation", (t2, e2) => {
              const i2 = e2[0];
              i2._validate();
            }, {priority: "highest"});
            this.schema.register("$root", {isLimit: true});
            this.schema.register("$block", {allowIn: "$root", isBlock: true});
            this.schema.register("$text", {allowIn: "$block", isInline: true});
            this.schema.register("$clipboardHolder", {allowContentOf: "$root", isLimit: true});
            this.schema.extend("$text", {allowIn: "$clipboardHolder"});
            this.schema.register("$marker");
            this.schema.addChildCheck((t2, e2) => {
              if (e2.name === "$marker") {
                return true;
              }
            });
            tp(this);
          }
          change(t2) {
            try {
              if (this._pendingChanges.length === 0) {
                this._pendingChanges.push({batch: new zg(), callback: t2});
                return this._runPendingChanges()[0];
              } else {
                return t2(this._currentWriter);
              }
            } catch (t3) {
              ss["b"].rethrowUnexpectedError(t3, this);
            }
          }
          enqueueChange(t2, e2) {
            try {
              if (typeof t2 === "string") {
                t2 = new zg(t2);
              } else if (typeof t2 == "function") {
                e2 = t2;
                t2 = new zg();
              }
              this._pendingChanges.push({batch: t2, callback: e2});
              if (this._pendingChanges.length == 1) {
                this._runPendingChanges();
              }
            } catch (t3) {
              ss["b"].rethrowUnexpectedError(t3, this);
            }
          }
          applyOperation(t2) {
            t2._execute();
          }
          insertContent(t2, e2, i2) {
            return Nm(this, t2, e2, i2);
          }
          deleteContent(t2, e2) {
            Bm(this, t2, e2);
          }
          modifySelection(t2, e2) {
            Um(this, t2, e2);
          }
          getSelectedContent(t2) {
            return Xm(this, t2);
          }
          hasContent(t2, e2) {
            const i2 = t2 instanceof jh ? $h._createIn(t2) : t2;
            if (i2.isCollapsed) {
              return false;
            }
            for (const t3 of this.markers.getMarkersIntersectingRange(i2)) {
              if (t3.affectsData) {
                return true;
              }
            }
            const {ignoreWhitespaces: n2 = false} = e2 || {};
            for (const t3 of i2.getItems()) {
              if (t3.is("textProxy")) {
                if (!n2) {
                  return true;
                } else if (t3.data.search(/\S/) !== -1) {
                  return true;
                }
              } else if (this.schema.isObject(t3)) {
                return true;
              }
            }
            return false;
          }
          createPositionFromPath(t2, e2, i2) {
            return new Uh(t2, e2, i2);
          }
          createPositionAt(t2, e2) {
            return Uh._createAt(t2, e2);
          }
          createPositionAfter(t2) {
            return Uh._createAfter(t2);
          }
          createPositionBefore(t2) {
            return Uh._createBefore(t2);
          }
          createRange(t2, e2) {
            return new $h(t2, e2);
          }
          createRangeIn(t2) {
            return $h._createIn(t2);
          }
          createRangeOn(t2) {
            return $h._createOn(t2);
          }
          createSelection(t2, e2, i2) {
            return new Xh(t2, e2, i2);
          }
          createBatch(t2) {
            return new zg(t2);
          }
          createOperationFromJSON(t2) {
            return Rm.fromJSON(t2, this.document);
          }
          destroy() {
            this.document.destroy();
            this.stopListening();
          }
          _runPendingChanges() {
            const t2 = [];
            this.fire("_beforeChanges");
            while (this._pendingChanges.length) {
              const e2 = this._pendingChanges[0].batch;
              this._currentWriter = new am(this, e2);
              const i2 = this._pendingChanges[0].callback(this._currentWriter);
              t2.push(i2);
              this.document._handleChangeBlock(this._currentWriter);
              this._pendingChanges.shift();
              this._currentWriter = null;
            }
            this.fire("_afterChanges");
            return t2;
          }
        }
        vs(lp, Jc);
        class dp {
          constructor() {
            this._listener = Object.create(qd);
          }
          listenTo(t2) {
            this._listener.listenTo(t2, "keydown", (t3, e2) => {
              this._listener.fire("_keydown:" + Ml(e2), e2);
            });
          }
          set(t2, e2, i2 = {}) {
            const n2 = Bl(t2);
            const o2 = i2.priority;
            this._listener.listenTo(this._listener, "_keydown:" + n2, (t3, i3) => {
              e2(i3, () => {
                i3.preventDefault();
                i3.stopPropagation();
                t3.stop();
              });
              t3.return = true;
            }, {priority: o2});
          }
          press(t2) {
            return !!this._listener.fire("_keydown:" + Ml(t2), t2);
          }
          destroy() {
            this._listener.stopListening();
          }
        }
        class up extends dp {
          constructor(t2) {
            super();
            this.editor = t2;
          }
          set(t2, e2, i2 = {}) {
            if (typeof e2 == "string") {
              const t3 = e2;
              e2 = (e3, i3) => {
                this.editor.execute(t3);
                i3();
              };
            }
            super.set(t2, e2, i2);
          }
        }
        class hp {
          constructor(t2 = {}) {
            this._context = t2.context || new Is({language: t2.language});
            this._context._addEditor(this, !t2.context);
            const e2 = Array.from(this.constructor.builtinPlugins || []);
            this.config = new Jr(t2, this.constructor.defaultConfig);
            this.config.define("plugins", e2);
            this.config.define(this._context._getEditorConfig());
            this.plugins = new xs(this, e2, this._context.plugins);
            this.locale = this._context.locale;
            this.t = this.locale.t;
            this.commands = new cg();
            this.set("state", "initializing");
            this.once("ready", () => this.state = "ready", {priority: "high"});
            this.once("destroy", () => this.state = "destroyed", {priority: "high"});
            this.set("isReadOnly", false);
            this.model = new lp();
            const i2 = new Vc();
            this.data = new Ig(this.model, i2);
            this.editing = new ag(this.model, i2);
            this.editing.view.document.bind("isReadOnly").to(this);
            this.conversion = new Ng([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
            this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
            this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
            this.keystrokes = new up(this);
            this.keystrokes.listenTo(this.editing.view.document);
          }
          initPlugins() {
            const t2 = this.config;
            const e2 = t2.get("plugins");
            const i2 = t2.get("removePlugins") || [];
            const n2 = t2.get("extraPlugins") || [];
            return this.plugins.init(e2.concat(n2), i2);
          }
          destroy() {
            let t2 = Promise.resolve();
            if (this.state == "initializing") {
              t2 = new Promise((t3) => this.once("ready", t3));
            }
            return t2.then(() => {
              this.fire("destroy");
              this.stopListening();
              this.commands.destroy();
            }).then(() => this.plugins.destroy()).then(() => {
              this.model.destroy();
              this.data.destroy();
              this.editing.destroy();
              this.keystrokes.destroy();
            }).then(() => this._context._removeEditor(this));
          }
          execute(...t2) {
            try {
              this.commands.execute(...t2);
            } catch (t3) {
              ss["b"].rethrowUnexpectedError(t3, this);
            }
          }
        }
        vs(hp, Jc);
        class fp {
          getHtml(t2) {
            const e2 = document.implementation.createHTMLDocument("");
            const i2 = e2.createElement("div");
            i2.appendChild(t2);
            return i2.innerHTML;
          }
        }
        class gp {
          constructor(t2) {
            this._domParser = new DOMParser();
            this._domConverter = new zd(t2, {blockFillerMode: "nbsp"});
            this._htmlWriter = new fp();
          }
          toData(t2) {
            const e2 = this._domConverter.viewToDom(t2, document);
            return this._htmlWriter.getHtml(e2);
          }
          toView(t2) {
            const e2 = this._toDom(t2);
            return this._domConverter.domToView(e2);
          }
          _toDom(t2) {
            const e2 = this._domParser.parseFromString(t2, "text/html");
            const i2 = e2.createDocumentFragment();
            const n2 = e2.body.childNodes;
            while (n2.length > 0) {
              i2.appendChild(n2[0]);
            }
            return i2;
          }
        }
        class mp {
          constructor(t2) {
            this.editor = t2;
            this.set("isEnabled", true);
            this._disableStack = new Set();
          }
          forceDisabled(t2) {
            this._disableStack.add(t2);
            if (this._disableStack.size == 1) {
              this.on("set:isEnabled", pp, {priority: "highest"});
              this.isEnabled = false;
            }
          }
          clearForceDisabled(t2) {
            this._disableStack.delete(t2);
            if (this._disableStack.size == 0) {
              this.off("set:isEnabled", pp);
              this.isEnabled = true;
            }
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return false;
          }
        }
        vs(mp, Jc);
        function pp(t2) {
          t2.return = false;
          t2.stop();
        }
        class bp extends ys {
          constructor(t2) {
            super({idProperty: "viewUid"});
            this.on("add", (t3, e2, i2) => {
              if (!e2.isRendered) {
                e2.render();
              }
              if (e2.element && this._parentElement) {
                this._parentElement.insertBefore(e2.element, this._parentElement.children[i2]);
              }
            });
            this.on("remove", (t3, e2) => {
              if (e2.element && this._parentElement) {
                e2.element.remove();
              }
            });
            this.locale = t2;
            this._parentElement = null;
          }
          destroy() {
            this.map((t2) => t2.destroy());
          }
          setParent(t2) {
            this._parentElement = t2;
          }
          delegate(...t2) {
            if (!t2.length || !wp(t2)) {
              throw new ss["b"]("ui-viewcollection-delegate-wrong-events: All event names must be strings.", this);
            }
            return {
              to: (e2) => {
                for (const i2 of this) {
                  for (const n2 of t2) {
                    i2.delegate(n2).to(e2);
                  }
                }
                this.on("add", (i2, n2) => {
                  for (const i3 of t2) {
                    n2.delegate(i3).to(e2);
                  }
                });
                this.on("remove", (i2, n2) => {
                  for (const i3 of t2) {
                    n2.stopDelegating(i3, e2);
                  }
                });
              }
            };
          }
        }
        function wp(t2) {
          return t2.every((t3) => typeof t3 == "string");
        }
        const kp = "http://www.w3.org/1999/xhtml";
        class _p {
          constructor(t2) {
            Object.assign(this, Op(Rp(t2)));
            this._isRendered = false;
            this._revertData = null;
          }
          render() {
            const t2 = this._renderNode({intoFragment: true});
            this._isRendered = true;
            return t2;
          }
          apply(t2) {
            this._revertData = qp();
            this._renderNode({node: t2, isApplying: true, revertData: this._revertData});
            return t2;
          }
          revert(t2) {
            if (!this._revertData) {
              throw new ss["b"]("ui-template-revert-not-applied: Attempting to revert a template which has not been applied yet.", [this, t2]);
            }
            this._revertTemplateFromNode(t2, this._revertData);
          }
          *getViews() {
            function* t2(e2) {
              if (e2.children) {
                for (const i2 of e2.children) {
                  if (jp(i2)) {
                    yield i2;
                  } else if (Hp(i2)) {
                    yield* t2(i2);
                  }
                }
              }
            }
            yield* t2(this);
          }
          static bind(t2, e2) {
            return {
              to(i2, n2) {
                return new yp({eventNameOrFunction: i2, attribute: i2, observable: t2, emitter: e2, callback: n2});
              },
              if(i2, n2, o2) {
                return new xp({observable: t2, emitter: e2, attribute: i2, valueIfTrue: n2, callback: o2});
              }
            };
          }
          static extend(t2, e2) {
            if (t2._isRendered) {
              throw new ss["b"]("template-extend-render: Attempting to extend a template which has already been rendered.", [this, t2]);
            }
            Fp(t2, Op(Rp(e2)));
          }
          _renderNode(t2) {
            let e2;
            if (t2.node) {
              e2 = this.tag && this.text;
            } else {
              e2 = this.tag ? this.text : !this.text;
            }
            if (e2) {
              throw new ss["b"]('ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering a new Node.', this);
            }
            if (this.text) {
              return this._renderText(t2);
            } else {
              return this._renderElement(t2);
            }
          }
          _renderElement(t2) {
            let e2 = t2.node;
            if (!e2) {
              e2 = t2.node = document.createElementNS(this.ns || kp, this.tag);
            }
            this._renderAttributes(t2);
            this._renderElementChildren(t2);
            this._setUpListeners(t2);
            return e2;
          }
          _renderText(t2) {
            let e2 = t2.node;
            if (e2) {
              t2.revertData.text = e2.textContent;
            } else {
              e2 = t2.node = document.createTextNode("");
            }
            if (Cp(this.text)) {
              this._bindToObservable({schema: this.text, updater: Pp(e2), data: t2});
            } else {
              e2.textContent = this.text.join("");
            }
            return e2;
          }
          _renderAttributes(t2) {
            let e2, i2, n2, o2;
            if (!this.attributes) {
              return;
            }
            const r2 = t2.node;
            const s2 = t2.revertData;
            for (e2 in this.attributes) {
              n2 = r2.getAttribute(e2);
              i2 = this.attributes[e2];
              if (s2) {
                s2.attributes[e2] = n2;
              }
              o2 = ct(i2[0]) && i2[0].ns ? i2[0].ns : null;
              if (Cp(i2)) {
                const a2 = o2 ? i2[0].value : i2;
                if (s2 && Up(e2)) {
                  a2.unshift(n2);
                }
                this._bindToObservable({schema: a2, updater: Sp(r2, e2, o2), data: t2});
              } else if (e2 == "style" && typeof i2[0] !== "string") {
                this._renderStyleAttribute(i2[0], t2);
              } else {
                if (s2 && n2 && Up(e2)) {
                  i2.unshift(n2);
                }
                i2 = i2.map((t3) => t3 ? t3.value || t3 : t3).reduce((t3, e3) => t3.concat(e3), []).reduce(zp, "");
                if (!Dp(i2)) {
                  r2.setAttributeNS(o2, e2, i2);
                }
              }
            }
          }
          _renderStyleAttribute(t2, e2) {
            const i2 = e2.node;
            for (const n2 in t2) {
              const o2 = t2[n2];
              if (Cp(o2)) {
                this._bindToObservable({schema: [o2], updater: Ep(i2, n2), data: e2});
              } else {
                i2.style[n2] = o2;
              }
            }
          }
          _renderElementChildren(t2) {
            const e2 = t2.node;
            const i2 = t2.intoFragment ? document.createDocumentFragment() : e2;
            const n2 = t2.isApplying;
            let o2 = 0;
            for (const r2 of this.children) {
              if (Wp(r2)) {
                if (!n2) {
                  r2.setParent(e2);
                  for (const t3 of r2) {
                    i2.appendChild(t3.element);
                  }
                }
              } else if (jp(r2)) {
                if (!n2) {
                  if (!r2.isRendered) {
                    r2.render();
                  }
                  i2.appendChild(r2.element);
                }
              } else if (xd(r2)) {
                i2.appendChild(r2);
              } else {
                if (n2) {
                  const e3 = t2.revertData;
                  const n3 = qp();
                  e3.children.push(n3);
                  r2._renderNode({node: i2.childNodes[o2++], isApplying: true, revertData: n3});
                } else {
                  i2.appendChild(r2.render());
                }
              }
            }
            if (t2.intoFragment) {
              e2.appendChild(i2);
            }
          }
          _setUpListeners(t2) {
            if (!this.eventListeners) {
              return;
            }
            for (const e2 in this.eventListeners) {
              const i2 = this.eventListeners[e2].map((i3) => {
                const [n2, o2] = e2.split("@");
                return i3.activateDomEventListener(n2, o2, t2);
              });
              if (t2.revertData) {
                t2.revertData.bindings.push(i2);
              }
            }
          }
          _bindToObservable({schema: t2, updater: e2, data: i2}) {
            const n2 = i2.revertData;
            Tp(t2, e2, i2);
            const o2 = t2.filter((t3) => !Dp(t3)).filter((t3) => t3.observable).map((n3) => n3.activateAttributeListener(t2, e2, i2));
            if (n2) {
              n2.bindings.push(o2);
            }
          }
          _revertTemplateFromNode(t2, e2) {
            for (const t3 of e2.bindings) {
              for (const e3 of t3) {
                e3();
              }
            }
            if (e2.text) {
              t2.textContent = e2.text;
              return;
            }
            for (const i2 in e2.attributes) {
              const n2 = e2.attributes[i2];
              if (n2 === null) {
                t2.removeAttribute(i2);
              } else {
                t2.setAttribute(i2, n2);
              }
            }
            for (let i2 = 0; i2 < e2.children.length; ++i2) {
              this._revertTemplateFromNode(t2.childNodes[i2], e2.children[i2]);
            }
          }
        }
        vs(_p, ds);
        class vp {
          constructor(t2) {
            Object.assign(this, t2);
          }
          getValue(t2) {
            const e2 = this.observable[this.attribute];
            return this.callback ? this.callback(e2, t2) : e2;
          }
          activateAttributeListener(t2, e2, i2) {
            const n2 = () => Tp(t2, e2, i2);
            this.emitter.listenTo(this.observable, "change:" + this.attribute, n2);
            return () => {
              this.emitter.stopListening(this.observable, "change:" + this.attribute, n2);
            };
          }
        }
        class yp extends vp {
          activateDomEventListener(t2, e2, i2) {
            const n2 = (t3, i3) => {
              if (!e2 || i3.target.matches(e2)) {
                if (typeof this.eventNameOrFunction == "function") {
                  this.eventNameOrFunction(i3);
                } else {
                  this.observable.fire(this.eventNameOrFunction, i3);
                }
              }
            };
            this.emitter.listenTo(i2.node, t2, n2);
            return () => {
              this.emitter.stopListening(i2.node, t2, n2);
            };
          }
        }
        class xp extends vp {
          getValue(t2) {
            const e2 = super.getValue(t2);
            return Dp(e2) ? false : this.valueIfTrue || true;
          }
        }
        function Cp(t2) {
          if (!t2) {
            return false;
          }
          if (t2.value) {
            t2 = t2.value;
          }
          if (Array.isArray(t2)) {
            return t2.some(Cp);
          } else if (t2 instanceof vp) {
            return true;
          }
          return false;
        }
        function Ap(t2, e2) {
          return t2.map((t3) => {
            if (t3 instanceof vp) {
              return t3.getValue(e2);
            }
            return t3;
          });
        }
        function Tp(t2, e2, {node: i2}) {
          let n2 = Ap(t2, i2);
          if (t2.length == 1 && t2[0] instanceof xp) {
            n2 = n2[0];
          } else {
            n2 = n2.reduce(zp, "");
          }
          if (Dp(n2)) {
            e2.remove();
          } else {
            e2.set(n2);
          }
        }
        function Pp(t2) {
          return {
            set(e2) {
              t2.textContent = e2;
            },
            remove() {
              t2.textContent = "";
            }
          };
        }
        function Sp(t2, e2, i2) {
          return {
            set(n2) {
              t2.setAttributeNS(i2, e2, n2);
            },
            remove() {
              t2.removeAttributeNS(i2, e2);
            }
          };
        }
        function Ep(t2, e2) {
          return {
            set(i2) {
              t2.style[e2] = i2;
            },
            remove() {
              t2.style[e2] = null;
            }
          };
        }
        function Rp(t2) {
          const e2 = $r(t2, (t3) => {
            if (t3 && (t3 instanceof vp || Hp(t3) || jp(t3) || Wp(t3))) {
              return t3;
            }
          });
          return e2;
        }
        function Op(t2) {
          if (typeof t2 == "string") {
            t2 = Np(t2);
          } else if (t2.text) {
            Mp(t2);
          }
          if (t2.on) {
            t2.eventListeners = Vp(t2.on);
            delete t2.on;
          }
          if (!t2.text) {
            if (t2.attributes) {
              Ip(t2.attributes);
            }
            const e2 = [];
            if (t2.children) {
              if (Wp(t2.children)) {
                e2.push(t2.children);
              } else {
                for (const i2 of t2.children) {
                  if (Hp(i2) || jp(i2) || xd(i2)) {
                    e2.push(i2);
                  } else {
                    e2.push(new _p(i2));
                  }
                }
              }
            }
            t2.children = e2;
          }
          return t2;
        }
        function Ip(t2) {
          for (const e2 in t2) {
            if (t2[e2].value) {
              t2[e2].value = [].concat(t2[e2].value);
            }
            Bp(t2, e2);
          }
        }
        function Vp(t2) {
          for (const e2 in t2) {
            Bp(t2, e2);
          }
          return t2;
        }
        function Np(t2) {
          return {text: [t2]};
        }
        function Mp(t2) {
          if (!Array.isArray(t2.text)) {
            t2.text = [t2.text];
          }
        }
        function Bp(t2, e2) {
          if (!Array.isArray(t2[e2])) {
            t2[e2] = [t2[e2]];
          }
        }
        function zp(t2, e2) {
          if (Dp(e2)) {
            return t2;
          } else if (Dp(t2)) {
            return e2;
          } else {
            return `${t2} ${e2}`;
          }
        }
        function Lp(t2, e2) {
          for (const i2 in e2) {
            if (t2[i2]) {
              t2[i2].push(...e2[i2]);
            } else {
              t2[i2] = e2[i2];
            }
          }
        }
        function Fp(t2, e2) {
          if (e2.attributes) {
            if (!t2.attributes) {
              t2.attributes = {};
            }
            Lp(t2.attributes, e2.attributes);
          }
          if (e2.eventListeners) {
            if (!t2.eventListeners) {
              t2.eventListeners = {};
            }
            Lp(t2.eventListeners, e2.eventListeners);
          }
          if (e2.text) {
            t2.text.push(...e2.text);
          }
          if (e2.children && e2.children.length) {
            if (t2.children.length != e2.children.length) {
              throw new ss["b"]("ui-template-extend-children-mismatch: The number of children in extended definition does not match.", t2);
            }
            let i2 = 0;
            for (const n2 of e2.children) {
              Fp(t2.children[i2++], n2);
            }
          }
        }
        function Dp(t2) {
          return !t2 && t2 !== 0;
        }
        function jp(t2) {
          return t2 instanceof Gp;
        }
        function Hp(t2) {
          return t2 instanceof _p;
        }
        function Wp(t2) {
          return t2 instanceof bp;
        }
        function qp() {
          return {children: [], bindings: [], attributes: {}};
        }
        function Up(t2) {
          return t2 == "class" || t2 == "style";
        }
        var $p = i(15);
        class Gp {
          constructor(t2) {
            this.element = null;
            this.isRendered = false;
            this.locale = t2;
            this.t = t2 && t2.t;
            this._viewCollections = new ys();
            this._unboundChildren = this.createCollection();
            this._viewCollections.on("add", (e2, i2) => {
              i2.locale = t2;
            });
            this.decorate("render");
          }
          get bindTemplate() {
            if (this._bindTemplate) {
              return this._bindTemplate;
            }
            return this._bindTemplate = _p.bind(this, this);
          }
          createCollection() {
            const t2 = new bp();
            this._viewCollections.add(t2);
            return t2;
          }
          registerChild(t2) {
            if (!js(t2)) {
              t2 = [t2];
            }
            for (const e2 of t2) {
              this._unboundChildren.add(e2);
            }
          }
          deregisterChild(t2) {
            if (!js(t2)) {
              t2 = [t2];
            }
            for (const e2 of t2) {
              this._unboundChildren.remove(e2);
            }
          }
          setTemplate(t2) {
            this.template = new _p(t2);
          }
          extendTemplate(t2) {
            _p.extend(this.template, t2);
          }
          render() {
            if (this.isRendered) {
              throw new ss["b"]("ui-view-render-already-rendered: This View has already been rendered.", this);
            }
            if (this.template) {
              this.element = this.template.render();
              this.registerChild(this.template.getViews());
            }
            this.isRendered = true;
          }
          destroy() {
            this.stopListening();
            this._viewCollections.map((t2) => t2.destroy());
            if (this.template && this.template._revertData) {
              this.template.revert(this.element);
            }
          }
        }
        vs(Gp, qd);
        vs(Gp, Jc);
        function Kp(t2) {
          while (t2 && t2.tagName.toLowerCase() != "html") {
            if (Id.window.getComputedStyle(t2).position != "static") {
              return t2;
            }
            t2 = t2.parentElement;
          }
          return null;
        }
        function Jp({element: t2, target: e2, positions: i2, limiter: n2, fitInViewport: o2}) {
          if (gt(e2)) {
            e2 = e2();
          }
          if (gt(n2)) {
            n2 = n2();
          }
          const r2 = Kp(t2.parentElement);
          const s2 = new vh(t2);
          const a2 = new vh(e2);
          let c2;
          let l2;
          if (!n2 && !o2) {
            [l2, c2] = Yp(i2[0], a2, s2);
          } else {
            const t3 = n2 && new vh(n2).getVisible();
            const e3 = o2 && new vh(Id.window);
            [l2, c2] = Qp(i2, a2, s2, t3, e3) || Yp(i2[0], a2, s2);
          }
          let {left: d2, top: u2} = Xp(c2);
          if (r2) {
            const t3 = Xp(new vh(r2));
            const e3 = kh(r2);
            d2 -= t3.left;
            u2 -= t3.top;
            d2 += r2.scrollLeft;
            u2 += r2.scrollTop;
            d2 -= e3.left;
            u2 -= e3.top;
          }
          return {left: d2, top: u2, name: l2};
        }
        function Yp(t2, e2, i2) {
          const {left: n2, top: o2, name: r2} = t2(e2, i2);
          return [r2, i2.clone().moveTo(n2, o2)];
        }
        function Qp(t2, e2, i2, n2, o2) {
          let r2 = 0;
          let s2 = 0;
          let a2;
          let c2;
          const l2 = i2.getArea();
          t2.some((t3) => {
            const [d2, u2] = Yp(t3, e2, i2);
            let h2;
            let f2;
            if (n2) {
              if (o2) {
                const t4 = n2.getIntersection(o2);
                if (t4) {
                  h2 = t4.getIntersectionArea(u2);
                } else {
                  h2 = 0;
                }
              } else {
                h2 = n2.getIntersectionArea(u2);
              }
            }
            if (o2) {
              f2 = o2.getIntersectionArea(u2);
            }
            if (o2 && !n2) {
              if (f2 > s2) {
                g2();
              }
            } else if (!o2 && n2) {
              if (h2 > r2) {
                g2();
              }
            } else {
              if (f2 > s2 && h2 >= r2) {
                g2();
              } else if (f2 >= s2 && h2 > r2) {
                g2();
              }
            }
            function g2() {
              s2 = f2;
              r2 = h2;
              a2 = u2;
              c2 = d2;
            }
            return h2 === l2;
          });
          return a2 ? [c2, a2] : null;
        }
        function Xp({left: t2, top: e2}) {
          const {scrollX: i2, scrollY: n2} = Id.window;
          return {left: t2 + i2, top: e2 + n2};
        }
        function Zp(t2) {
          return (e2) => e2 + t2;
        }
        var tb = i(17);
        const eb = Zp("px");
        const ib = Id.document.body;
        class nb extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("top", 0);
            this.set("left", 0);
            this.set("position", "arrow_nw");
            this.set("isVisible", false);
            this.set("withArrow", true);
            this.set("class");
            this.content = this.createCollection();
            this.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-balloon-panel", e2.to("position", (t3) => `ck-balloon-panel_${t3}`), e2.if("isVisible", "ck-balloon-panel_visible"), e2.if("withArrow", "ck-balloon-panel_with-arrow"), e2.to("class")],
                style: {top: e2.to("top", eb), left: e2.to("left", eb)}
              },
              children: this.content
            });
          }
          show() {
            this.isVisible = true;
          }
          hide() {
            this.isVisible = false;
          }
          attachTo(t2) {
            this.show();
            const e2 = nb.defaultPositions;
            const i2 = Object.assign({}, {
              element: this.element,
              positions: [e2.southArrowNorth, e2.southArrowNorthMiddleWest, e2.southArrowNorthMiddleEast, e2.southArrowNorthWest, e2.southArrowNorthEast, e2.northArrowSouth, e2.northArrowSouthMiddleWest, e2.northArrowSouthMiddleEast, e2.northArrowSouthWest, e2.northArrowSouthEast],
              limiter: ib,
              fitInViewport: true
            }, t2);
            const n2 = nb._getOptimalPosition(i2);
            const o2 = parseInt(n2.left);
            const r2 = parseInt(n2.top);
            const s2 = n2.name;
            Object.assign(this, {top: r2, left: o2, position: s2});
          }
          pin(t2) {
            this.unpin();
            this._pinWhenIsVisibleCallback = () => {
              if (this.isVisible) {
                this._startPinning(t2);
              } else {
                this._stopPinning();
              }
            };
            this._startPinning(t2);
            this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
          }
          unpin() {
            if (this._pinWhenIsVisibleCallback) {
              this._stopPinning();
              this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
              this._pinWhenIsVisibleCallback = null;
              this.hide();
            }
          }
          _startPinning(t2) {
            this.attachTo(t2);
            const e2 = ob(t2.target);
            const i2 = t2.limiter ? ob(t2.limiter) : ib;
            this.listenTo(Id.document, "scroll", (n2, o2) => {
              const r2 = o2.target;
              const s2 = e2 && r2.contains(e2);
              const a2 = i2 && r2.contains(i2);
              if (s2 || a2 || !e2 || !i2) {
                this.attachTo(t2);
              }
            }, {useCapture: true});
            this.listenTo(Id.window, "resize", () => {
              this.attachTo(t2);
            });
          }
          _stopPinning() {
            this.stopListening(Id.document, "scroll");
            this.stopListening(Id.window, "resize");
          }
        }
        function ob(t2) {
          if (Kr(t2)) {
            return t2;
          }
          if (wh(t2)) {
            return t2.commonAncestorContainer;
          }
          if (typeof t2 == "function") {
            return ob(t2());
          }
          return null;
        }
        nb.arrowHorizontalOffset = 25;
        nb.arrowVerticalOffset = 10;
        nb._getOptimalPosition = Jp;
        nb.defaultPositions = {
          northWestArrowSouthWest: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.left - nb.arrowHorizontalOffset,
            name: "arrow_sw"
          }),
          northWestArrowSouthMiddleWest: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.left - e2.width * 0.25 - nb.arrowHorizontalOffset,
            name: "arrow_smw"
          }),
          northWestArrowSouth: (t2, e2) => ({top: rb(t2, e2), left: t2.left - e2.width / 2, name: "arrow_s"}),
          northWestArrowSouthMiddleEast: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.left - e2.width * 0.75 + nb.arrowHorizontalOffset,
            name: "arrow_sme"
          }),
          northWestArrowSouthEast: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.left - e2.width + nb.arrowHorizontalOffset,
            name: "arrow_se"
          }),
          northArrowSouthWest: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.left + t2.width / 2 - nb.arrowHorizontalOffset,
            name: "arrow_sw"
          }),
          northArrowSouthMiddleWest: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.left + t2.width / 2 - e2.width * 0.25 - nb.arrowHorizontalOffset,
            name: "arrow_smw"
          }),
          northArrowSouth: (t2, e2) => ({top: rb(t2, e2), left: t2.left + t2.width / 2 - e2.width / 2, name: "arrow_s"}),
          northArrowSouthMiddleEast: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.left + t2.width / 2 - e2.width * 0.75 + nb.arrowHorizontalOffset,
            name: "arrow_sme"
          }),
          northArrowSouthEast: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.left + t2.width / 2 - e2.width + nb.arrowHorizontalOffset,
            name: "arrow_se"
          }),
          northEastArrowSouthWest: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.right - nb.arrowHorizontalOffset,
            name: "arrow_sw"
          }),
          northEastArrowSouthMiddleWest: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.right - e2.width * 0.25 - nb.arrowHorizontalOffset,
            name: "arrow_smw"
          }),
          northEastArrowSouth: (t2, e2) => ({top: rb(t2, e2), left: t2.right - e2.width / 2, name: "arrow_s"}),
          northEastArrowSouthMiddleEast: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.right - e2.width * 0.75 + nb.arrowHorizontalOffset,
            name: "arrow_sme"
          }),
          northEastArrowSouthEast: (t2, e2) => ({
            top: rb(t2, e2),
            left: t2.right - e2.width + nb.arrowHorizontalOffset,
            name: "arrow_se"
          }),
          southWestArrowNorthWest: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.left - nb.arrowHorizontalOffset,
            name: "arrow_nw"
          }),
          southWestArrowNorthMiddleWest: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.left - e2.width * 0.25 - nb.arrowHorizontalOffset,
            name: "arrow_nmw"
          }),
          southWestArrowNorth: (t2, e2) => ({top: sb(t2, e2), left: t2.left - e2.width / 2, name: "arrow_n"}),
          southWestArrowNorthMiddleEast: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.left - e2.width * 0.75 + nb.arrowHorizontalOffset,
            name: "arrow_nme"
          }),
          southWestArrowNorthEast: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.left - e2.width + nb.arrowHorizontalOffset,
            name: "arrow_ne"
          }),
          southArrowNorthWest: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.left + t2.width / 2 - nb.arrowHorizontalOffset,
            name: "arrow_nw"
          }),
          southArrowNorthMiddleWest: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.left + t2.width / 2 - e2.width * 0.25 - nb.arrowHorizontalOffset,
            name: "arrow_nmw"
          }),
          southArrowNorth: (t2, e2) => ({top: sb(t2, e2), left: t2.left + t2.width / 2 - e2.width / 2, name: "arrow_n"}),
          southArrowNorthMiddleEast: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.left + t2.width / 2 - e2.width * 0.75 + nb.arrowHorizontalOffset,
            name: "arrow_nme"
          }),
          southArrowNorthEast: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.left + t2.width / 2 - e2.width + nb.arrowHorizontalOffset,
            name: "arrow_ne"
          }),
          southEastArrowNorthWest: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.right - nb.arrowHorizontalOffset,
            name: "arrow_nw"
          }),
          southEastArrowNorthMiddleWest: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.right - e2.width * 0.25 - nb.arrowHorizontalOffset,
            name: "arrow_nmw"
          }),
          southEastArrowNorth: (t2, e2) => ({top: sb(t2, e2), left: t2.right - e2.width / 2, name: "arrow_n"}),
          southEastArrowNorthMiddleEast: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.right - e2.width * 0.75 + nb.arrowHorizontalOffset,
            name: "arrow_nme"
          }),
          southEastArrowNorthEast: (t2, e2) => ({
            top: sb(t2, e2),
            left: t2.right - e2.width + nb.arrowHorizontalOffset,
            name: "arrow_ne"
          })
        };
        function rb(t2, e2) {
          return t2.top - e2.height - nb.arrowVerticalOffset;
        }
        function sb(t2) {
          return t2.bottom + nb.arrowVerticalOffset;
        }
        var ab = i(19);
        class cb extends Gp {
          constructor() {
            super();
            const t2 = this.bindTemplate;
            this.set("content", "");
            this.set("viewBox", "0 0 20 20");
            this.set("fillColor", "");
            this.setTemplate({
              tag: "svg",
              ns: "http://www.w3.org/2000/svg",
              attributes: {class: ["ck", "ck-icon"], viewBox: t2.to("viewBox")}
            });
          }
          render() {
            super.render();
            this._updateXMLContent();
            this._colorFillPaths();
            this.on("change:content", () => {
              this._updateXMLContent();
              this._colorFillPaths();
            });
            this.on("change:fillColor", () => {
              this._colorFillPaths();
            });
          }
          _updateXMLContent() {
            if (this.content) {
              const t2 = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
              const e2 = t2.querySelector("svg");
              const i2 = e2.getAttribute("viewBox");
              if (i2) {
                this.viewBox = i2;
              }
              this.element.innerHTML = "";
              while (e2.childNodes.length > 0) {
                this.element.appendChild(e2.childNodes[0]);
              }
            }
          }
          _colorFillPaths() {
            if (this.fillColor) {
              this.element.querySelectorAll(".ck-icon__fill").forEach((t2) => {
                t2.style.fill = this.fillColor;
              });
            }
          }
        }
        var lb = i(21);
        class db extends Gp {
          constructor(t2) {
            super(t2);
            this.set("text", "");
            this.set("position", "s");
            const e2 = this.bindTemplate;
            this.setTemplate({
              tag: "span",
              attributes: {class: ["ck", "ck-tooltip", e2.to("position", (t3) => "ck-tooltip_" + t3), e2.if("text", "ck-hidden", (t3) => !t3.trim())]},
              children: [{
                tag: "span",
                attributes: {class: ["ck", "ck-tooltip__text"]},
                children: [{text: e2.to("text")}]
              }]
            });
          }
        }
        var ub = i(23);
        class hb extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            const i2 = is();
            this.set("class");
            this.set("labelStyle");
            this.set("icon");
            this.set("isEnabled", true);
            this.set("isOn", false);
            this.set("isVisible", true);
            this.set("isToggleable", false);
            this.set("keystroke");
            this.set("label");
            this.set("tabindex", -1);
            this.set("tooltip");
            this.set("tooltipPosition", "s");
            this.set("type", "button");
            this.set("withText", false);
            this.set("withKeystroke", false);
            this.children = this.createCollection();
            this.tooltipView = this._createTooltipView();
            this.labelView = this._createLabelView(i2);
            this.iconView = new cb();
            this.iconView.extendTemplate({attributes: {class: "ck-button__icon"}});
            this.keystrokeView = this._createKeystrokeView();
            this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
            this.setTemplate({
              tag: "button",
              attributes: {
                class: ["ck", "ck-button", e2.to("class"), e2.if("isEnabled", "ck-disabled", (t3) => !t3), e2.if("isVisible", "ck-hidden", (t3) => !t3), e2.to("isOn", (t3) => t3 ? "ck-on" : "ck-off"), e2.if("withText", "ck-button_with-text"), e2.if("withKeystroke", "ck-button_with-keystroke")],
                type: e2.to("type", (t3) => t3 ? t3 : "button"),
                tabindex: e2.to("tabindex"),
                "aria-labelledby": `ck-editor__aria-label_${i2}`,
                "aria-disabled": e2.if("isEnabled", true, (t3) => !t3),
                "aria-pressed": e2.to("isOn", (t3) => this.isToggleable ? String(t3) : false)
              },
              children: this.children,
              on: {
                mousedown: e2.to((t3) => {
                  t3.preventDefault();
                }),
                click: e2.to((t3) => {
                  if (this.isEnabled) {
                    this.fire("execute");
                  } else {
                    t3.preventDefault();
                  }
                })
              }
            });
          }
          render() {
            super.render();
            if (this.icon) {
              this.iconView.bind("content").to(this, "icon");
              this.children.add(this.iconView);
            }
            this.children.add(this.tooltipView);
            this.children.add(this.labelView);
            if (this.withKeystroke) {
              this.children.add(this.keystrokeView);
            }
          }
          focus() {
            this.element.focus();
          }
          _createTooltipView() {
            const t2 = new db();
            t2.bind("text").to(this, "_tooltipString");
            t2.bind("position").to(this, "tooltipPosition");
            return t2;
          }
          _createLabelView(t2) {
            const e2 = new Gp();
            const i2 = this.bindTemplate;
            e2.setTemplate({
              tag: "span",
              attributes: {
                class: ["ck", "ck-button__label"],
                style: i2.to("labelStyle"),
                id: `ck-editor__aria-label_${t2}`
              },
              children: [{text: this.bindTemplate.to("label")}]
            });
            return e2;
          }
          _createKeystrokeView() {
            const t2 = new Gp();
            t2.setTemplate({
              tag: "span",
              attributes: {class: ["ck", "ck-button__keystroke"]},
              children: [{text: this.bindTemplate.to("keystroke", (t3) => zl(t3))}]
            });
            return t2;
          }
          _getTooltipString(t2, e2, i2) {
            if (t2) {
              if (typeof t2 == "string") {
                return t2;
              } else {
                if (i2) {
                  i2 = zl(i2);
                }
                if (t2 instanceof Function) {
                  return t2(e2, i2);
                } else {
                  return `${e2}${i2 ? ` (${i2})` : ""}`;
                }
              }
            }
            return "";
          }
        }
        class fb {
          constructor() {
            this.set("isFocused", false);
            this.set("focusedElement", null);
            this._elements = new Set();
            this._nextEventLoopTimeout = null;
          }
          add(t2) {
            if (this._elements.has(t2)) {
              throw new ss["b"]("focusTracker-add-element-already-exist", this);
            }
            this.listenTo(t2, "focus", () => this._focus(t2), {useCapture: true});
            this.listenTo(t2, "blur", () => this._blur(), {useCapture: true});
            this._elements.add(t2);
          }
          remove(t2) {
            if (t2 === this.focusedElement) {
              this._blur(t2);
            }
            if (this._elements.has(t2)) {
              this.stopListening(t2);
              this._elements.delete(t2);
            }
          }
          destroy() {
            this.stopListening();
          }
          _focus(t2) {
            clearTimeout(this._nextEventLoopTimeout);
            this.focusedElement = t2;
            this.isFocused = true;
          }
          _blur() {
            clearTimeout(this._nextEventLoopTimeout);
            this._nextEventLoopTimeout = setTimeout(() => {
              this.focusedElement = null;
              this.isFocused = false;
            }, 0);
          }
        }
        vs(fb, qd);
        vs(fb, Jc);
        var gb = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
        var mb = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
        var pb = i(25);
        var bb = i(27);
        const wb = Zp("px");
        class kb extends mp {
          static get pluginName() {
            return "ContextualBalloon";
          }
          constructor(t2) {
            super(t2);
            this.positionLimiter = () => {
              const t3 = this.editor.editing.view;
              const e2 = t3.document;
              const i2 = e2.selection.editableElement;
              if (i2) {
                return t3.domConverter.mapViewToDom(i2.root);
              }
              return null;
            };
            this.set("visibleView", null);
            this.view = new nb(t2.locale);
            t2.ui.view.body.add(this.view);
            t2.ui.focusTracker.add(this.view.element);
            this._viewToStack = new Map();
            this._idToStack = new Map();
            this.set("_numberOfStacks", 0);
            this.set("_singleViewMode", false);
            this._rotatorView = this._createRotatorView();
            this._fakePanelsView = this._createFakePanelsView();
          }
          hasView(t2) {
            return Array.from(this._viewToStack.keys()).includes(t2);
          }
          add(t2) {
            if (this.hasView(t2.view)) {
              throw new ss["b"]("contextualballoon-add-view-exist: Cannot add configuration of the same view twice.", [this, t2]);
            }
            const e2 = t2.stackId || "main";
            if (!this._idToStack.has(e2)) {
              this._idToStack.set(e2, new Map([[t2.view, t2]]));
              this._viewToStack.set(t2.view, this._idToStack.get(e2));
              this._numberOfStacks = this._idToStack.size;
              if (!this._visibleStack || t2.singleViewMode) {
                this.showStack(e2);
              }
              return;
            }
            const i2 = this._idToStack.get(e2);
            if (t2.singleViewMode) {
              this.showStack(e2);
            }
            i2.set(t2.view, t2);
            this._viewToStack.set(t2.view, i2);
            if (i2 === this._visibleStack) {
              this._showView(t2);
            }
          }
          remove(t2) {
            if (!this.hasView(t2)) {
              throw new ss["b"]("contextualballoon-remove-view-not-exist: Cannot remove the configuration of a non-existent view.", [this, t2]);
            }
            const e2 = this._viewToStack.get(t2);
            if (this._singleViewMode && this.visibleView === t2) {
              this._singleViewMode = false;
            }
            if (this.visibleView === t2) {
              if (e2.size === 1) {
                if (this._idToStack.size > 1) {
                  this._showNextStack();
                } else {
                  this.view.hide();
                  this.visibleView = null;
                  this._rotatorView.hideView();
                }
              } else {
                this._showView(Array.from(e2.values())[e2.size - 2]);
              }
            }
            if (e2.size === 1) {
              this._idToStack.delete(this._getStackId(e2));
              this._numberOfStacks = this._idToStack.size;
            } else {
              e2.delete(t2);
            }
            this._viewToStack.delete(t2);
          }
          updatePosition(t2) {
            if (t2) {
              this._visibleStack.get(this.visibleView).position = t2;
            }
            this.view.pin(this._getBalloonPosition());
            this._fakePanelsView.updatePosition();
          }
          showStack(t2) {
            this.visibleStack = t2;
            const e2 = this._idToStack.get(t2);
            if (!e2) {
              throw new ss["b"]("contextualballoon-showstack-stack-not-exist: Cannot show a stack that does not exist.", this);
            }
            if (this._visibleStack === e2) {
              return;
            }
            this._showView(Array.from(e2.values()).pop());
          }
          get _visibleStack() {
            return this._viewToStack.get(this.visibleView);
          }
          _getStackId(t2) {
            const e2 = Array.from(this._idToStack.entries()).find((e3) => e3[1] === t2);
            return e2[0];
          }
          _showNextStack() {
            const t2 = Array.from(this._idToStack.values());
            let e2 = t2.indexOf(this._visibleStack) + 1;
            if (!t2[e2]) {
              e2 = 0;
            }
            this.showStack(this._getStackId(t2[e2]));
          }
          _showPrevStack() {
            const t2 = Array.from(this._idToStack.values());
            let e2 = t2.indexOf(this._visibleStack) - 1;
            if (!t2[e2]) {
              e2 = t2.length - 1;
            }
            this.showStack(this._getStackId(t2[e2]));
          }
          _createRotatorView() {
            const t2 = new _b(this.editor.locale);
            const e2 = this.editor.locale.t;
            this.view.content.add(t2);
            t2.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (t3, e3) => !e3 && t3 > 1);
            t2.on("change:isNavigationVisible", () => this.updatePosition(), {priority: "low"});
            t2.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (t3, i2) => {
              if (i2 < 2) {
                return "";
              }
              const n2 = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
              return e2("lu", [n2, i2]);
            });
            t2.buttonNextView.on("execute", () => {
              if (t2.focusTracker.isFocused) {
                this.editor.editing.view.focus();
              }
              this._showNextStack();
            });
            t2.buttonPrevView.on("execute", () => {
              if (t2.focusTracker.isFocused) {
                this.editor.editing.view.focus();
              }
              this._showPrevStack();
            });
            return t2;
          }
          _createFakePanelsView() {
            const t2 = new vb(this.editor.locale, this.view);
            t2.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t3, e2) => {
              const i2 = !e2 && t3 >= 2;
              return i2 ? Math.min(t3 - 1, 2) : 0;
            });
            t2.listenTo(this.view, "change:top", () => t2.updatePosition());
            t2.listenTo(this.view, "change:left", () => t2.updatePosition());
            this.editor.ui.view.body.add(t2);
            return t2;
          }
          _showView({view: t2, balloonClassName: e2 = "", withArrow: i2 = true, singleViewMode: n2 = false}) {
            this.view.class = e2;
            this.view.withArrow = i2;
            this._rotatorView.showView(t2);
            this.visibleView = t2;
            this.view.pin(this._getBalloonPosition());
            this._fakePanelsView.updatePosition();
            if (n2) {
              this._singleViewMode = true;
            }
          }
          _getBalloonPosition() {
            let t2 = Array.from(this._visibleStack.values()).pop().position;
            if (t2 && !t2.limiter) {
              t2 = Object.assign({}, t2, {limiter: this.positionLimiter});
            }
            return t2;
          }
        }
        class _b extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = t2.t;
            const i2 = this.bindTemplate;
            this.set("isNavigationVisible", true);
            this.focusTracker = new fb();
            this.buttonPrevView = this._createButtonView(e2("lv"), gb);
            this.buttonNextView = this._createButtonView(e2("lw"), mb);
            this.content = this.createCollection();
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck", "ck-balloon-rotator"], "z-index": "-1"},
              children: [{
                tag: "div",
                attributes: {class: ["ck-balloon-rotator__navigation", i2.to("isNavigationVisible", (t3) => t3 ? "" : "ck-hidden")]},
                children: [this.buttonPrevView, {
                  tag: "span",
                  attributes: {class: ["ck-balloon-rotator__counter"]},
                  children: [{text: i2.to("counter")}]
                }, this.buttonNextView]
              }, {tag: "div", attributes: {class: "ck-balloon-rotator__content"}, children: this.content}]
            });
          }
          render() {
            super.render();
            this.focusTracker.add(this.element);
          }
          showView(t2) {
            this.hideView();
            this.content.add(t2);
          }
          hideView() {
            this.content.clear();
          }
          _createButtonView(t2, e2) {
            const i2 = new hb(this.locale);
            i2.set({label: t2, icon: e2, tooltip: true});
            return i2;
          }
        }
        class vb extends Gp {
          constructor(t2, e2) {
            super(t2);
            const i2 = this.bindTemplate;
            this.set("top", 0);
            this.set("left", 0);
            this.set("height", 0);
            this.set("width", 0);
            this.set("numberOfPanels", 0);
            this.content = this.createCollection();
            this._balloonPanelView = e2;
            this.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck-fake-panel", i2.to("numberOfPanels", (t3) => t3 ? "" : "ck-hidden")],
                style: {
                  top: i2.to("top", wb),
                  left: i2.to("left", wb),
                  width: i2.to("width", wb),
                  height: i2.to("height", wb)
                }
              },
              children: this.content
            });
            this.on("change:numberOfPanels", (t3, e3, i3, n2) => {
              if (i3 > n2) {
                this._addPanels(i3 - n2);
              } else {
                this._removePanels(n2 - i3);
              }
              this.updatePosition();
            });
          }
          _addPanels(t2) {
            while (t2--) {
              const t3 = new Gp();
              t3.setTemplate({tag: "div"});
              this.content.add(t3);
              this.registerChild(t3);
            }
          }
          _removePanels(t2) {
            while (t2--) {
              const t3 = this.content.last;
              this.content.remove(t3);
              this.deregisterChild(t3);
              t3.destroy();
            }
          }
          updatePosition() {
            if (this.numberOfPanels) {
              const {top: t2, left: e2} = this._balloonPanelView;
              const {width: i2, height: n2} = new vh(this._balloonPanelView.element);
              Object.assign(this, {top: t2, left: e2, width: i2, height: n2});
            }
          }
        }
        class yb {
          constructor(t2) {
            Object.assign(this, t2);
            if (t2.actions && t2.keystrokeHandler) {
              for (const e2 in t2.actions) {
                let i2 = t2.actions[e2];
                if (typeof i2 == "string") {
                  i2 = [i2];
                }
                for (const n2 of i2) {
                  t2.keystrokeHandler.set(n2, (t3, i3) => {
                    this[e2]();
                    i3();
                  });
                }
              }
            }
          }
          get first() {
            return this.focusables.find(xb) || null;
          }
          get last() {
            return this.focusables.filter(xb).slice(-1)[0] || null;
          }
          get next() {
            return this._getFocusableItem(1);
          }
          get previous() {
            return this._getFocusableItem(-1);
          }
          get current() {
            let t2 = null;
            if (this.focusTracker.focusedElement === null) {
              return null;
            }
            this.focusables.find((e2, i2) => {
              const n2 = e2.element === this.focusTracker.focusedElement;
              if (n2) {
                t2 = i2;
              }
              return n2;
            });
            return t2;
          }
          focusFirst() {
            this._focus(this.first);
          }
          focusLast() {
            this._focus(this.last);
          }
          focusNext() {
            this._focus(this.next);
          }
          focusPrevious() {
            this._focus(this.previous);
          }
          _focus(t2) {
            if (t2) {
              t2.focus();
            }
          }
          _getFocusableItem(t2) {
            const e2 = this.current;
            const i2 = this.focusables.length;
            if (!i2) {
              return null;
            }
            if (e2 === null) {
              return this[t2 === 1 ? "first" : "last"];
            }
            let n2 = (e2 + i2 + t2) % i2;
            do {
              const e3 = this.focusables.get(n2);
              if (xb(e3)) {
                return e3;
              }
              n2 = (n2 + i2 + t2) % i2;
            } while (n2 !== e2);
            return null;
          }
        }
        function xb(t2) {
          return !!(t2.focus && Id.window.getComputedStyle(t2.element).display != "none");
        }
        class Cb extends Gp {
          constructor(t2) {
            super(t2);
            this.setTemplate({tag: "span", attributes: {class: ["ck", "ck-toolbar__separator"]}});
          }
        }
        const Ab = 100;
        class Tb {
          constructor(t2, e2) {
            if (!Tb._observerInstance) {
              Tb._createObserver();
            }
            this._element = t2;
            this._callback = e2;
            Tb._addElementCallback(t2, e2);
            Tb._observerInstance.observe(t2);
          }
          destroy() {
            Tb._deleteElementCallback(this._element, this._callback);
          }
          static _addElementCallback(t2, e2) {
            if (!Tb._elementCallbacks) {
              Tb._elementCallbacks = new Map();
            }
            let i2 = Tb._elementCallbacks.get(t2);
            if (!i2) {
              i2 = new Set();
              Tb._elementCallbacks.set(t2, i2);
            }
            i2.add(e2);
          }
          static _deleteElementCallback(t2, e2) {
            const i2 = Tb._getElementCallbacks(t2);
            if (i2) {
              i2.delete(e2);
              if (!i2.size) {
                Tb._elementCallbacks.delete(t2);
                Tb._observerInstance.unobserve(t2);
              }
            }
            if (Tb._elementCallbacks && !Tb._elementCallbacks.size) {
              Tb._observerInstance = null;
              Tb._elementCallbacks = null;
            }
          }
          static _getElementCallbacks(t2) {
            if (!Tb._elementCallbacks) {
              return null;
            }
            return Tb._elementCallbacks.get(t2);
          }
          static _createObserver() {
            let t2;
            if (typeof Id.window.ResizeObserver === "function") {
              t2 = Id.window.ResizeObserver;
            } else {
              t2 = Pb;
            }
            Tb._observerInstance = new t2((t3) => {
              for (const e2 of t3) {
                const t4 = Tb._getElementCallbacks(e2.target);
                if (t4) {
                  for (const i2 of t4) {
                    i2(e2);
                  }
                }
              }
            });
          }
        }
        Tb._observerInstance = null;
        Tb._elementCallbacks = null;
        class Pb {
          constructor(t2) {
            this._callback = t2;
            this._elements = new Set();
            this._previousRects = new Map();
            this._periodicCheckTimeout = null;
          }
          observe(t2) {
            this._elements.add(t2);
            this._checkElementRectsAndExecuteCallback();
            if (this._elements.size === 1) {
              this._startPeriodicCheck();
            }
          }
          unobserve(t2) {
            this._elements.delete(t2);
            this._previousRects.delete(t2);
            if (!this._elements.size) {
              this._stopPeriodicCheck();
            }
          }
          _startPeriodicCheck() {
            const t2 = () => {
              this._checkElementRectsAndExecuteCallback();
              this._periodicCheckTimeout = setTimeout(t2, Ab);
            };
            this.listenTo(Id.window, "resize", () => {
              this._checkElementRectsAndExecuteCallback();
            });
            this._periodicCheckTimeout = setTimeout(t2, Ab);
          }
          _stopPeriodicCheck() {
            clearTimeout(this._periodicCheckTimeout);
            this.stopListening();
            this._previousRects.clear();
          }
          _checkElementRectsAndExecuteCallback() {
            const t2 = [];
            for (const e2 of this._elements) {
              if (this._hasRectChanged(e2)) {
                t2.push({target: e2, contentRect: this._previousRects.get(e2)});
              }
            }
            if (t2.length) {
              this._callback(t2);
            }
          }
          _hasRectChanged(t2) {
            if (!t2.ownerDocument.body.contains(t2)) {
              return false;
            }
            const e2 = new vh(t2);
            const i2 = this._previousRects.get(t2);
            const n2 = !i2 || !i2.isEqual(e2);
            this._previousRects.set(t2, e2);
            return n2;
          }
        }
        vs(Pb, qd);
        function Sb(t2) {
          return t2.bindTemplate.to((e2) => {
            if (e2.target === t2.element) {
              e2.preventDefault();
            }
          });
        }
        class Eb extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("isVisible", false);
            this.set("position", "se");
            this.children = this.createCollection();
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck", "ck-reset", "ck-dropdown__panel", e2.to("position", (t3) => `ck-dropdown__panel_${t3}`), e2.if("isVisible", "ck-dropdown__panel-visible")]},
              children: this.children,
              on: {selectstart: e2.to((t3) => t3.preventDefault())}
            });
          }
          focus() {
            if (this.children.length) {
              this.children.first.focus();
            }
          }
          focusLast() {
            if (this.children.length) {
              const t2 = this.children.last;
              if (typeof t2.focusLast === "function") {
                t2.focusLast();
              } else {
                t2.focus();
              }
            }
          }
        }
        var Rb = i(29);
        class Ob extends Gp {
          constructor(t2, e2, i2) {
            super(t2);
            const n2 = this.bindTemplate;
            this.buttonView = e2;
            this.panelView = i2;
            this.set("isOpen", false);
            this.set("isEnabled", true);
            this.set("class");
            this.set("id");
            this.set("panelPosition", "auto");
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-dropdown", n2.to("class"), n2.if("isEnabled", "ck-disabled", (t3) => !t3)],
                id: n2.to("id"),
                "aria-describedby": n2.to("ariaDescribedById")
              },
              children: [e2, i2]
            });
            e2.extendTemplate({attributes: {class: ["ck-dropdown__button"]}});
          }
          render() {
            super.render();
            this.listenTo(this.buttonView, "open", () => {
              this.isOpen = !this.isOpen;
            });
            this.panelView.bind("isVisible").to(this, "isOpen");
            this.on("change:isOpen", () => {
              if (!this.isOpen) {
                return;
              }
              if (this.panelPosition === "auto") {
                this.panelView.position = Ob._getOptimalPosition({
                  element: this.panelView.element,
                  target: this.buttonView.element,
                  fitInViewport: true,
                  positions: this._panelPositions
                }).name;
              } else {
                this.panelView.position = this.panelPosition;
              }
            });
            this.keystrokes.listenTo(this.element);
            this.focusTracker.add(this.element);
            const t2 = (t3, e2) => {
              if (this.isOpen) {
                this.buttonView.focus();
                this.isOpen = false;
                e2();
              }
            };
            this.keystrokes.set("arrowdown", (t3, e2) => {
              if (this.buttonView.isEnabled && !this.isOpen) {
                this.isOpen = true;
                e2();
              }
            });
            this.keystrokes.set("arrowright", (t3, e2) => {
              if (this.isOpen) {
                e2();
              }
            });
            this.keystrokes.set("arrowleft", t2);
            this.keystrokes.set("esc", t2);
          }
          focus() {
            this.buttonView.focus();
          }
          get _panelPositions() {
            const {southEast: t2, southWest: e2, northEast: i2, northWest: n2} = Ob.defaultPanelPositions;
            if (this.locale.uiLanguageDirection === "ltr") {
              return [t2, e2, i2, n2];
            } else {
              return [e2, t2, n2, i2];
            }
          }
        }
        Ob.defaultPanelPositions = {
          southEast: (t2) => ({top: t2.bottom, left: t2.left, name: "se"}),
          southWest: (t2, e2) => ({top: t2.bottom, left: t2.left - e2.width + t2.width, name: "sw"}),
          northEast: (t2, e2) => ({top: t2.top - e2.height, left: t2.left, name: "ne"}),
          northWest: (t2, e2) => ({top: t2.bottom - e2.height, left: t2.left - e2.width + t2.width, name: "nw"})
        };
        Ob._getOptimalPosition = Jp;
        var Ib = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
        class Vb extends hb {
          constructor(t2) {
            super(t2);
            this.arrowView = this._createArrowView();
            this.extendTemplate({attributes: {"aria-haspopup": true}});
            this.delegate("execute").to(this, "open");
          }
          render() {
            super.render();
            this.children.add(this.arrowView);
          }
          _createArrowView() {
            const t2 = new cb();
            t2.content = Ib;
            t2.extendTemplate({attributes: {class: "ck-dropdown__arrow"}});
            return t2;
          }
        }
        var Nb = i(31);
        class Mb extends Gp {
          constructor() {
            super();
            this.items = this.createCollection();
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this._focusCycler = new yb({
              focusables: this.items,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: "arrowup", focusNext: "arrowdown"}
            });
            this.setTemplate({tag: "ul", attributes: {class: ["ck", "ck-reset", "ck-list"]}, children: this.items});
          }
          render() {
            super.render();
            for (const t2 of this.items) {
              this.focusTracker.add(t2.element);
            }
            this.items.on("add", (t2, e2) => {
              this.focusTracker.add(e2.element);
            });
            this.items.on("remove", (t2, e2) => {
              this.focusTracker.remove(e2.element);
            });
            this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
        }
        class Bb extends Gp {
          constructor(t2) {
            super(t2);
            this.children = this.createCollection();
            this.setTemplate({tag: "li", attributes: {class: ["ck", "ck-list__item"]}, children: this.children});
          }
          focus() {
            this.children.first.focus();
          }
        }
        class zb extends Gp {
          constructor(t2) {
            super(t2);
            this.setTemplate({tag: "li", attributes: {class: ["ck", "ck-list__separator"]}});
          }
        }
        var Lb = i(33);
        class Fb extends hb {
          constructor(t2) {
            super(t2);
            this.isToggleable = true;
            this.toggleSwitchView = this._createToggleView();
            this.extendTemplate({attributes: {class: "ck-switchbutton"}});
          }
          render() {
            super.render();
            this.children.add(this.toggleSwitchView);
          }
          _createToggleView() {
            const t2 = new Gp();
            t2.setTemplate({
              tag: "span",
              attributes: {class: ["ck", "ck-button__toggle"]},
              children: [{tag: "span", attributes: {class: ["ck", "ck-button__toggle__inner"]}}]
            });
            return t2;
          }
        }
        function Db({emitter: t2, activator: e2, callback: i2, contextElements: n2}) {
          t2.listenTo(document, "mousedown", (t3, {target: o2}) => {
            if (!e2()) {
              return;
            }
            for (const t4 of n2) {
              if (t4.contains(o2)) {
                return;
              }
            }
            i2();
          });
        }
        var jb = i(35);
        var Hb = i(37);
        function Wb(t2, e2 = Vb) {
          const i2 = new e2(t2);
          const n2 = new Eb(t2);
          const o2 = new Ob(t2, i2, n2);
          i2.bind("isEnabled").to(o2);
          if (i2 instanceof Vb) {
            i2.bind("isOn").to(o2, "isOpen");
          } else {
            i2.arrowView.bind("isOn").to(o2, "isOpen");
          }
          $b(o2);
          return o2;
        }
        function qb(t2, e2) {
          const i2 = t2.locale;
          const n2 = i2.t;
          const o2 = t2.toolbarView = new Xb(i2);
          o2.set("ariaLabel", n2("lg"));
          t2.extendTemplate({attributes: {class: ["ck-toolbar-dropdown"]}});
          e2.map((t3) => o2.items.add(t3));
          t2.panelView.children.add(o2);
          o2.items.delegate("execute").to(t2);
        }
        function Ub(t2, e2) {
          const i2 = t2.locale;
          const n2 = t2.listView = new Mb(i2);
          n2.items.bindTo(e2).using(({type: t3, model: e3}) => {
            if (t3 === "separator") {
              return new zb(i2);
            } else if (t3 === "button" || t3 === "switchbutton") {
              const n3 = new Bb(i2);
              let o2;
              if (t3 === "button") {
                o2 = new hb(i2);
              } else {
                o2 = new Fb(i2);
              }
              o2.bind(...Object.keys(e3)).to(e3);
              o2.delegate("execute").to(n3);
              n3.children.add(o2);
              return n3;
            }
          });
          t2.panelView.children.add(n2);
          n2.items.delegate("execute").to(t2);
        }
        function $b(t2) {
          Gb(t2);
          Kb(t2);
          Jb(t2);
        }
        function Gb(t2) {
          t2.on("render", () => {
            Db({
              emitter: t2,
              activator: () => t2.isOpen,
              callback: () => {
                t2.isOpen = false;
              },
              contextElements: [t2.element]
            });
          });
        }
        function Kb(t2) {
          t2.on("execute", (e2) => {
            if (e2.source instanceof Fb) {
              return;
            }
            t2.isOpen = false;
          });
        }
        function Jb(t2) {
          t2.keystrokes.set("arrowdown", (e2, i2) => {
            if (t2.isOpen) {
              t2.panelView.focus();
              i2();
            }
          });
          t2.keystrokes.set("arrowup", (e2, i2) => {
            if (t2.isOpen) {
              t2.panelView.focusLast();
              i2();
            }
          });
        }
        var Yb = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
        var Qb = i(39);
        class Xb extends Gp {
          constructor(t2, e2) {
            super(t2);
            const i2 = this.bindTemplate;
            const n2 = this.t;
            this.options = e2 || {};
            this.set("ariaLabel", n2("lr"));
            this.set("maxWidth", "auto");
            this.items = this.createCollection();
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this.set("class");
            this.set("isCompact", false);
            this.itemsView = new Zb(t2);
            this.children = this.createCollection();
            this.children.add(this.itemsView);
            this.focusables = this.createCollection();
            this._focusCycler = new yb({
              focusables: this.focusables,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: ["arrowleft", "arrowup"], focusNext: ["arrowright", "arrowdown"]}
            });
            this.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-toolbar", i2.to("class"), i2.if("isCompact", "ck-toolbar_compact")],
                role: "toolbar",
                "aria-label": i2.to("ariaLabel"),
                style: {maxWidth: i2.to("maxWidth")}
              },
              children: this.children,
              on: {mousedown: Sb(this)}
            });
            this._behavior = this.options.shouldGroupWhenFull ? new ew(this) : new tw(this);
          }
          render() {
            super.render();
            for (const t2 of this.items) {
              this.focusTracker.add(t2.element);
            }
            this.items.on("add", (t2, e2) => {
              this.focusTracker.add(e2.element);
            });
            this.items.on("remove", (t2, e2) => {
              this.focusTracker.remove(e2.element);
            });
            this.keystrokes.listenTo(this.element);
            this._behavior.render(this);
          }
          destroy() {
            this._behavior.destroy();
            return super.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          fillFromConfig(t2, e2) {
            t2.map((t3) => {
              if (t3 == "|") {
                this.items.add(new Cb());
              } else if (e2.has(t3)) {
                this.items.add(e2.create(t3));
              } else {
                console.warn(Object(ss["a"])("toolbarview-item-unavailable: The requested toolbar item is unavailable."), {name: t3});
              }
            });
          }
        }
        class Zb extends Gp {
          constructor(t2) {
            super(t2);
            this.children = this.createCollection();
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck", "ck-toolbar__items"]},
              children: this.children
            });
          }
        }
        class tw {
          constructor(t2) {
            const e2 = t2.bindTemplate;
            t2.set("isVertical", false);
            t2.itemsView.children.bindTo(t2.items).using((t3) => t3);
            t2.focusables.bindTo(t2.items).using((t3) => t3);
            t2.extendTemplate({attributes: {class: [e2.if("isVertical", "ck-toolbar_vertical")]}});
          }
          render() {
          }
          destroy() {
          }
        }
        class ew {
          constructor(t2) {
            this.viewChildren = t2.children;
            this.viewFocusables = t2.focusables;
            this.viewItemsView = t2.itemsView;
            this.viewFocusTracker = t2.focusTracker;
            this.viewLocale = t2.locale;
            this.ungroupedItems = t2.createCollection();
            this.groupedItems = t2.createCollection();
            this.groupedItemsDropdown = this._createGroupedItemsDropdown();
            this.resizeObserver = null;
            this.cachedPadding = null;
            t2.itemsView.children.bindTo(this.ungroupedItems).using((t3) => t3);
            this.ungroupedItems.on("add", this._updateFocusCycleableItems.bind(this));
            this.ungroupedItems.on("remove", this._updateFocusCycleableItems.bind(this));
            t2.children.on("add", this._updateFocusCycleableItems.bind(this));
            t2.children.on("remove", this._updateFocusCycleableItems.bind(this));
            t2.items.on("add", (t3, e2, i2) => {
              if (i2 > this.ungroupedItems.length) {
                this.groupedItems.add(e2, i2 - this.ungroupedItems.length);
              } else {
                this.ungroupedItems.add(e2, i2);
              }
              this._updateGrouping();
            });
            t2.items.on("remove", (t3, e2, i2) => {
              if (i2 > this.ungroupedItems.length) {
                this.groupedItems.remove(e2);
              } else {
                this.ungroupedItems.remove(e2);
              }
              this._updateGrouping();
            });
            t2.extendTemplate({attributes: {class: ["ck-toolbar_grouping"]}});
          }
          render(t2) {
            this.viewElement = t2.element;
            this._enableGroupingOnResize();
            this._enableGroupingOnMaxWidthChange(t2);
          }
          destroy() {
            this.groupedItemsDropdown.destroy();
            this.resizeObserver.destroy();
          }
          _updateGrouping() {
            if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
              return;
            }
            let t2;
            while (this._areItemsOverflowing) {
              this._groupLastItem();
              t2 = true;
            }
            if (!t2 && this.groupedItems.length) {
              while (this.groupedItems.length && !this._areItemsOverflowing) {
                this._ungroupFirstItem();
              }
              if (this._areItemsOverflowing) {
                this._groupLastItem();
              }
            }
          }
          get _areItemsOverflowing() {
            if (!this.ungroupedItems.length) {
              return false;
            }
            const t2 = this.viewElement;
            const e2 = this.viewLocale.uiLanguageDirection;
            const i2 = new vh(t2.lastChild);
            const n2 = new vh(t2);
            if (!this.cachedPadding) {
              const i3 = Id.window.getComputedStyle(t2);
              const n3 = e2 === "ltr" ? "paddingRight" : "paddingLeft";
              this.cachedPadding = Number.parseInt(i3[n3]);
            }
            if (e2 === "ltr") {
              return i2.right > n2.right - this.cachedPadding;
            } else {
              return i2.left < n2.left + this.cachedPadding;
            }
          }
          _enableGroupingOnResize() {
            let t2;
            this.resizeObserver = new Tb(this.viewElement, (e2) => {
              if (!t2 || t2 !== e2.contentRect.width) {
                this._updateGrouping();
                t2 = e2.contentRect.width;
              }
            });
            this._updateGrouping();
          }
          _enableGroupingOnMaxWidthChange(t2) {
            t2.on("change:maxWidth", () => {
              this._updateGrouping();
            });
          }
          _groupLastItem() {
            if (!this.groupedItems.length) {
              this.viewChildren.add(new Cb());
              this.viewChildren.add(this.groupedItemsDropdown);
              this.viewFocusTracker.add(this.groupedItemsDropdown.element);
            }
            this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
          }
          _ungroupFirstItem() {
            this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
            if (!this.groupedItems.length) {
              this.viewChildren.remove(this.groupedItemsDropdown);
              this.viewChildren.remove(this.viewChildren.last);
              this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
            }
          }
          _createGroupedItemsDropdown() {
            const t2 = this.viewLocale;
            const e2 = t2.t;
            const i2 = Wb(t2);
            i2.class = "ck-toolbar__grouped-dropdown";
            i2.panelPosition = t2.uiLanguageDirection === "ltr" ? "sw" : "se";
            qb(i2, []);
            i2.buttonView.set({label: e2("ls"), tooltip: true, icon: Yb});
            i2.toolbarView.items.bindTo(this.groupedItems).using((t3) => t3);
            return i2;
          }
          _updateFocusCycleableItems() {
            this.viewFocusables.clear();
            this.ungroupedItems.map((t2) => {
              this.viewFocusables.add(t2);
            });
            if (this.groupedItems.length) {
              this.viewFocusables.add(this.groupedItemsDropdown);
            }
          }
        }
        function iw(t2) {
          if (Array.isArray(t2)) {
            return {items: t2};
          }
          if (!t2) {
            return {items: []};
          }
          return Object.assign({items: []}, t2);
        }
        const nw = Zp("px");
        class ow extends mp {
          static get pluginName() {
            return "BalloonToolbar";
          }
          static get requires() {
            return [kb];
          }
          constructor(t2) {
            super(t2);
            this._balloonConfig = iw(t2.config.get("balloonToolbar"));
            this.toolbarView = this._createToolbarView();
            this.focusTracker = new fb();
            t2.ui.once("ready", () => {
              this.focusTracker.add(t2.ui.getEditableElement());
              this.focusTracker.add(this.toolbarView.element);
            });
            this._resizeObserver = null;
            this._balloon = t2.plugins.get(kb);
            this._fireSelectionChangeDebounced = uh(() => this.fire("_selectionChangeDebounced"), 200);
            this.decorate("show");
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.document.selection;
            this.listenTo(this.focusTracker, "change:isFocused", (t3, e3, i2) => {
              const n2 = this._balloon.visibleView === this.toolbarView;
              if (!i2 && n2) {
                this.hide();
              } else if (i2) {
                this.show();
              }
            });
            this.listenTo(e2, "change:range", (t3, i2) => {
              if (i2.directChange || e2.isCollapsed) {
                this.hide();
              }
              this._fireSelectionChangeDebounced();
            });
            this.listenTo(this, "_selectionChangeDebounced", () => {
              if (this.editor.editing.view.document.isFocused) {
                this.show();
              }
            });
            if (!this._balloonConfig.shouldNotGroupWhenFull) {
              this.listenTo(t2, "ready", () => {
                const e3 = t2.ui.view.editable.element;
                this._resizeObserver = new Tb(e3, () => {
                  this.toolbarView.maxWidth = nw(new vh(e3).width * 0.9);
                });
              });
            }
          }
          afterInit() {
            const t2 = this.editor.ui.componentFactory;
            this.toolbarView.fillFromConfig(this._balloonConfig.items, t2);
          }
          _createToolbarView() {
            const t2 = !this._balloonConfig.shouldNotGroupWhenFull;
            const e2 = new Xb(this.editor.locale, {shouldGroupWhenFull: t2});
            e2.extendTemplate({attributes: {class: ["ck-toolbar_floating"]}});
            e2.render();
            return e2;
          }
          show() {
            const t2 = this.editor;
            if (this._balloon.hasView(this.toolbarView)) {
              return;
            }
            if (t2.model.document.selection.isCollapsed) {
              return;
            }
            if (Array.from(this.toolbarView.items).every((t3) => t3.isEnabled !== void 0 && !t3.isEnabled)) {
              return;
            }
            this.listenTo(this.editor.ui, "update", () => {
              this._balloon.updatePosition(this._getBalloonPositionData());
            });
            this._balloon.add({
              view: this.toolbarView,
              position: this._getBalloonPositionData(),
              balloonClassName: "ck-toolbar-container"
            });
          }
          hide() {
            if (this._balloon.hasView(this.toolbarView)) {
              this.stopListening(this.editor.ui, "update");
              this._balloon.remove(this.toolbarView);
            }
          }
          _getBalloonPositionData() {
            const t2 = this.editor;
            const e2 = t2.editing.view;
            const i2 = e2.document;
            const n2 = i2.selection;
            const o2 = i2.selection.isBackward;
            return {
              target: () => {
                const t3 = o2 ? n2.getFirstRange() : n2.getLastRange();
                const i3 = vh.getDomRangeRects(e2.domConverter.viewRangeToDom(t3));
                if (o2) {
                  return i3[0];
                } else {
                  if (i3.length > 1 && i3[i3.length - 1].width === 0) {
                    i3.pop();
                  }
                  return i3[i3.length - 1];
                }
              },
              positions: rw(o2)
            };
          }
          destroy() {
            super.destroy();
            this.stopListening();
            this._fireSelectionChangeDebounced.cancel();
            this.toolbarView.destroy();
            this.focusTracker.destroy();
            if (this._resizeObserver) {
              this._resizeObserver.destroy();
            }
          }
        }
        function rw(t2) {
          const e2 = nb.defaultPositions;
          return t2 ? [e2.northWestArrowSouth, e2.northWestArrowSouthWest, e2.northWestArrowSouthEast, e2.northWestArrowSouthMiddleEast, e2.northWestArrowSouthMiddleWest, e2.southWestArrowNorth, e2.southWestArrowNorthWest, e2.southWestArrowNorthEast, e2.southWestArrowNorthMiddleWest, e2.southWestArrowNorthMiddleEast] : [e2.southEastArrowNorth, e2.southEastArrowNorthEast, e2.southEastArrowNorthWest, e2.southEastArrowNorthMiddleEast, e2.southEastArrowNorthMiddleWest, e2.northEastArrowSouth, e2.northEastArrowSouthEast, e2.northEastArrowSouthWest, e2.northEastArrowSouthMiddleEast, e2.northEastArrowSouthMiddleWest];
        }
        class sw {
          constructor(t2) {
            this.editor = t2;
            this._components = new Map();
          }
          *names() {
            for (const t2 of this._components.values()) {
              yield t2.originalName;
            }
          }
          add(t2, e2) {
            if (this.has(t2)) {
              throw new ss["b"]("componentfactory-item-exists: The item already exists in the component factory.", this, {name: t2});
            }
            this._components.set(aw(t2), {callback: e2, originalName: t2});
          }
          create(t2) {
            if (!this.has(t2)) {
              throw new ss["b"]("componentfactory-item-missing: The required component is not registered in the factory.", this, {name: t2});
            }
            return this._components.get(aw(t2)).callback(this.editor.locale);
          }
          has(t2) {
            return this._components.has(aw(t2));
          }
        }
        function aw(t2) {
          return String(t2).toLowerCase();
        }
        class cw {
          constructor(t2) {
            this.editor = t2;
            this.componentFactory = new sw(t2);
            this.focusTracker = new fb();
            this._editableElementsMap = new Map();
            this.listenTo(t2.editing.view.document, "layoutChanged", () => this.update());
          }
          get element() {
            return null;
          }
          update() {
            this.fire("update");
          }
          destroy() {
            this.stopListening();
            this.focusTracker.destroy();
            for (const t2 of this._editableElementsMap.values()) {
              t2.ckeditorInstance = null;
            }
            this._editableElementsMap = new Map();
          }
          setEditableElement(t2, e2) {
            this._editableElementsMap.set(t2, e2);
            if (!e2.ckeditorInstance) {
              e2.ckeditorInstance = this.editor;
            }
          }
          getEditableElement(t2 = "main") {
            return this._editableElementsMap.get(t2);
          }
          getEditableElementsNames() {
            return this._editableElementsMap.keys();
          }
          get _editableElements() {
            console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {editorUI: this});
            return this._editableElementsMap;
          }
        }
        vs(cw, ds);
        function lw({origin: t2, originKeystrokeHandler: e2, originFocusTracker: i2, toolbar: n2, beforeFocus: o2, afterBlur: r2}) {
          i2.add(n2.element);
          e2.set("Alt+F10", (t3, e3) => {
            if (i2.isFocused && !n2.focusTracker.isFocused) {
              if (o2) {
                o2();
              }
              n2.focus();
              e3();
            }
          });
          n2.keystrokes.set("Esc", (e3, i3) => {
            if (n2.focusTracker.isFocused) {
              t2.focus();
              if (r2) {
                r2();
              }
              i3();
            }
          });
        }
        var dw = i(41);
        const uw = new WeakMap();
        function hw(t2) {
          const {view: e2, element: i2, text: n2, isDirectHost: o2 = true} = t2;
          const r2 = e2.document;
          if (!uw.has(r2)) {
            uw.set(r2, new Map());
            r2.registerPostFixer((t3) => bw(r2, t3));
          }
          uw.get(r2).set(i2, {text: n2, isDirectHost: o2});
          e2.change((t3) => bw(r2, t3));
        }
        function fw(t2, e2) {
          const i2 = e2.document;
          t2.change((t3) => {
            if (!uw.has(i2)) {
              return;
            }
            const n2 = uw.get(i2);
            const o2 = n2.get(e2);
            t3.removeAttribute("data-placeholder", o2.hostElement);
            mw(t3, o2.hostElement);
            n2.delete(e2);
          });
        }
        function gw(t2, e2) {
          if (!e2.hasClass("ck-placeholder")) {
            t2.addClass("ck-placeholder", e2);
            return true;
          }
          return false;
        }
        function mw(t2, e2) {
          if (e2.hasClass("ck-placeholder")) {
            t2.removeClass("ck-placeholder", e2);
            return true;
          }
          return false;
        }
        function pw(t2) {
          if (!t2.isAttached()) {
            return false;
          }
          const e2 = !Array.from(t2.getChildren()).some((t3) => !t3.is("uiElement"));
          const i2 = t2.document;
          if (!i2.isFocused && e2) {
            return true;
          }
          const n2 = i2.selection;
          const o2 = n2.anchor;
          if (e2 && o2 && o2.parent !== t2) {
            return true;
          }
          return false;
        }
        function bw(t2, e2) {
          const i2 = uw.get(t2);
          let n2 = false;
          for (const [t3, o2] of i2) {
            if (ww(e2, t3, o2)) {
              n2 = true;
            }
          }
          return n2;
        }
        function ww(t2, e2, i2) {
          const {text: n2, isDirectHost: o2} = i2;
          const r2 = o2 ? e2 : kw(e2);
          let s2 = false;
          if (!r2) {
            return false;
          }
          i2.hostElement = r2;
          if (r2.getAttribute("data-placeholder") !== n2) {
            t2.setAttribute("data-placeholder", n2, r2);
            s2 = true;
          }
          if (pw(r2)) {
            if (gw(t2, r2)) {
              s2 = true;
            }
          } else if (mw(t2, r2)) {
            s2 = true;
          }
          return s2;
        }
        function kw(t2) {
          if (t2.childCount === 1) {
            const e2 = t2.getChild(0);
            if (e2.is("element") && !e2.is("uiElement")) {
              return e2;
            }
          }
          return null;
        }
        class _w extends cw {
          constructor(t2, e2) {
            super(t2);
            this.view = e2;
          }
          get element() {
            return this.view.editable.element;
          }
          init() {
            const t2 = this.editor;
            const e2 = this.view;
            const i2 = t2.plugins.get("BalloonToolbar");
            const n2 = t2.editing.view;
            const o2 = e2.editable;
            const r2 = n2.document.getRoot();
            o2.name = r2.rootName;
            e2.render();
            const s2 = o2.element;
            this.setEditableElement(o2.name, s2);
            this.focusTracker.add(s2);
            o2.bind("isFocused").to(this.focusTracker);
            n2.attachDomRoot(s2);
            lw({
              origin: n2,
              originFocusTracker: this.focusTracker,
              originKeystrokeHandler: t2.keystrokes,
              toolbar: i2.toolbarView,
              beforeFocus() {
                i2.show();
              },
              afterBlur() {
                i2.hide();
              }
            });
            this._initPlaceholder();
            this.fire("ready");
          }
          destroy() {
            const t2 = this.view;
            const e2 = this.editor.editing.view;
            e2.detachDomRoot(t2.editable.name);
            t2.destroy();
            super.destroy();
          }
          _initPlaceholder() {
            const t2 = this.editor;
            const e2 = t2.editing.view;
            const i2 = e2.document.getRoot();
            const n2 = t2.sourceElement;
            const o2 = t2.config.get("placeholder") || n2 && n2.tagName.toLowerCase() === "textarea" && n2.getAttribute("placeholder");
            if (o2) {
              hw({view: e2, element: i2, text: o2, isDirectHost: false});
            }
          }
        }
        var vw = "[object String]";
        function yw(t2) {
          return typeof t2 == "string" || !Je(t2) && T(t2) && _(t2) == vw;
        }
        var xw = yw;
        function Cw(t2, e2, i2 = {}, n2 = []) {
          const o2 = i2 && i2.xmlns;
          const r2 = o2 ? t2.createElementNS(o2, e2) : t2.createElement(e2);
          for (const t3 in i2) {
            r2.setAttribute(t3, i2[t3]);
          }
          if (xw(n2) || !js(n2)) {
            n2 = [n2];
          }
          for (let e3 of n2) {
            if (xw(e3)) {
              e3 = t2.createTextNode(e3);
            }
            r2.appendChild(e3);
          }
          return r2;
        }
        class Aw extends bp {
          attachToDom() {
            this._bodyCollectionContainer = new _p({
              tag: "div",
              attributes: {
                class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                dir: this.locale.uiLanguageDirection
              },
              children: this
            }).render();
            let t2 = document.querySelector(".ck-body-wrapper");
            if (!t2) {
              t2 = Cw(document, "div", {class: "ck-body-wrapper"});
              document.body.appendChild(t2);
            }
            t2.appendChild(this._bodyCollectionContainer);
          }
          detachFromDom() {
            super.destroy();
            if (this._bodyCollectionContainer) {
              this._bodyCollectionContainer.remove();
            }
            const t2 = document.querySelector(".ck-body-wrapper");
            if (t2 && t2.childElementCount == 0) {
              t2.remove();
            }
          }
        }
        var Tw = i(43);
        class Pw extends Gp {
          constructor(t2) {
            super(t2);
            this.body = new Aw(t2);
          }
          render() {
            super.render();
            this.body.attachToDom();
          }
          destroy() {
            this.body.detachFromDom();
            return super.destroy();
          }
        }
        class Sw extends Gp {
          constructor(t2, e2, i2) {
            super(t2);
            this.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                lang: t2.contentLanguage,
                dir: t2.contentLanguageDirection
              }
            });
            this.name = null;
            this.set("isFocused", false);
            this._editableElement = i2;
            this._hasExternalElement = !!this._editableElement;
            this._editingView = e2;
          }
          render() {
            super.render();
            if (this._hasExternalElement) {
              this.template.apply(this.element = this._editableElement);
            } else {
              this._editableElement = this.element;
            }
            this.on("change:isFocused", () => this._updateIsFocusedClasses());
            this._updateIsFocusedClasses();
          }
          destroy() {
            if (this._hasExternalElement) {
              this.template.revert(this._editableElement);
            }
            super.destroy();
          }
          _updateIsFocusedClasses() {
            const t2 = this._editingView;
            if (t2.isRenderingInProgress) {
              i2(this);
            } else {
              e2(this);
            }
            function e2(e3) {
              t2.change((i3) => {
                const n2 = t2.document.getRoot(e3.name);
                i3.addClass(e3.isFocused ? "ck-focused" : "ck-blurred", n2);
                i3.removeClass(e3.isFocused ? "ck-blurred" : "ck-focused", n2);
              });
            }
            function i2(n2) {
              t2.once("change:isRenderingInProgress", (t3, o2, r2) => {
                if (!r2) {
                  e2(n2);
                } else {
                  i2(n2);
                }
              });
            }
          }
        }
        class Ew extends Sw {
          constructor(t2, e2, i2) {
            super(t2, e2, i2);
            this.extendTemplate({attributes: {role: "textbox", class: "ck-editor__editable_inline"}});
          }
          render() {
            super.render();
            const t2 = this._editingView;
            const e2 = this.t;
            t2.change((i2) => {
              const n2 = t2.document.getRoot(this.name);
              i2.setAttribute("aria-label", e2("of", [this.name]), n2);
            });
          }
        }
        class Rw extends Pw {
          constructor(t2, e2, i2) {
            super(t2);
            this.editable = new Ew(t2, e2, i2);
          }
          render() {
            super.render();
            this.registerChild(this.editable);
          }
        }
        function Ow(t2, e2) {
          if (t2 instanceof HTMLTextAreaElement) {
            t2.value = e2;
          }
          t2.innerHTML = e2;
        }
        function Iw(t2) {
          if (t2 instanceof HTMLTextAreaElement) {
            return t2.value;
          }
          return t2.innerHTML;
        }
        const Vw = {
          setData(t2) {
            this.data.set(t2);
          },
          getData(t2) {
            return this.data.get(t2);
          }
        };
        var Nw = Vw;
        const Mw = {
          updateSourceElement() {
            if (!this.sourceElement) {
              throw new ss["b"]("editor-missing-sourceelement: Cannot update the source element of a detached editor.", this);
            }
            Ow(this.sourceElement, this.data.get());
          }
        };
        var Bw = Mw;
        function zw(t2) {
          if (!gt(t2.updateSourceElement)) {
            throw new ss["b"]("attachtoform-missing-elementapi-interface: Editor passed to attachToForm() must implement ElementApi.", t2);
          }
          const e2 = t2.sourceElement;
          if (e2 && e2.tagName.toLowerCase() === "textarea" && e2.form) {
            let i2;
            const n2 = e2.form;
            const o2 = () => t2.updateSourceElement();
            if (gt(n2.submit)) {
              i2 = n2.submit;
              n2.submit = () => {
                o2();
                i2.apply(n2);
              };
            }
            n2.addEventListener("submit", o2);
            t2.on("destroy", () => {
              n2.removeEventListener("submit", o2);
              if (i2) {
                n2.submit = i2;
              }
            });
          }
        }
        function Lw(t2) {
          const e2 = t2.sourceElement;
          if (!e2) {
            return;
          }
          if (e2.ckeditorInstance) {
            throw new ss["b"]("editor-source-element-already-used: The DOM element cannot be used to create multiple editor instances.", t2);
          }
          e2.ckeditorInstance = t2;
          t2.once("destroy", () => {
            delete e2.ckeditorInstance;
          });
        }
        class Fw extends hp {
          constructor(t2, e2) {
            super(e2);
            if (Kr(t2)) {
              this.sourceElement = t2;
              Lw(this);
            }
            const i2 = this.config.get("plugins");
            i2.push(ow);
            this.config.set("plugins", i2);
            this.config.define("balloonToolbar", this.config.get("toolbar"));
            this.data.processor = new gp(this.data.viewDocument);
            this.model.document.createRoot();
            const n2 = new Rw(this.locale, this.editing.view, this.sourceElement);
            this.ui = new _w(this, n2);
            zw(this);
          }
          destroy() {
            const t2 = this.getData();
            this.ui.destroy();
            return super.destroy().then(() => {
              if (this.sourceElement) {
                Ow(this.sourceElement, t2);
              }
            });
          }
          static create(t2, e2 = {}) {
            return new Promise((i2) => {
              const n2 = Kr(t2);
              if (n2 && t2.tagName === "TEXTAREA") {
                throw new ss["b"]("editor-wrong-element: This type of editor cannot be initialized inside <textarea> element.", null);
              }
              const o2 = new this(t2, e2);
              i2(o2.initPlugins().then(() => {
                o2.ui.init();
              }).then(() => {
                if (!n2 && e2.initialData) {
                  throw new ss["b"]("editor-create-initial-data: The config.initialData option cannot be used together with initial data passed in Editor.create().", null);
                }
                const i3 = e2.initialData || Dw(t2);
                return o2.data.init(i3);
              }).then(() => o2.fire("ready")).then(() => o2));
            });
          }
        }
        vs(Fw, Nw);
        vs(Fw, Bw);
        function Dw(t2) {
          return Kr(t2) ? Iw(t2) : t2;
        }
        class jw {
          constructor(t2) {
            this.editor = t2;
            this.set("value", void 0);
            this.set("isEnabled", false);
            this._disableStack = new Set();
            this.decorate("execute");
            this.listenTo(this.editor.model.document, "change", () => {
              this.refresh();
            });
            this.on("execute", (t3) => {
            }, {priority: "high"});
            this.listenTo(t2, "change:isReadOnly", (t3, e2, i2) => {
              if (i2) {
                this.forceDisabled("readOnlyMode");
              } else {
                this.clearForceDisabled("readOnlyMode");
              }
            });
          }
          refresh() {
            this.isEnabled = true;
          }
          forceDisabled(t2) {
            this._disableStack.add(t2);
            if (this._disableStack.size == 1) {
              this.on("set:isEnabled", Hw, {priority: "highest"});
              this.isEnabled = false;
            }
          }
          clearForceDisabled(t2) {
            this._disableStack.delete(t2);
            if (this._disableStack.size == 0) {
              this.off("set:isEnabled", Hw);
              this.refresh();
            }
          }
          execute() {
          }
          destroy() {
            this.stopListening();
          }
        }
        vs(jw, Jc);
        function Hw(t2) {
          t2.return = false;
          t2.stop();
        }
        function Ww(t2) {
          const e2 = t2.next();
          if (e2.done) {
            return null;
          }
          return e2.value;
        }
        const qw = ["left", "right", "center", "justify"];
        function Uw(t2) {
          return qw.includes(t2);
        }
        function $w(t2, e2) {
          if (e2.contentLanguageDirection == "rtl") {
            return t2 === "right";
          } else {
            return t2 === "left";
          }
        }
        const Gw = "alignment";
        class Kw extends jw {
          refresh() {
            const t2 = this.editor;
            const e2 = t2.locale;
            const i2 = Ww(this.editor.model.document.selection.getSelectedBlocks());
            this.isEnabled = !!i2 && this._canBeAligned(i2);
            if (this.isEnabled && i2.hasAttribute("alignment")) {
              this.value = i2.getAttribute("alignment");
            } else {
              this.value = e2.contentLanguageDirection === "rtl" ? "right" : "left";
            }
          }
          execute(t2 = {}) {
            const e2 = this.editor;
            const i2 = e2.locale;
            const n2 = e2.model;
            const o2 = n2.document;
            const r2 = t2.value;
            n2.change((t3) => {
              const e3 = Array.from(o2.selection.getSelectedBlocks()).filter((t4) => this._canBeAligned(t4));
              const n3 = e3[0].getAttribute("alignment");
              const s2 = $w(r2, i2) || n3 === r2 || !r2;
              if (s2) {
                Jw(e3, t3);
              } else {
                Yw(e3, t3, r2);
              }
            });
          }
          _canBeAligned(t2) {
            return this.editor.model.schema.checkAttribute(t2, Gw);
          }
        }
        function Jw(t2, e2) {
          for (const i2 of t2) {
            e2.removeAttribute(Gw, i2);
          }
        }
        function Yw(t2, e2, i2) {
          for (const n2 of t2) {
            e2.setAttribute(Gw, i2, n2);
          }
        }
        class Qw extends mp {
          static get pluginName() {
            return "AlignmentEditing";
          }
          constructor(t2) {
            super(t2);
            t2.config.define("alignment", {options: [...qw]});
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.locale;
            const i2 = t2.model.schema;
            const n2 = t2.config.get("alignment.options").filter(Uw);
            i2.extend("$block", {allowAttributes: "alignment"});
            t2.model.schema.setAttributeProperties("alignment", {isFormatting: true});
            const o2 = Xw(n2.filter((t3) => !$w(t3, e2)));
            t2.conversion.attributeToAttribute(o2);
            t2.commands.add("alignment", new Kw(t2));
          }
        }
        function Xw(t2) {
          const e2 = {model: {key: "alignment", values: t2.slice()}, view: {}};
          for (const i2 of t2) {
            e2.view[i2] = {key: "style", value: {"text-align": i2}};
          }
          return e2;
        }
        var Zw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
        var tk = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
        var ek = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
        var ik = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
        const nk = new Map([["left", Zw], ["right", tk], ["center", ek], ["justify", ik]]);
        class ok extends mp {
          get localizedOptionTitles() {
            const t2 = this.editor.t;
            return {left: t2("iw"), right: t2("ix"), center: t2("iy"), justify: t2("iz")};
          }
          static get pluginName() {
            return "AlignmentUI";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.ui.componentFactory;
            const i2 = t2.t;
            const n2 = t2.config.get("alignment.options");
            n2.filter(Uw).forEach((t3) => this._addButton(t3));
            e2.add("alignment", (t3) => {
              const o2 = Wb(t3);
              const r2 = n2.map((t4) => e2.create(`alignment:${t4}`));
              qb(o2, r2);
              o2.buttonView.set({label: i2("ja"), tooltip: true});
              o2.toolbarView.isVertical = true;
              o2.toolbarView.ariaLabel = i2("jb");
              o2.extendTemplate({attributes: {class: "ck-alignment-dropdown"}});
              const s2 = t3.contentLanguageDirection === "rtl" ? tk : Zw;
              o2.buttonView.bind("icon").toMany(r2, "isOn", (...t4) => {
                const e3 = t4.findIndex((t5) => t5);
                if (e3 < 0) {
                  return s2;
                }
                return r2[e3].icon;
              });
              o2.bind("isEnabled").toMany(r2, "isEnabled", (...t4) => t4.some((t5) => t5));
              return o2;
            });
          }
          _addButton(t2) {
            const e2 = this.editor;
            e2.ui.componentFactory.add(`alignment:${t2}`, (i2) => {
              const n2 = e2.commands.get("alignment");
              const o2 = new hb(i2);
              o2.set({label: this.localizedOptionTitles[t2], icon: nk.get(t2), tooltip: true, isToggleable: true});
              o2.bind("isEnabled").to(n2);
              o2.bind("isOn").to(n2, "value", (e3) => e3 === t2);
              this.listenTo(o2, "execute", () => {
                e2.execute("alignment", {value: t2});
                e2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class rk extends mp {
          static get requires() {
            return [Qw, ok];
          }
          static get pluginName() {
            return "Alignment";
          }
        }
        class sk {
          constructor(t2) {
            this.context = t2;
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return true;
          }
        }
        vs(sk, Jc);
        class ak extends sk {
          static get pluginName() {
            return "PendingActions";
          }
          init() {
            this.set("hasAny", false);
            this._actions = new ys({idProperty: "_id"});
            this._actions.delegate("add", "remove").to(this);
          }
          add(t2) {
            if (typeof t2 !== "string") {
              throw new ss["b"]("pendingactions-add-invalid-message: The message must be a string.", this);
            }
            const e2 = Object.create(Jc);
            e2.set("message", t2);
            this._actions.add(e2);
            this.hasAny = true;
            return e2;
          }
          remove(t2) {
            this._actions.remove(t2);
            this.hasAny = !!this._actions.length;
          }
          get first() {
            return this._actions.get(0);
          }
          [Symbol.iterator]() {
            return this._actions[Symbol.iterator]();
          }
        }
        class ck {
          constructor() {
            const t2 = new window.FileReader();
            this._reader = t2;
            this._data = void 0;
            this.set("loaded", 0);
            t2.onprogress = (t3) => {
              this.loaded = t3.loaded;
            };
          }
          get error() {
            return this._reader.error;
          }
          get data() {
            return this._data;
          }
          read(t2) {
            const e2 = this._reader;
            this.total = t2.size;
            return new Promise((i2, n2) => {
              e2.onload = () => {
                const t3 = e2.result;
                this._data = t3;
                i2(t3);
              };
              e2.onerror = () => {
                n2("error");
              };
              e2.onabort = () => {
                n2("aborted");
              };
              this._reader.readAsDataURL(t2);
            });
          }
          abort() {
            this._reader.abort();
          }
        }
        vs(ck, Jc);
        class lk extends mp {
          static get pluginName() {
            return "FileRepository";
          }
          static get requires() {
            return [ak];
          }
          init() {
            this.loaders = new ys();
            this.loaders.on("add", () => this._updatePendingAction());
            this.loaders.on("remove", () => this._updatePendingAction());
            this._loadersMap = new Map();
            this._pendingAction = null;
            this.set("uploaded", 0);
            this.set("uploadTotal", null);
            this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t2, e2) => e2 ? t2 / e2 * 100 : 0);
          }
          getLoader(t2) {
            return this._loadersMap.get(t2) || null;
          }
          createLoader(t2) {
            if (!this.createUploadAdapter) {
              console.warn(Object(ss["a"])("filerepository-no-upload-adapter: Upload adapter is not defined."));
              return null;
            }
            const e2 = new dk(Promise.resolve(t2), this.createUploadAdapter);
            this.loaders.add(e2);
            this._loadersMap.set(t2, e2);
            if (t2 instanceof Promise) {
              e2.file.then((t3) => {
                this._loadersMap.set(t3, e2);
              }).catch(() => {
              });
            }
            e2.on("change:uploaded", () => {
              let t3 = 0;
              for (const e3 of this.loaders) {
                t3 += e3.uploaded;
              }
              this.uploaded = t3;
            });
            e2.on("change:uploadTotal", () => {
              let t3 = 0;
              for (const e3 of this.loaders) {
                if (e3.uploadTotal) {
                  t3 += e3.uploadTotal;
                }
              }
              this.uploadTotal = t3;
            });
            return e2;
          }
          destroyLoader(t2) {
            const e2 = t2 instanceof dk ? t2 : this.getLoader(t2);
            e2._destroy();
            this.loaders.remove(e2);
            this._loadersMap.forEach((t3, i2) => {
              if (t3 === e2) {
                this._loadersMap.delete(i2);
              }
            });
          }
          _updatePendingAction() {
            const t2 = this.editor.plugins.get(ak);
            if (this.loaders.length) {
              if (!this._pendingAction) {
                const e2 = this.editor.t;
                const i2 = (t3) => `${e2("lb")} ${parseInt(t3)}%.`;
                this._pendingAction = t2.add(i2(this.uploadedPercent));
                this._pendingAction.bind("message").to(this, "uploadedPercent", i2);
              }
            } else {
              t2.remove(this._pendingAction);
              this._pendingAction = null;
            }
          }
        }
        vs(lk, Jc);
        class dk {
          constructor(t2, e2) {
            this.id = is();
            this._filePromiseWrapper = this._createFilePromiseWrapper(t2);
            this._adapter = e2(this);
            this._reader = new ck();
            this.set("status", "idle");
            this.set("uploaded", 0);
            this.set("uploadTotal", null);
            this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t3, e3) => e3 ? t3 / e3 * 100 : 0);
            this.set("uploadResponse", null);
          }
          get file() {
            if (!this._filePromiseWrapper) {
              return Promise.resolve(null);
            } else {
              return this._filePromiseWrapper.promise.then((t2) => this._filePromiseWrapper ? t2 : null);
            }
          }
          get data() {
            return this._reader.data;
          }
          read() {
            if (this.status != "idle") {
              throw new ss["b"]("filerepository-read-wrong-status: You cannot call read if the status is different than idle.", this);
            }
            this.status = "reading";
            return this.file.then((t2) => this._reader.read(t2)).then((t2) => {
              this.status = "idle";
              return t2;
            }).catch((t2) => {
              if (t2 === "aborted") {
                this.status = "aborted";
                throw "aborted";
              }
              this.status = "error";
              throw this._reader.error ? this._reader.error : t2;
            });
          }
          upload() {
            if (this.status != "idle") {
              throw new ss["b"]("filerepository-upload-wrong-status: You cannot call upload if the status is different than idle.", this);
            }
            this.status = "uploading";
            return this.file.then(() => this._adapter.upload()).then((t2) => {
              this.uploadResponse = t2;
              this.status = "idle";
              return t2;
            }).catch((t2) => {
              if (this.status === "aborted") {
                throw "aborted";
              }
              this.status = "error";
              throw t2;
            });
          }
          abort() {
            const t2 = this.status;
            this.status = "aborted";
            if (!this._filePromiseWrapper.isFulfilled) {
              this._filePromiseWrapper.promise.catch(() => {
              });
              this._filePromiseWrapper.rejecter("aborted");
            } else if (t2 == "reading") {
              this._reader.abort();
            } else if (t2 == "uploading" && this._adapter.abort) {
              this._adapter.abort();
            }
            this._destroy();
          }
          _destroy() {
            this._filePromiseWrapper = void 0;
            this._reader = void 0;
            this._adapter = void 0;
            this.uploadResponse = void 0;
          }
          _createFilePromiseWrapper(t2) {
            const e2 = {};
            e2.promise = new Promise((i2, n2) => {
              e2.rejecter = n2;
              e2.isFulfilled = false;
              t2.then((t3) => {
                e2.isFulfilled = true;
                i2(t3);
              }).catch((t3) => {
                e2.isFulfilled = true;
                n2(t3);
              });
            });
            return e2;
          }
        }
        vs(dk, Jc);
        class uk extends mp {
          static get requires() {
            return [lk];
          }
          static get pluginName() {
            return "Base64UploadAdapter";
          }
          init() {
            this.editor.plugins.get(lk).createUploadAdapter = (t2) => new hk(t2);
          }
        }
        class hk {
          constructor(t2) {
            this.loader = t2;
          }
          upload() {
            return new Promise((t2, e2) => {
              const i2 = this.reader = new window.FileReader();
              i2.addEventListener("load", () => {
                t2({default: i2.result});
              });
              i2.addEventListener("error", (t3) => {
                e2(t3);
              });
              i2.addEventListener("abort", () => {
                e2();
              });
              this.loader.file.then((t3) => {
                i2.readAsDataURL(t3);
              });
            });
          }
          abort() {
            this.reader.abort();
          }
        }
        class fk extends jw {
          refresh() {
            this.value = this._getValue();
            this.isEnabled = this._checkEnabled();
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = e2.schema;
            const n2 = e2.document.selection;
            const o2 = Array.from(n2.getSelectedBlocks());
            const r2 = t2.forceValue === void 0 ? !this.value : t2.forceValue;
            e2.change((t3) => {
              if (!r2) {
                this._removeQuote(t3, o2.filter(gk));
              } else {
                const e3 = o2.filter((t4) => gk(t4) || pk(i2, t4));
                this._applyQuote(t3, e3);
              }
            });
          }
          _getValue() {
            const t2 = this.editor.model.document.selection;
            const e2 = Ww(t2.getSelectedBlocks());
            return !!(e2 && gk(e2));
          }
          _checkEnabled() {
            if (this.value) {
              return true;
            }
            const t2 = this.editor.model.document.selection;
            const e2 = this.editor.model.schema;
            const i2 = Ww(t2.getSelectedBlocks());
            if (!i2) {
              return false;
            }
            return pk(e2, i2);
          }
          _removeQuote(t2, e2) {
            mk(t2, e2).reverse().forEach((e3) => {
              if (e3.start.isAtStart && e3.end.isAtEnd) {
                t2.unwrap(e3.start.parent);
                return;
              }
              if (e3.start.isAtStart) {
                const i3 = t2.createPositionBefore(e3.start.parent);
                t2.move(e3, i3);
                return;
              }
              if (!e3.end.isAtEnd) {
                t2.split(e3.end);
              }
              const i2 = t2.createPositionAfter(e3.end.parent);
              t2.move(e3, i2);
            });
          }
          _applyQuote(t2, e2) {
            const i2 = [];
            mk(t2, e2).reverse().forEach((e3) => {
              let n2 = gk(e3.start);
              if (!n2) {
                n2 = t2.createElement("blockQuote");
                t2.wrap(e3, n2);
              }
              i2.push(n2);
            });
            i2.reverse().reduce((e3, i3) => {
              if (e3.nextSibling == i3) {
                t2.merge(t2.createPositionAfter(e3));
                return e3;
              }
              return i3;
            });
          }
        }
        function gk(t2) {
          return t2.parent.name == "blockQuote" ? t2.parent : null;
        }
        function mk(t2, e2) {
          let i2;
          let n2 = 0;
          const o2 = [];
          while (n2 < e2.length) {
            const r2 = e2[n2];
            const s2 = e2[n2 + 1];
            if (!i2) {
              i2 = t2.createPositionBefore(r2);
            }
            if (!s2 || r2.nextSibling != s2) {
              o2.push(t2.createRange(i2, t2.createPositionAfter(r2)));
              i2 = null;
            }
            n2++;
          }
          return o2;
        }
        function pk(t2, e2) {
          const i2 = t2.checkChild(e2.parent, "blockQuote");
          const n2 = t2.checkChild(["$root", "blockQuote"], e2);
          return i2 && n2;
        }
        class bk extends mp {
          static get pluginName() {
            return "BlockQuoteEditing";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.schema;
            t2.commands.add("blockQuote", new fk(t2));
            e2.register("blockQuote", {allowWhere: "$block", allowContentOf: "$root"});
            e2.addChildCheck((t3, e3) => {
              if (t3.endsWith("blockQuote") && e3.name == "blockQuote") {
                return false;
              }
            });
            t2.conversion.elementToElement({model: "blockQuote", view: "blockquote"});
            t2.model.document.registerPostFixer((i2) => {
              const n2 = t2.model.document.differ.getChanges();
              for (const t3 of n2) {
                if (t3.type == "insert") {
                  const n3 = t3.position.nodeAfter;
                  if (!n3) {
                    continue;
                  }
                  if (n3.is("blockQuote") && n3.isEmpty) {
                    i2.remove(n3);
                    return true;
                  } else if (n3.is("blockQuote") && !e2.checkChild(t3.position, n3)) {
                    i2.unwrap(n3);
                    return true;
                  } else if (n3.is("element")) {
                    const t4 = i2.createRangeIn(n3);
                    for (const n4 of t4.getItems()) {
                      if (n4.is("blockQuote") && !e2.checkChild(i2.createPositionBefore(n4), n4)) {
                        i2.unwrap(n4);
                        return true;
                      }
                    }
                  }
                } else if (t3.type == "remove") {
                  const e3 = t3.position.parent;
                  if (e3.is("blockQuote") && e3.isEmpty) {
                    i2.remove(e3);
                    return true;
                  }
                }
              }
              return false;
            });
          }
          afterInit() {
            const t2 = this.editor;
            const e2 = t2.commands.get("blockQuote");
            this.listenTo(this.editor.editing.view.document, "enter", (t3, i2) => {
              const n2 = this.editor.model.document;
              const o2 = n2.selection.getLastPosition().parent;
              if (n2.selection.isCollapsed && o2.isEmpty && e2.value) {
                this.editor.execute("blockQuote");
                this.editor.editing.view.scrollToTheSelection();
                i2.preventDefault();
                t3.stop();
              }
            });
          }
        }
        var wk = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
        var kk = i(45);
        class _k extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add("blockQuote", (i2) => {
              const n2 = t2.commands.get("blockQuote");
              const o2 = new hb(i2);
              o2.set({label: e2("jc"), icon: wk, tooltip: true, isToggleable: true});
              o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute("blockQuote");
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class vk extends mp {
          static get requires() {
            return [bk, _k];
          }
          static get pluginName() {
            return "BlockQuote";
          }
        }
        class yk extends jw {
          constructor(t2, e2) {
            super(t2);
            this.attributeKey = e2;
          }
          refresh() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            this.value = this._getValueFromFirstAllowedNode();
            this.isEnabled = t2.schema.checkAttributeInSelection(e2.selection, this.attributeKey);
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = e2.document;
            const n2 = i2.selection;
            const o2 = t2.forceValue === void 0 ? !this.value : t2.forceValue;
            e2.change((t3) => {
              if (n2.isCollapsed) {
                if (o2) {
                  t3.setSelectionAttribute(this.attributeKey, true);
                } else {
                  t3.removeSelectionAttribute(this.attributeKey);
                }
              } else {
                const i3 = e2.schema.getValidRanges(n2.getRanges(), this.attributeKey);
                for (const e3 of i3) {
                  if (o2) {
                    t3.setAttribute(this.attributeKey, o2, e3);
                  } else {
                    t3.removeAttribute(this.attributeKey, e3);
                  }
                }
              }
            });
          }
          _getValueFromFirstAllowedNode() {
            const t2 = this.editor.model;
            const e2 = t2.schema;
            const i2 = t2.document.selection;
            if (i2.isCollapsed) {
              return i2.hasAttribute(this.attributeKey);
            }
            for (const t3 of i2.getRanges()) {
              for (const i3 of t3.getItems()) {
                if (e2.checkAttribute(i3, this.attributeKey)) {
                  return i3.hasAttribute(this.attributeKey);
                }
              }
            }
            return false;
          }
        }
        const xk = "bold";
        class Ck extends mp {
          static get pluginName() {
            return "BoldEditing";
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", {allowAttributes: xk});
            t2.model.schema.setAttributeProperties(xk, {isFormatting: true, copyOnEnter: true});
            t2.conversion.attributeToElement({
              model: xk,
              view: "strong",
              upcastAlso: ["b", (t3) => {
                const e2 = t3.getStyle("font-weight");
                if (!e2) {
                  return null;
                }
                if (e2 == "bold" || Number(e2) >= 600) {
                  return {name: true, styles: ["font-weight"]};
                }
              }]
            });
            t2.commands.add(xk, new yk(t2, xk));
            t2.keystrokes.set("CTRL+B", xk);
          }
        }
        var Ak = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
        const Tk = "bold";
        class Pk extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add(Tk, (i2) => {
              const n2 = t2.commands.get(Tk);
              const o2 = new hb(i2);
              o2.set({label: e2("ji"), icon: Ak, keystroke: "CTRL+B", tooltip: true, isToggleable: true});
              o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute(Tk);
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class Sk extends mp {
          static get requires() {
            return [Ck, Pk];
          }
          static get pluginName() {
            return "Bold";
          }
        }
        class Ek extends jw {
          constructor(t2, e2) {
            super(t2);
            this.attributeKey = e2;
          }
          refresh() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            this.value = e2.selection.getAttribute(this.attributeKey);
            this.isEnabled = t2.schema.checkAttributeInSelection(e2.selection, this.attributeKey);
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = e2.document;
            const n2 = i2.selection;
            const o2 = t2.value;
            e2.change((t3) => {
              if (n2.isCollapsed) {
                if (o2) {
                  t3.setSelectionAttribute(this.attributeKey, o2);
                } else {
                  t3.removeSelectionAttribute(this.attributeKey);
                }
              } else {
                const i3 = e2.schema.getValidRanges(n2.getRanges(), this.attributeKey);
                for (const e3 of i3) {
                  if (o2) {
                    t3.setAttribute(this.attributeKey, o2, e3);
                  } else {
                    t3.removeAttribute(this.attributeKey, e3);
                  }
                }
              }
            });
          }
        }
        var Rk = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035L8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
        class Ok extends hb {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("color");
            this.set("hasBorder");
            this.icon = Rk;
            this.extendTemplate({
              attributes: {
                style: {backgroundColor: e2.to("color")},
                class: ["ck", "ck-color-grid__tile", e2.if("hasBorder", "ck-color-table__color-tile_bordered")]
              }
            });
          }
          render() {
            super.render();
            this.iconView.fillColor = "hsl(0, 0%, 100%)";
          }
        }
        var Ik = i(47);
        class Vk extends Gp {
          constructor(t2, e2) {
            super(t2);
            const i2 = e2 && e2.colorDefinitions || [];
            const n2 = {};
            if (e2 && e2.columns) {
              n2.gridTemplateColumns = `repeat( ${e2.columns}, 1fr)`;
            }
            this.set("selectedColor");
            this.items = this.createCollection();
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this._focusCycler = new yb({
              focusables: this.items,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: "arrowleft", focusNext: "arrowright"}
            });
            this.items.on("add", (t3, e3) => {
              e3.isOn = e3.color === this.selectedColor;
            });
            i2.forEach((t3) => {
              const e3 = new Ok();
              e3.set({color: t3.color, label: t3.label, tooltip: true, hasBorder: t3.options.hasBorder});
              e3.on("execute", () => {
                this.fire("execute", {value: t3.color, hasBorder: t3.options.hasBorder, label: t3.label});
              });
              this.items.add(e3);
            });
            this.setTemplate({
              tag: "div",
              children: this.items,
              attributes: {class: ["ck", "ck-color-grid"], style: n2}
            });
            this.on("change:selectedColor", (t3, e3, i3) => {
              for (const t4 of this.items) {
                t4.isOn = t4.color === i3;
              }
            });
          }
          focus() {
            if (this.items.length) {
              this.items.first.focus();
            }
          }
          focusLast() {
            if (this.items.length) {
              this.items.last.focus();
            }
          }
          render() {
            super.render();
            for (const t2 of this.items) {
              this.focusTracker.add(t2.element);
            }
            this.items.on("add", (t2, e2) => {
              this.focusTracker.add(e2.element);
            });
            this.items.on("remove", (t2, e2) => {
              this.focusTracker.remove(e2.element);
            });
            this.keystrokes.listenTo(this.element);
          }
        }
        var Nk = i(49);
        class Mk extends Gp {
          constructor(t2) {
            super(t2);
            this.set("text");
            this.set("for");
            this.id = `ck-editor__label_${is()}`;
            const e2 = this.bindTemplate;
            this.setTemplate({
              tag: "label",
              attributes: {class: ["ck", "ck-label"], id: this.id, for: e2.to("for")},
              children: [{text: e2.to("text")}]
            });
          }
        }
        class Bk extends ys {
          constructor(t2) {
            super(t2);
            this.set("isEmpty", true);
          }
          add(t2, e2) {
            if (this.find((e3) => e3.color === t2.color)) {
              return;
            }
            super.add(t2, e2);
            this.set("isEmpty", false);
          }
          remove(t2) {
            const e2 = super.remove(t2);
            if (this.length === 0) {
              this.set("isEmpty", true);
            }
            return e2;
          }
          hasColor(t2) {
            return !!this.find((e2) => e2.color === t2);
          }
        }
        vs(Bk, Jc);
        var zk = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.636 9.531l-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
        var Lk = i(51);
        class Fk extends Gp {
          constructor(t2, {colors: e2, columns: i2, removeButtonLabel: n2, documentColorsLabel: o2, documentColorsCount: r2}) {
            super(t2);
            this.items = this.createCollection();
            this.colorDefinitions = e2;
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this.set("selectedColor");
            this.removeButtonLabel = n2;
            this.columns = i2;
            this.documentColors = new Bk();
            this.documentColorsCount = r2;
            this._focusCycler = new yb({
              focusables: this.items,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: "arrowup", focusNext: "arrowdown"}
            });
            this._documentColorsLabel = o2;
            this.setTemplate({tag: "div", attributes: {class: ["ck", "ck-color-table"]}, children: this.items});
            this.items.add(this._removeColorButton());
          }
          updateDocumentColors(t2, e2) {
            const i2 = t2.document;
            const n2 = this.documentColorsCount;
            this.documentColors.clear();
            for (const o2 of i2.getRootNames()) {
              const r2 = i2.getRoot(o2);
              const s2 = t2.createRangeIn(r2);
              for (const t3 of s2.getItems()) {
                if (t3.is("textProxy") && t3.hasAttribute(e2)) {
                  this._addColorToDocumentColors(t3.getAttribute(e2));
                  if (this.documentColors.length >= n2) {
                    return;
                  }
                }
              }
            }
          }
          updateSelectedColors() {
            const t2 = this.documentColorsGrid;
            const e2 = this.staticColorsGrid;
            const i2 = this.selectedColor;
            e2.selectedColor = i2;
            if (t2) {
              t2.selectedColor = i2;
            }
          }
          render() {
            super.render();
            for (const t2 of this.items) {
              this.focusTracker.add(t2.element);
            }
            this.keystrokes.listenTo(this.element);
          }
          appendGrids() {
            if (this.staticColorsGrid) {
              return;
            }
            this.staticColorsGrid = this._createStaticColorsGrid();
            this.items.add(this.staticColorsGrid);
            if (this.documentColorsCount) {
              const t2 = _p.bind(this.documentColors, this.documentColors);
              const e2 = new Mk(this.locale);
              e2.text = this._documentColorsLabel;
              e2.extendTemplate({attributes: {class: ["ck", "ck-color-grid__label", t2.if("isEmpty", "ck-hidden")]}});
              this.items.add(e2);
              this.documentColorsGrid = this._createDocumentColorsGrid();
              this.items.add(this.documentColorsGrid);
            }
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          _removeColorButton() {
            const t2 = new hb();
            t2.set({withText: true, icon: zk, tooltip: true, label: this.removeButtonLabel});
            t2.class = "ck-color-table__remove-color";
            t2.on("execute", () => {
              this.fire("execute", {value: null});
            });
            return t2;
          }
          _createStaticColorsGrid() {
            const t2 = new Vk(this.locale, {colorDefinitions: this.colorDefinitions, columns: this.columns});
            t2.delegate("execute").to(this);
            return t2;
          }
          _createDocumentColorsGrid() {
            const t2 = _p.bind(this.documentColors, this.documentColors);
            const e2 = new Vk(this.locale, {columns: this.columns});
            e2.delegate("execute").to(this);
            e2.extendTemplate({attributes: {class: t2.if("isEmpty", "ck-hidden")}});
            e2.items.bindTo(this.documentColors).using((t3) => {
              const e3 = new Ok();
              e3.set({color: t3.color, hasBorder: t3.options && t3.options.hasBorder});
              if (t3.label) {
                e3.set({label: t3.label, tooltip: true});
              }
              e3.on("execute", () => {
                this.fire("execute", {value: t3.color});
              });
              return e3;
            });
            this.documentColors.on("change:isEmpty", (t3, i2, n2) => {
              if (n2) {
                e2.selectedColor = null;
              }
            });
            return e2;
          }
          _addColorToDocumentColors(t2) {
            const e2 = this.colorDefinitions.find((e3) => e3.color === t2);
            if (!e2) {
              this.documentColors.add({color: t2, label: t2, options: {hasBorder: false}});
            } else {
              this.documentColors.add(Object.assign({}, e2));
            }
          }
        }
        const Dk = "fontSize";
        const jk = "fontFamily";
        const Hk = "fontColor";
        const Wk = "fontBackgroundColor";
        function qk(t2, e2) {
          const i2 = {model: {key: t2, values: []}, view: {}, upcastAlso: {}};
          for (const t3 of e2) {
            i2.model.values.push(t3.model);
            i2.view[t3.model] = t3.view;
            if (t3.upcastAlso) {
              i2.upcastAlso[t3.model] = t3.upcastAlso;
            }
          }
          return i2;
        }
        function Uk(t2) {
          return (e2) => Kk(e2.getStyle(t2));
        }
        function $k(t2) {
          return (e2, i2) => i2.createAttributeElement("span", {style: `${t2}:${e2}`}, {priority: 7});
        }
        function Gk({dropdownView: t2, colors: e2, columns: i2, removeButtonLabel: n2, documentColorsLabel: o2, documentColorsCount: r2}) {
          const s2 = t2.locale;
          const a2 = new Fk(s2, {
            colors: e2,
            columns: i2,
            removeButtonLabel: n2,
            documentColorsLabel: o2,
            documentColorsCount: r2
          });
          t2.colorTableView = a2;
          t2.panelView.children.add(a2);
          a2.delegate("execute").to(t2, "execute");
          return a2;
        }
        function Kk(t2) {
          return t2.replace(/\s/g, "");
        }
        class Jk extends Ek {
          constructor(t2) {
            super(t2, jk);
          }
        }
        function Yk(t2) {
          return t2.map(Qk).filter((t3) => !!t3);
        }
        function Qk(t2) {
          if (typeof t2 === "object") {
            return t2;
          }
          if (t2 === "default") {
            return {title: "Default", model: void 0};
          }
          if (typeof t2 !== "string") {
            return;
          }
          return Xk(t2);
        }
        function Xk(t2) {
          const e2 = t2.replace(/"|'/g, "").split(",");
          const i2 = e2[0];
          const n2 = e2.map(Zk).join(", ");
          return {title: i2, model: i2, view: {name: "span", styles: {"font-family": n2}, priority: 7}};
        }
        function Zk(t2) {
          t2 = t2.trim();
          if (t2.indexOf(" ") > 0) {
            t2 = `'${t2}'`;
          }
          return t2;
        }
        class t_ extends mp {
          static get pluginName() {
            return "FontFamilyEditing";
          }
          constructor(t2) {
            super(t2);
            t2.config.define(jk, {options: ["default", "Arial, Helvetica, sans-serif", "Courier New, Courier, monospace", "Georgia, serif", "Lucida Sans Unicode, Lucida Grande, sans-serif", "Tahoma, Geneva, sans-serif", "Times New Roman, Times, serif", "Trebuchet MS, Helvetica, sans-serif", "Verdana, Geneva, sans-serif"]});
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", {allowAttributes: jk});
            t2.model.schema.setAttributeProperties(jk, {isFormatting: true, copyOnEnter: true});
            const e2 = Yk(t2.config.get("fontFamily.options")).filter((t3) => t3.model);
            const i2 = qk(jk, e2);
            t2.conversion.attributeToElement(i2);
            t2.commands.add(jk, new Jk(t2));
          }
        }
        class e_ {
          constructor(t2, e2) {
            if (e2) {
              qc(this, e2);
            }
            if (t2) {
              this.set(t2);
            }
          }
        }
        vs(e_, Jc);
        var i_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>';
        class n_ extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            const i2 = this._getLocalizedOptions();
            const n2 = t2.commands.get(jk);
            t2.ui.componentFactory.add(jk, (o2) => {
              const r2 = Wb(o2);
              Ub(r2, o_(i2, n2));
              r2.buttonView.set({label: e2("jo"), icon: i_, tooltip: true});
              r2.extendTemplate({attributes: {class: "ck-font-family-dropdown"}});
              r2.bind("isEnabled").to(n2);
              this.listenTo(r2, "execute", (e3) => {
                t2.execute(e3.source.commandName, {value: e3.source.commandParam});
                t2.editing.view.focus();
              });
              return r2;
            });
          }
          _getLocalizedOptions() {
            const t2 = this.editor;
            const e2 = t2.t;
            const i2 = Yk(t2.config.get(jk).options);
            return i2.map((t3) => {
              if (t3.title === "Default") {
                t3.title = e2("jp");
              }
              return t3;
            });
          }
        }
        function o_(t2, e2) {
          const i2 = new ys();
          for (const n2 of t2) {
            const t3 = {
              type: "button",
              model: new e_({commandName: jk, commandParam: n2.model, label: n2.title, withText: true})
            };
            t3.model.bind("isOn").to(e2, "value", (t4) => t4 === n2.model);
            if (n2.view && n2.view.styles) {
              t3.model.set("labelStyle", `font-family: ${n2.view.styles["font-family"]}`);
            }
            i2.add(t3);
          }
          return i2;
        }
        class r_ extends mp {
          static get requires() {
            return [t_, n_];
          }
          static get pluginName() {
            return "FontFamily";
          }
        }
        class s_ extends Ek {
          constructor(t2) {
            super(t2, Dk);
          }
        }
        function a_(t2) {
          return t2.map(l_).filter((t3) => !!t3);
        }
        const c_ = {
          tiny: {title: "Tiny", model: "tiny", view: {name: "span", classes: "text-tiny", priority: 7}},
          small: {title: "Small", model: "small", view: {name: "span", classes: "text-small", priority: 7}},
          big: {title: "Big", model: "big", view: {name: "span", classes: "text-big", priority: 7}},
          huge: {title: "Huge", model: "huge", view: {name: "span", classes: "text-huge", priority: 7}}
        };
        function l_(t2) {
          if (typeof t2 === "object") {
            return t2;
          }
          if (c_[t2]) {
            return c_[t2];
          }
          if (t2 === "default") {
            return {model: void 0, title: "Default"};
          }
          const e2 = parseFloat(t2);
          if (isNaN(e2)) {
            return;
          }
          return d_(e2);
        }
        function d_(t2) {
          const e2 = String(t2);
          return {title: e2, model: t2, view: {name: "span", styles: {"font-size": `${t2}px`}, priority: 7}};
        }
        class u_ extends mp {
          static get pluginName() {
            return "FontSizeEditing";
          }
          constructor(t2) {
            super(t2);
            t2.config.define(Dk, {options: ["tiny", "small", "default", "big", "huge"]});
            const e2 = a_(this.editor.config.get("fontSize.options")).filter((t3) => t3.model);
            const i2 = qk(Dk, e2);
            t2.conversion.attributeToElement(i2);
            t2.commands.add(Dk, new s_(t2));
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", {allowAttributes: Dk});
            t2.model.schema.setAttributeProperties(Dk, {isFormatting: true, copyOnEnter: true});
          }
        }
        var h_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5L7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279l.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
        var f_ = i(53);
        class g_ extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            const i2 = this._getLocalizedOptions();
            const n2 = t2.commands.get(Dk);
            t2.ui.componentFactory.add(Dk, (o2) => {
              const r2 = Wb(o2);
              Ub(r2, m_(i2, n2));
              r2.buttonView.set({label: e2("jq"), icon: h_, tooltip: true});
              r2.extendTemplate({attributes: {class: ["ck-font-size-dropdown"]}});
              r2.bind("isEnabled").to(n2);
              this.listenTo(r2, "execute", (e3) => {
                t2.execute(e3.source.commandName, {value: e3.source.commandParam});
                t2.editing.view.focus();
              });
              return r2;
            });
          }
          _getLocalizedOptions() {
            const t2 = this.editor;
            const e2 = t2.t;
            const i2 = {Default: e2("jp"), Tiny: e2("jr"), Small: e2("js"), Big: e2("jt"), Huge: e2("ju")};
            const n2 = a_(t2.config.get(Dk).options);
            return n2.map((t3) => {
              const e3 = i2[t3.title];
              if (e3 && e3 != t3.title) {
                t3 = Object.assign({}, t3, {title: e3});
              }
              return t3;
            });
          }
        }
        function m_(t2, e2) {
          const i2 = new ys();
          for (const n2 of t2) {
            const t3 = {
              type: "button",
              model: new e_({
                commandName: Dk,
                commandParam: n2.model,
                label: n2.title,
                class: "ck-fontsize-option",
                withText: true
              })
            };
            if (n2.view && n2.view.styles) {
              t3.model.set("labelStyle", `font-size:${n2.view.styles["font-size"]}`);
            }
            if (n2.view && n2.view.classes) {
              t3.model.set("class", `${t3.model.class} ${n2.view.classes}`);
            }
            t3.model.bind("isOn").to(e2, "value", (t4) => t4 === n2.model);
            i2.add(t3);
          }
          return i2;
        }
        class p_ extends mp {
          static get requires() {
            return [u_, g_];
          }
          static get pluginName() {
            return "FontSize";
          }
        }
        class b_ extends Ek {
          constructor(t2) {
            super(t2, Hk);
          }
        }
        class w_ extends mp {
          static get pluginName() {
            return "FontColorEditing";
          }
          constructor(t2) {
            super(t2);
            t2.config.define(Hk, {
              colors: [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
                color: "hsl(0, 0%, 30%)",
                label: "Dim grey"
              }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
                color: "hsl(0, 0%, 90%)",
                label: "Light grey"
              }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true}, {
                color: "hsl(0, 75%, 60%)",
                label: "Red"
              }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
                color: "hsl(60, 75%, 60%)",
                label: "Yellow"
              }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
                color: "hsl(120, 75%, 60%)",
                label: "Green"
              }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
                color: "hsl(180, 75%, 60%)",
                label: "Turquoise"
              }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
                color: "hsl(240, 75%, 60%)",
                label: "Blue"
              }, {color: "hsl(270, 75%, 60%)", label: "Purple"}],
              columns: 5
            });
            t2.conversion.for("upcast").elementToAttribute({
              view: {name: "span", styles: {color: /[\s\S]+/}},
              model: {key: Hk, value: Uk("color")}
            });
            t2.conversion.for("downcast").attributeToElement({model: Hk, view: $k("color")});
            t2.commands.add(Hk, new b_(t2));
            t2.model.schema.extend("$text", {allowAttributes: Hk});
            t2.model.schema.setAttributeProperties(Hk, {isFormatting: true, copyOnEnter: true});
          }
        }
        function k_(t2, e2) {
          const i2 = t2.t;
          const n2 = {
            Black: i2("lx"),
            "Dim grey": i2("ly"),
            Grey: i2("lz"),
            "Light grey": i2("ma"),
            White: i2("mb"),
            Red: i2("mc"),
            Orange: i2("md"),
            Yellow: i2("me"),
            "Light green": i2("mf"),
            Green: i2("mg"),
            Aquamarine: i2("mh"),
            Turquoise: i2("mi"),
            "Light blue": i2("mj"),
            Blue: i2("mk"),
            Purple: i2("ml")
          };
          return e2.map((t3) => {
            const e3 = n2[t3.label];
            if (e3 && e3 != t3.label) {
              t3.label = e3;
            }
            return t3;
          });
        }
        function __(t2) {
          return t2.map(v_).filter((t3) => !!t3);
        }
        function v_(t2) {
          if (typeof t2 === "string") {
            return {
              model: t2.replace(/ /g, ""),
              label: t2,
              hasBorder: false,
              view: {name: "span", styles: {color: t2}}
            };
          } else {
            return {
              model: t2.color.replace(/ /g, ""),
              label: t2.label || t2.color,
              hasBorder: t2.hasBorder === void 0 ? false : t2.hasBorder,
              view: {name: "span", styles: {color: `${t2.color}`}}
            };
          }
        }
        class y_ extends mp {
          constructor(t2, {commandName: e2, icon: i2, componentName: n2, dropdownLabel: o2}) {
            super(t2);
            this.commandName = e2;
            this.componentName = n2;
            this.icon = i2;
            this.dropdownLabel = o2;
            this.columns = t2.config.get(`${this.componentName}.columns`);
            this.colorTableView;
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.locale;
            const i2 = e2.t;
            const n2 = t2.commands.get(this.commandName);
            const o2 = __(t2.config.get(this.componentName).colors);
            const r2 = k_(e2, o2);
            const s2 = t2.config.get(`${this.componentName}.documentColors`);
            t2.ui.componentFactory.add(this.componentName, (e3) => {
              const o3 = Wb(e3);
              this.colorTableView = Gk({
                dropdownView: o3,
                colors: r2.map((t3) => ({label: t3.label, color: t3.model, options: {hasBorder: t3.hasBorder}})),
                columns: this.columns,
                removeButtonLabel: i2("li"),
                documentColorsLabel: s2 !== 0 ? i2("lj") : void 0,
                documentColorsCount: s2 === void 0 ? this.columns : s2
              });
              this.colorTableView.bind("selectedColor").to(n2, "value");
              o3.buttonView.set({label: this.dropdownLabel, icon: this.icon, tooltip: true});
              o3.extendTemplate({attributes: {class: "ck-color-ui-dropdown"}});
              o3.bind("isEnabled").to(n2);
              o3.on("execute", (e4, i3) => {
                t2.execute(this.commandName, i3);
                t2.editing.view.focus();
              });
              o3.on("change:isOpen", (e4, i3, n3) => {
                o3.colorTableView.appendGrids();
                if (n3) {
                  if (s2 !== 0) {
                    this.colorTableView.updateDocumentColors(t2.model, this.componentName);
                  }
                  this.colorTableView.updateSelectedColors();
                }
              });
              return o3;
            });
          }
        }
        var x_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3L10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
        class C_ extends y_ {
          constructor(t2) {
            const e2 = t2.locale.t;
            super(t2, {commandName: Hk, componentName: Hk, icon: x_, dropdownLabel: e2("jv")});
          }
          static get pluginName() {
            return "FontColorUI";
          }
        }
        class A_ extends mp {
          static get requires() {
            return [w_, C_];
          }
          static get pluginName() {
            return "FontColor";
          }
        }
        class T_ extends Ek {
          constructor(t2) {
            super(t2, Wk);
          }
        }
        class P_ extends mp {
          static get pluginName() {
            return "FontBackgroundColorEditing";
          }
          constructor(t2) {
            super(t2);
            t2.config.define(Wk, {
              colors: [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
                color: "hsl(0, 0%, 30%)",
                label: "Dim grey"
              }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
                color: "hsl(0, 0%, 90%)",
                label: "Light grey"
              }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true}, {
                color: "hsl(0, 75%, 60%)",
                label: "Red"
              }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
                color: "hsl(60, 75%, 60%)",
                label: "Yellow"
              }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
                color: "hsl(120, 75%, 60%)",
                label: "Green"
              }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
                color: "hsl(180, 75%, 60%)",
                label: "Turquoise"
              }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
                color: "hsl(240, 75%, 60%)",
                label: "Blue"
              }, {color: "hsl(270, 75%, 60%)", label: "Purple"}],
              columns: 5
            });
            t2.conversion.for("upcast").elementToAttribute({
              view: {
                name: "span",
                styles: {"background-color": /[\s\S]+/}
              },
              model: {key: Wk, value: Uk("background-color")}
            });
            t2.conversion.for("downcast").attributeToElement({model: Wk, view: $k("background-color")});
            t2.commands.add(Wk, new T_(t2));
            t2.model.schema.extend("$text", {allowAttributes: Wk});
            t2.model.schema.setAttributeProperties(Wk, {isFormatting: true, copyOnEnter: true});
          }
        }
        var S_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';
        class E_ extends y_ {
          constructor(t2) {
            const e2 = t2.locale.t;
            super(t2, {commandName: Wk, componentName: Wk, icon: S_, dropdownLabel: e2("jw")});
          }
          static get pluginName() {
            return "FontBackgroundColorUI";
          }
        }
        class R_ extends mp {
          static get requires() {
            return [P_, E_];
          }
          static get pluginName() {
            return "FontBackgroundColor";
          }
        }
        class O_ extends jw {
          refresh() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            const i2 = Ww(e2.selection.getSelectedBlocks());
            this.value = !!i2 && i2.is("paragraph");
            this.isEnabled = !!i2 && I_(i2, t2.schema);
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = e2.document;
            e2.change((n2) => {
              const o2 = (t2.selection || i2.selection).getSelectedBlocks();
              for (const t3 of o2) {
                if (!t3.is("paragraph") && I_(t3, e2.schema)) {
                  n2.rename(t3, "paragraph");
                }
              }
            });
          }
        }
        function I_(t2, e2) {
          return e2.checkChild(t2.parent, "paragraph") && !e2.isObject(t2);
        }
        class V_ extends mp {
          static get pluginName() {
            return "Paragraph";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model;
            const i2 = t2.data;
            t2.commands.add("paragraph", new O_(t2));
            e2.schema.register("paragraph", {inheritAllFrom: "$block"});
            t2.conversion.elementToElement({model: "paragraph", view: "p"});
            t2.conversion.for("upcast").elementToElement({
              model: (t3, e3) => {
                if (!V_.paragraphLikeElements.has(t3.name)) {
                  return null;
                }
                if (t3.isEmpty) {
                  return null;
                }
                return e3.createElement("paragraph");
              },
              converterPriority: "low"
            });
            i2.upcastDispatcher.on("element", (t3, e3, i3) => {
              if (!i3.consumable.test(e3.viewItem, {name: e3.viewItem.name})) {
                return;
              }
              if (M_(e3.viewItem, e3.modelCursor, i3.schema)) {
                Object.assign(e3, N_(e3.viewItem, e3.modelCursor, i3));
              }
            }, {priority: "low"});
            i2.upcastDispatcher.on("text", (t3, e3, i3) => {
              if (e3.modelRange) {
                return;
              }
              if (M_(e3.viewItem, e3.modelCursor, i3.schema)) {
                Object.assign(e3, N_(e3.viewItem, e3.modelCursor, i3));
              }
            }, {priority: "lowest"});
            e2.document.registerPostFixer((t3) => this._autoparagraphEmptyRoots(t3));
            t2.data.on("ready", () => {
              e2.enqueueChange("transparent", (t3) => this._autoparagraphEmptyRoots(t3));
            }, {priority: "lowest"});
          }
          _autoparagraphEmptyRoots(t2) {
            const e2 = this.editor.model;
            for (const i2 of e2.document.getRootNames()) {
              const n2 = e2.document.getRoot(i2);
              if (n2.isEmpty && n2.rootName != "$graveyard") {
                if (e2.schema.checkChild(n2, "paragraph")) {
                  t2.insertElement("paragraph", n2);
                  return true;
                }
              }
            }
          }
        }
        V_.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td"]);
        function N_(t2, e2, i2) {
          const n2 = i2.writer.createElement("paragraph");
          i2.writer.insert(n2, e2);
          return i2.convertItem(t2, i2.writer.createPositionAt(n2, 0));
        }
        function M_(t2, e2, i2) {
          const n2 = i2.createContext(e2);
          if (!i2.checkChild(n2, "paragraph")) {
            return false;
          }
          if (!i2.checkChild(n2.push("paragraph"), t2)) {
            return false;
          }
          return true;
        }
        class B_ extends jw {
          constructor(t2, e2) {
            super(t2);
            this.modelElements = e2;
          }
          refresh() {
            const t2 = Ww(this.editor.model.document.selection.getSelectedBlocks());
            this.value = !!t2 && this.modelElements.includes(t2.name) && t2.name;
            this.isEnabled = !!t2 && this.modelElements.some((e2) => z_(t2, e2, this.editor.model.schema));
          }
          execute(t2) {
            const e2 = this.editor.model;
            const i2 = e2.document;
            const n2 = t2.value;
            e2.change((t3) => {
              const o2 = Array.from(i2.selection.getSelectedBlocks()).filter((t4) => z_(t4, n2, e2.schema));
              for (const e3 of o2) {
                if (!e3.is(n2)) {
                  t3.rename(e3, n2);
                }
              }
            });
          }
        }
        function z_(t2, e2, i2) {
          return i2.checkChild(t2.parent, e2) && !i2.isObject(t2);
        }
        const L_ = "paragraph";
        class F_ extends mp {
          static get pluginName() {
            return "HeadingEditing";
          }
          constructor(t2) {
            super(t2);
            t2.config.define("heading", {
              options: [{
                model: "paragraph",
                title: "Paragraph",
                class: "ck-heading_paragraph"
              }, {
                model: "heading1",
                view: "h2",
                title: "Heading 1",
                class: "ck-heading_heading1"
              }, {
                model: "heading2",
                view: "h3",
                title: "Heading 2",
                class: "ck-heading_heading2"
              }, {model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3"}]
            });
          }
          static get requires() {
            return [V_];
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.config.get("heading.options");
            const i2 = [];
            for (const n2 of e2) {
              if (n2.model !== L_) {
                t2.model.schema.register(n2.model, {inheritAllFrom: "$block"});
                t2.conversion.elementToElement(n2);
                i2.push(n2.model);
              }
            }
            this._addDefaultH1Conversion(t2);
            t2.commands.add("heading", new B_(t2, i2));
          }
          afterInit() {
            const t2 = this.editor;
            const e2 = t2.commands.get("enter");
            const i2 = t2.config.get("heading.options");
            if (e2) {
              this.listenTo(e2, "afterExecute", (e3, n2) => {
                const o2 = t2.model.document.selection.getFirstPosition().parent;
                const r2 = i2.some((t3) => o2.is(t3.model));
                if (r2 && !o2.is(L_) && o2.childCount === 0) {
                  n2.writer.rename(o2, L_);
                }
              });
            }
          }
          _addDefaultH1Conversion(t2) {
            t2.conversion.for("upcast").elementToElement({
              model: "heading1",
              view: "h1",
              converterPriority: os.get("low") + 1
            });
          }
        }
        function D_(t2) {
          const e2 = t2.t;
          const i2 = {
            Paragraph: e2("ny"),
            "Heading 1": e2("nz"),
            "Heading 2": e2("oa"),
            "Heading 3": e2("ob"),
            "Heading 4": e2("oc"),
            "Heading 5": e2("od"),
            "Heading 6": e2("oe")
          };
          return t2.config.get("heading.options").map((t3) => {
            const e3 = i2[t3.title];
            if (e3 && e3 != t3.title) {
              t3.title = e3;
            }
            return t3;
          });
        }
        var j_ = i(11);
        class H_ extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            const i2 = D_(t2);
            const n2 = e2("jd");
            const o2 = e2("je");
            t2.ui.componentFactory.add("heading", (e3) => {
              const r2 = {};
              const s2 = new ys();
              const a2 = t2.commands.get("heading");
              const c2 = t2.commands.get("paragraph");
              const l2 = [a2];
              for (const t3 of i2) {
                const e4 = {type: "button", model: new e_({label: t3.title, class: t3.class, withText: true})};
                if (t3.model === "paragraph") {
                  e4.model.bind("isOn").to(c2, "value");
                  e4.model.set("commandName", "paragraph");
                  l2.push(c2);
                } else {
                  e4.model.bind("isOn").to(a2, "value", (e5) => e5 === t3.model);
                  e4.model.set({commandName: "heading", commandValue: t3.model});
                }
                s2.add(e4);
                r2[t3.model] = t3.title;
              }
              const d2 = Wb(e3);
              Ub(d2, s2);
              d2.buttonView.set({isOn: false, withText: true, tooltip: o2});
              d2.extendTemplate({attributes: {class: ["ck-heading-dropdown"]}});
              d2.bind("isEnabled").toMany(l2, "isEnabled", (...t3) => t3.some((t4) => t4));
              d2.buttonView.bind("label").to(a2, "value", c2, "value", (t3, e4) => {
                const i3 = t3 || e4 && "paragraph";
                return r2[i3] ? r2[i3] : n2;
              });
              this.listenTo(d2, "execute", (e4) => {
                t2.execute(e4.source.commandName, e4.source.commandValue ? {value: e4.source.commandValue} : void 0);
                t2.editing.view.focus();
              });
              return d2;
            });
          }
        }
        class W_ extends mp {
          static get requires() {
            return [F_, H_];
          }
          static get pluginName() {
            return "Heading";
          }
        }
        class q_ {
          constructor() {
            this._stack = [];
          }
          add(t2, e2) {
            const i2 = this._stack;
            const n2 = i2[0];
            this._insertDescriptor(t2);
            const o2 = i2[0];
            if (n2 !== o2 && !U_(n2, o2)) {
              this.fire("change:top", {oldDescriptor: n2, newDescriptor: o2, writer: e2});
            }
          }
          remove(t2, e2) {
            const i2 = this._stack;
            const n2 = i2[0];
            this._removeDescriptor(t2);
            const o2 = i2[0];
            if (n2 !== o2 && !U_(n2, o2)) {
              this.fire("change:top", {oldDescriptor: n2, newDescriptor: o2, writer: e2});
            }
          }
          _insertDescriptor(t2) {
            const e2 = this._stack;
            const i2 = e2.findIndex((e3) => e3.id === t2.id);
            if (U_(t2, e2[i2])) {
              return;
            }
            if (i2 > -1) {
              e2.splice(i2, 1);
            }
            let n2 = 0;
            while (e2[n2] && $_(e2[n2], t2)) {
              n2++;
            }
            e2.splice(n2, 0, t2);
          }
          _removeDescriptor(t2) {
            const e2 = this._stack;
            const i2 = e2.findIndex((e3) => e3.id === t2);
            if (i2 > -1) {
              e2.splice(i2, 1);
            }
          }
        }
        vs(q_, ds);
        function U_(t2, e2) {
          return t2 && e2 && t2.priority == e2.priority && G_(t2.classes) == G_(e2.classes);
        }
        function $_(t2, e2) {
          if (t2.priority > e2.priority) {
            return true;
          } else if (t2.priority < e2.priority) {
            return false;
          }
          return G_(t2.classes) > G_(e2.classes);
        }
        function G_(t2) {
          return Array.isArray(t2) ? t2.sort().join(",") : t2;
        }
        var K_ = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
        const J_ = "ck-widget";
        const Y_ = "ck-widget_selected";
        function Q_(t2) {
          if (!t2.is("element")) {
            return false;
          }
          return !!t2.getCustomProperty("widget");
        }
        function X_(t2, e2, i2 = {}) {
          if (!Al.isEdge) {
            e2.setAttribute("contenteditable", "false", t2);
          }
          e2.addClass(J_, t2);
          e2.setCustomProperty("widget", true, t2);
          t2.getFillerOffset = rv;
          if (i2.label) {
            tv(t2, i2.label, e2);
          }
          if (i2.hasSelectionHandle) {
            sv(t2, e2);
          }
          Z_(t2, e2, (t3, e3, i3) => i3.addClass(n2(e3.classes), t3), (t3, e3, i3) => i3.removeClass(n2(e3.classes), t3));
          return t2;
          function n2(t3) {
            return Array.isArray(t3) ? t3 : [t3];
          }
        }
        function Z_(t2, e2, i2, n2) {
          const o2 = new q_();
          o2.on("change:top", (e3, o3) => {
            if (o3.oldDescriptor) {
              n2(t2, o3.oldDescriptor, o3.writer);
            }
            if (o3.newDescriptor) {
              i2(t2, o3.newDescriptor, o3.writer);
            }
          });
          e2.setCustomProperty("addHighlight", (t3, e3, i3) => o2.add(e3, i3), t2);
          e2.setCustomProperty("removeHighlight", (t3, e3, i3) => o2.remove(e3, i3), t2);
        }
        function tv(t2, e2, i2) {
          i2.setCustomProperty("widgetLabel", e2, t2);
        }
        function ev(t2) {
          const e2 = t2.getCustomProperty("widgetLabel");
          if (!e2) {
            return "";
          }
          return typeof e2 == "function" ? e2() : e2;
        }
        function iv(t2, e2) {
          e2.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t2);
          if (!Al.isEdge) {
            e2.setAttribute("contenteditable", t2.isReadOnly ? "false" : "true", t2);
            t2.on("change:isReadOnly", (i2, n2, o2) => {
              e2.setAttribute("contenteditable", o2 ? "false" : "true", t2);
            });
          }
          t2.on("change:isFocused", (i2, n2, o2) => {
            if (o2) {
              e2.addClass("ck-editor__nested-editable_focused", t2);
            } else {
              e2.removeClass("ck-editor__nested-editable_focused", t2);
            }
          });
          return t2;
        }
        function nv(t2, e2) {
          const i2 = t2.getSelectedElement();
          if (i2 && e2.schema.isBlock(i2)) {
            return e2.createPositionAfter(i2);
          }
          const n2 = t2.getSelectedBlocks().next().value;
          if (n2) {
            if (n2.isEmpty) {
              return e2.createPositionAt(n2, 0);
            }
            const i3 = e2.createPositionAfter(n2);
            if (t2.focus.isTouching(i3)) {
              return i3;
            }
            return e2.createPositionBefore(n2);
          }
          return t2.focus;
        }
        function ov(t2, e2) {
          return (i2, n2) => {
            const {mapper: o2, viewPosition: r2} = n2;
            const s2 = o2.findMappedViewAncestor(r2);
            if (!e2(s2)) {
              return;
            }
            const a2 = o2.toModelElement(s2);
            n2.modelPosition = t2.createPositionAt(a2, r2.isAtStart ? "before" : "after");
          };
        }
        function rv() {
          return null;
        }
        function sv(t2, e2) {
          const i2 = e2.createUIElement("div", {class: "ck ck-widget__selection-handle"}, function(t3) {
            const e3 = this.toDomElement(t3);
            const i3 = new cb();
            i3.set("content", K_);
            i3.render();
            e3.appendChild(i3.element);
            return e3;
          });
          e2.insert(e2.createPositionAt(t2, 0), i2);
          e2.addClass(["ck-widget_with-selection-handle"], t2);
        }
        class av extends jw {
          refresh() {
            this.isEnabled = cv(this.editor.model);
          }
          execute() {
            const t2 = this.editor.model;
            t2.change((e2) => {
              const i2 = e2.createElement("horizontalLine");
              t2.insertContent(i2);
              let n2 = i2.nextSibling;
              const o2 = n2 && t2.schema.checkChild(n2, "$text");
              if (!o2 && t2.schema.checkChild(i2.parent, "paragraph")) {
                n2 = e2.createElement("paragraph");
                t2.insertContent(n2, e2.createPositionAfter(i2));
              }
              if (n2) {
                e2.setSelection(n2, 0);
              }
            });
          }
        }
        function cv(t2) {
          const e2 = t2.schema;
          const i2 = t2.document.selection;
          return lv(i2, e2, t2) && !dv(i2, e2);
        }
        function lv(t2, e2, i2) {
          const n2 = uv(t2, i2);
          return e2.checkChild(n2, "horizontalLine");
        }
        function dv(t2, e2) {
          const i2 = t2.getSelectedElement();
          return i2 && e2.isObject(i2);
        }
        function uv(t2, e2) {
          const i2 = nv(t2, e2);
          const n2 = i2.parent;
          if (n2.isEmpty && !n2.is("$root")) {
            return n2.parent;
          }
          return n2;
        }
        var hv = i(56);
        class fv extends mp {
          static get pluginName() {
            return "HorizontalLineEditing";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.schema;
            const i2 = t2.t;
            const n2 = t2.conversion;
            e2.register("horizontalLine", {isObject: true, allowWhere: "$block"});
            n2.for("dataDowncast").elementToElement({
              model: "horizontalLine",
              view: (t3, e3) => e3.createEmptyElement("hr")
            });
            n2.for("editingDowncast").elementToElement({
              model: "horizontalLine",
              view: (t3, e3) => {
                const n3 = i2("jf");
                const o2 = e3.createContainerElement("div");
                const r2 = e3.createEmptyElement("hr");
                e3.addClass("ck-horizontal-line", o2);
                e3.setCustomProperty("hr", true, o2);
                e3.insert(e3.createPositionAt(o2, 0), r2);
                return gv(o2, e3, n3);
              }
            });
            n2.for("upcast").elementToElement({view: "hr", model: "horizontalLine"});
            t2.commands.add("horizontalLine", new av(t2));
          }
        }
        function gv(t2, e2, i2) {
          e2.setCustomProperty("horizontalLine", true, t2);
          return X_(t2, e2, {label: i2});
        }
        var mv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>';
        class pv extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add("horizontalLine", (i2) => {
              const n2 = t2.commands.get("horizontalLine");
              const o2 = new hb(i2);
              o2.set({label: e2("jf"), icon: mv, tooltip: true});
              o2.bind("isEnabled").to(n2, "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute("horizontalLine");
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class bv extends mp {
          static get requires() {
            return [fv, pv];
          }
          static get pluginName() {
            return "HorizontalLine";
          }
        }
        class wv extends Gd {
          observe(t2) {
            this.listenTo(t2, "load", (t3, e2) => {
              const i2 = e2.target;
              if (i2.tagName == "IMG") {
                this._fireEvents(e2);
              }
            }, {useCapture: true});
          }
          _fireEvents(t2) {
            if (this.isEnabled) {
              this.document.fire("layoutChanged");
              this.document.fire("imageLoaded", t2);
            }
          }
        }
        function kv(t2, e2, i2) {
          e2.setCustomProperty("image", true, t2);
          return X_(t2, e2, {label: n2});
          function n2() {
            const e3 = Av(t2);
            const n3 = e3.getAttribute("alt");
            return n3 ? `${n3} ${i2}` : i2;
          }
        }
        function _v(t2) {
          return !!t2.getCustomProperty("image") && Q_(t2);
        }
        function vv(t2) {
          const e2 = t2.getSelectedElement();
          if (e2 && _v(e2)) {
            return e2;
          }
          return null;
        }
        function yv(t2) {
          return !!t2 && t2.is("image");
        }
        function xv(t2, e2, i2 = {}) {
          const n2 = t2.createElement("image", i2);
          const o2 = nv(e2.document.selection, e2);
          e2.insertContent(n2, o2);
          if (n2.parent) {
            t2.setSelection(n2, "on");
          }
        }
        function Cv(t2) {
          const e2 = t2.schema;
          const i2 = t2.document.selection;
          return Tv(i2, e2, t2) && !Pv(i2, e2) && Sv(i2);
        }
        function Av(t2) {
          return Array.from(t2.getChildren()).find((t3) => t3.is("img"));
        }
        function Tv(t2, e2, i2) {
          const n2 = Ev(t2, i2);
          return e2.checkChild(n2, "image");
        }
        function Pv(t2, e2) {
          const i2 = t2.getSelectedElement();
          return i2 && e2.isObject(i2);
        }
        function Sv(t2) {
          return [...t2.focus.getAncestors()].every((t3) => !t3.is("image"));
        }
        function Ev(t2, e2) {
          const i2 = nv(t2, e2);
          const n2 = i2.parent;
          if (n2.isEmpty && !n2.is("$root")) {
            return n2.parent;
          }
          return n2;
        }
        function Rv() {
          return (e2) => {
            e2.on("element:figure", t2);
          };
          function t2(t3, e2, i2) {
            if (!i2.consumable.test(e2.viewItem, {name: true, classes: "image"})) {
              return;
            }
            const n2 = Av(e2.viewItem);
            if (!n2 || !n2.hasAttribute("src") || !i2.consumable.test(n2, {name: true})) {
              return;
            }
            const o2 = i2.convertItem(n2, e2.modelCursor);
            const r2 = Ww(o2.modelRange.getItems());
            if (!r2) {
              return;
            }
            i2.convertChildren(e2.viewItem, i2.writer.createPositionAt(r2, 0));
            e2.modelRange = o2.modelRange;
            e2.modelCursor = o2.modelCursor;
          }
        }
        function Ov() {
          return (e2) => {
            e2.on("attribute:srcset:image", t2);
          };
          function t2(t3, e2, i2) {
            if (!i2.consumable.consume(e2.item, t3.name)) {
              return;
            }
            const n2 = i2.writer;
            const o2 = i2.mapper.toViewElement(e2.item);
            const r2 = Av(o2);
            if (e2.attributeNewValue === null) {
              const t4 = e2.attributeOldValue;
              if (t4.data) {
                n2.removeAttribute("srcset", r2);
                n2.removeAttribute("sizes", r2);
                if (t4.width) {
                  n2.removeAttribute("width", r2);
                }
              }
            } else {
              const t4 = e2.attributeNewValue;
              if (t4.data) {
                n2.setAttribute("srcset", t4.data, r2);
                n2.setAttribute("sizes", "100vw", r2);
                if (t4.width) {
                  n2.setAttribute("width", t4.width, r2);
                }
              }
            }
          }
        }
        function Iv(t2) {
          return (i2) => {
            i2.on(`attribute:${t2}:image`, e2);
          };
          function e2(t3, e3, i2) {
            if (!i2.consumable.consume(e3.item, t3.name)) {
              return;
            }
            const n2 = i2.writer;
            const o2 = i2.mapper.toViewElement(e3.item);
            const r2 = Av(o2);
            if (e3.attributeNewValue !== null) {
              n2.setAttribute(e3.attributeKey, e3.attributeNewValue, r2);
            } else {
              n2.removeAttribute(e3.attributeKey, r2);
            }
          }
        }
        class Vv extends jw {
          refresh() {
            this.isEnabled = Cv(this.editor.model);
          }
          execute(t2) {
            const e2 = this.editor.model;
            e2.change((i2) => {
              const n2 = Array.isArray(t2.source) ? t2.source : [t2.source];
              for (const t3 of n2) {
                xv(i2, e2, {src: t3});
              }
            });
          }
        }
        class Nv extends mp {
          static get pluginName() {
            return "ImageEditing";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.schema;
            const i2 = t2.t;
            const n2 = t2.conversion;
            t2.editing.view.addObserver(wv);
            e2.register("image", {
              isObject: true,
              isBlock: true,
              allowWhere: "$block",
              allowAttributes: ["alt", "src", "srcset"]
            });
            n2.for("dataDowncast").elementToElement({model: "image", view: (t3, e3) => Mv(e3)});
            n2.for("editingDowncast").elementToElement({model: "image", view: (t3, e3) => kv(Mv(e3), e3, i2("jx"))});
            n2.for("downcast").add(Iv("src")).add(Iv("alt")).add(Ov());
            n2.for("upcast").elementToElement({
              view: {name: "img", attributes: {src: true}},
              model: (t3, e3) => e3.createElement("image", {src: t3.getAttribute("src")})
            }).attributeToAttribute({
              view: {name: "img", key: "alt"},
              model: "alt"
            }).attributeToAttribute({
              view: {name: "img", key: "srcset"},
              model: {
                key: "srcset",
                value: (t3) => {
                  const e3 = {data: t3.getAttribute("srcset")};
                  if (t3.hasAttribute("width")) {
                    e3.width = t3.getAttribute("width");
                  }
                  return e3;
                }
              }
            }).add(Rv());
            t2.commands.add("imageInsert", new Vv(t2));
          }
        }
        function Mv(t2) {
          const e2 = t2.createEmptyElement("img");
          const i2 = t2.createContainerElement("figure", {class: "image"});
          t2.insert(t2.createPositionAt(i2, 0), e2);
          return i2;
        }
        class Bv extends Ju {
          constructor(t2) {
            super(t2);
            this.domEventType = "mousedown";
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        var zv = i(58);
        const Lv = Bl("Ctrl+A");
        class Fv extends mp {
          static get pluginName() {
            return "Widget";
          }
          init() {
            const t2 = this.editor.editing.view;
            const e2 = t2.document;
            this._previouslySelected = new Set();
            this.editor.editing.downcastDispatcher.on("selection", (t3, e3, i2) => {
              this._clearPreviouslySelectedWidgets(i2.writer);
              const n2 = i2.writer;
              const o2 = n2.document.selection;
              const r2 = o2.getSelectedElement();
              let s2 = null;
              for (const t4 of o2.getRanges()) {
                for (const e4 of t4) {
                  const t5 = e4.item;
                  if (Q_(t5) && !Wv(t5, s2)) {
                    n2.addClass(Y_, t5);
                    this._previouslySelected.add(t5);
                    s2 = t5;
                    if (t5 == r2) {
                      n2.setSelection(o2.getRanges(), {fake: true, label: ev(r2)});
                    }
                  }
                }
              }
            }, {priority: "low"});
            t2.addObserver(Bv);
            this.listenTo(e2, "mousedown", (...t3) => this._onMousedown(...t3));
            this.listenTo(e2, "keydown", (...t3) => this._onKeydown(...t3), {priority: "high"});
            this.listenTo(e2, "delete", (t3, e3) => {
              if (this._handleDelete(e3.direction == "forward")) {
                e3.preventDefault();
                t3.stop();
              }
            }, {priority: "high"});
          }
          _onMousedown(t2, e2) {
            const i2 = this.editor;
            const n2 = i2.editing.view;
            const o2 = n2.document;
            let r2 = e2.target;
            if (Hv(r2)) {
              if (Al.isSafari && e2.domEvent.detail >= 3) {
                const t3 = i2.editing.mapper;
                const n3 = t3.toModelElement(r2);
                this.editor.model.change((t4) => {
                  e2.preventDefault();
                  t4.setSelection(n3, "in");
                });
              }
              return;
            }
            if (!Q_(r2)) {
              r2 = r2.findAncestor(Q_);
              if (!r2) {
                return;
              }
            }
            e2.preventDefault();
            if (!o2.isFocused) {
              n2.focus();
            }
            const s2 = i2.editing.mapper.toModelElement(r2);
            this._setSelectionOverElement(s2);
          }
          _onKeydown(t2, e2) {
            const i2 = e2.keyCode;
            const n2 = this.editor.locale.contentLanguageDirection === "ltr";
            const o2 = i2 == Nl.arrowdown || i2 == Nl[n2 ? "arrowright" : "arrowleft"];
            let r2 = false;
            if (Dv(i2)) {
              r2 = this._handleArrowKeys(o2);
            } else if (jv(e2)) {
              r2 = this._selectAllNestedEditableContent() || this._selectAllContent();
            } else if (i2 === Nl.enter) {
              r2 = this._handleEnterKey(e2.shiftKey);
            }
            if (r2) {
              e2.preventDefault();
              t2.stop();
            }
          }
          _handleDelete(t2) {
            if (this.editor.isReadOnly) {
              return;
            }
            const e2 = this.editor.model.document;
            const i2 = e2.selection;
            if (!i2.isCollapsed) {
              return;
            }
            const n2 = this._getObjectElementNextToSelection(t2);
            if (n2) {
              this.editor.model.change((t3) => {
                let e3 = i2.anchor.parent;
                while (e3.isEmpty) {
                  const i3 = e3;
                  e3 = i3.parent;
                  t3.remove(i3);
                }
                this._setSelectionOverElement(n2);
              });
              return true;
            }
          }
          _handleArrowKeys(t2) {
            const e2 = this.editor.model;
            const i2 = e2.schema;
            const n2 = e2.document;
            const o2 = n2.selection;
            const r2 = o2.getSelectedElement();
            if (r2 && i2.isObject(r2)) {
              const n3 = t2 ? o2.getLastPosition() : o2.getFirstPosition();
              const r3 = i2.getNearestSelectionRange(n3, t2 ? "forward" : "backward");
              if (r3) {
                e2.change((t3) => {
                  t3.setSelection(r3);
                });
              }
              return true;
            }
            if (!o2.isCollapsed) {
              return;
            }
            const s2 = this._getObjectElementNextToSelection(t2);
            if (!!s2 && i2.isObject(s2)) {
              this._setSelectionOverElement(s2);
              return true;
            }
          }
          _handleEnterKey(t2) {
            const e2 = this.editor.model;
            const i2 = e2.document.selection;
            const n2 = i2.getSelectedElement();
            if (qv(n2, e2.schema)) {
              e2.change((i3) => {
                let o2 = i3.createPositionAt(n2, t2 ? "before" : "after");
                const r2 = i3.createElement("paragraph");
                if (e2.schema.isBlock(n2.parent)) {
                  const t3 = e2.schema.findAllowedParent(o2, r2);
                  o2 = i3.split(o2, t3).position;
                }
                i3.insert(r2, o2);
                i3.setSelection(r2, "in");
              });
              return true;
            }
          }
          _selectAllNestedEditableContent() {
            const t2 = this.editor.model;
            const e2 = t2.document.selection;
            const i2 = t2.schema.getLimitElement(e2);
            if (e2.getFirstRange().root == i2) {
              return false;
            }
            t2.change((t3) => {
              t3.setSelection(t3.createRangeIn(i2));
            });
            return true;
          }
          _selectAllContent() {
            const t2 = this.editor.model;
            const e2 = this.editor.editing;
            const i2 = e2.view;
            const n2 = i2.document;
            const o2 = n2.selection;
            const r2 = o2.getSelectedElement();
            if (r2 && Q_(r2)) {
              const i3 = e2.mapper.toModelElement(r2.parent);
              t2.change((t3) => {
                t3.setSelection(t3.createRangeIn(i3));
              });
              return true;
            }
            return false;
          }
          _setSelectionOverElement(t2) {
            this.editor.model.change((e2) => {
              e2.setSelection(e2.createRangeOn(t2));
            });
          }
          _getObjectElementNextToSelection(t2) {
            const e2 = this.editor.model;
            const i2 = e2.schema;
            const n2 = e2.document.selection;
            const o2 = e2.createSelection(n2);
            e2.modifySelection(o2, {direction: t2 ? "forward" : "backward"});
            const r2 = t2 ? o2.focus.nodeBefore : o2.focus.nodeAfter;
            if (!!r2 && i2.isObject(r2)) {
              return r2;
            }
            return null;
          }
          _clearPreviouslySelectedWidgets(t2) {
            for (const e2 of this._previouslySelected) {
              t2.removeClass(Y_, e2);
            }
            this._previouslySelected.clear();
          }
        }
        function Dv(t2) {
          return t2 == Nl.arrowright || t2 == Nl.arrowleft || t2 == Nl.arrowup || t2 == Nl.arrowdown;
        }
        function jv(t2) {
          return Ml(t2) == Lv;
        }
        function Hv(t2) {
          while (t2) {
            if (t2.is("editableElement") && !t2.is("rootElement")) {
              return true;
            }
            if (Q_(t2)) {
              return false;
            }
            t2 = t2.parent;
          }
          return false;
        }
        function Wv(t2, e2) {
          if (!e2) {
            return false;
          }
          return Array.from(t2.getAncestors()).includes(e2);
        }
        function qv(t2, e2) {
          return t2 && e2.isObject(t2) && !e2.isInline(t2);
        }
        class Uv extends jw {
          refresh() {
            const t2 = this.editor.model.document.selection.getSelectedElement();
            this.isEnabled = yv(t2);
            if (yv(t2) && t2.hasAttribute("alt")) {
              this.value = t2.getAttribute("alt");
            } else {
              this.value = false;
            }
          }
          execute(t2) {
            const e2 = this.editor.model;
            const i2 = e2.document.selection.getSelectedElement();
            e2.change((e3) => {
              e3.setAttribute("alt", t2.newValue, i2);
            });
          }
        }
        class $v extends mp {
          static get pluginName() {
            return "ImageTextAlternativeEditing";
          }
          init() {
            this.editor.commands.add("imageTextAlternative", new Uv(this.editor));
          }
        }
        var Gv = i(60);
        class Kv extends Gp {
          constructor(t2, e2) {
            super(t2);
            const i2 = `ck-input-${is()}`;
            const n2 = `ck-status-${is()}`;
            this.set("label");
            this.set("value");
            this.set("isReadOnly", false);
            this.set("errorText", null);
            this.set("infoText", null);
            this.labelView = this._createLabelView(i2);
            this.inputView = this._createInputView(e2, i2, n2);
            this.statusView = this._createStatusView(n2);
            this.bind("_statusText").to(this, "errorText", this, "infoText", (t3, e3) => t3 || e3);
            const o2 = this.bindTemplate;
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck", "ck-labeled-input", o2.if("isReadOnly", "ck-disabled")]},
              children: [this.labelView, this.inputView, this.statusView]
            });
          }
          _createLabelView(t2) {
            const e2 = new Mk(this.locale);
            e2.for = t2;
            e2.bind("text").to(this, "label");
            return e2;
          }
          _createInputView(t2, e2, i2) {
            const n2 = new t2(this.locale, i2);
            n2.id = e2;
            n2.ariaDescribedById = i2;
            n2.bind("value").to(this);
            n2.bind("isReadOnly").to(this);
            n2.bind("hasError").to(this, "errorText", (t3) => !!t3);
            n2.on("input", () => {
              this.errorText = null;
            });
            return n2;
          }
          _createStatusView(t2) {
            const e2 = new Gp(this.locale);
            const i2 = this.bindTemplate;
            e2.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-labeled-input__status", i2.if("errorText", "ck-labeled-input__status_error"), i2.if("_statusText", "ck-hidden", (t3) => !t3)],
                id: t2,
                role: i2.if("errorText", "alert")
              },
              children: [{text: i2.to("_statusText")}]
            });
            return e2;
          }
          select() {
            this.inputView.select();
          }
          focus() {
            this.inputView.focus();
          }
        }
        var Jv = i(62);
        class Yv extends Gp {
          constructor(t2) {
            super(t2);
            this.set("value");
            this.set("id");
            this.set("placeholder");
            this.set("isReadOnly", false);
            this.set("hasError", false);
            this.set("ariaDescribedById");
            const e2 = this.bindTemplate;
            this.setTemplate({
              tag: "input",
              attributes: {
                type: "text",
                class: ["ck", "ck-input", "ck-input-text", e2.if("hasError", "ck-error")],
                id: e2.to("id"),
                placeholder: e2.to("placeholder"),
                readonly: e2.to("isReadOnly"),
                "aria-invalid": e2.if("hasError", true),
                "aria-describedby": e2.to("ariaDescribedById")
              },
              on: {input: e2.to("input")}
            });
          }
          render() {
            super.render();
            const t2 = (t3) => {
              this.element.value = !t3 && t3 !== 0 ? "" : t3;
            };
            t2(this.value);
            this.on("change:value", (e2, i2, n2) => {
              t2(n2);
            });
          }
          select() {
            this.element.select();
          }
          focus() {
            this.element.focus();
          }
        }
        function Qv({view: t2}) {
          t2.listenTo(t2.element, "submit", (e2, i2) => {
            i2.preventDefault();
            t2.fire("submit");
          }, {useCapture: true});
        }
        var Xv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
        var Zv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.591 10.177l4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
        var ty = i(64);
        class ey extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = this.locale.t;
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this.labeledInput = this._createLabeledInputView();
            this.saveButtonView = this._createButton(e2("lo"), Xv, "ck-button-save");
            this.saveButtonView.type = "submit";
            this.cancelButtonView = this._createButton(e2("lp"), Zv, "ck-button-cancel", "cancel");
            this._focusables = new bp();
            this._focusCycler = new yb({
              focusables: this._focusables,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: "shift + tab", focusNext: "tab"}
            });
            this.setTemplate({
              tag: "form",
              attributes: {class: ["ck", "ck-text-alternative-form"], tabindex: "-1"},
              children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
            });
          }
          render() {
            super.render();
            this.keystrokes.listenTo(this.element);
            Qv({view: this});
            [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t2) => {
              this._focusables.add(t2);
              this.focusTracker.add(t2.element);
            });
          }
          _createButton(t2, e2, i2, n2) {
            const o2 = new hb(this.locale);
            o2.set({label: t2, icon: e2, tooltip: true});
            o2.extendTemplate({attributes: {class: i2}});
            if (n2) {
              o2.delegate("execute").to(this, n2);
            }
            return o2;
          }
          _createLabeledInputView() {
            const t2 = this.locale.t;
            const e2 = new Kv(this.locale, Yv);
            e2.label = t2("lt");
            e2.inputView.placeholder = t2("lt");
            return e2;
          }
        }
        var iy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22L2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
        function ny(t2) {
          const e2 = t2.plugins.get("ContextualBalloon");
          if (vv(t2.editing.view.document.selection)) {
            const i2 = oy(t2);
            e2.updatePosition(i2);
          }
        }
        function oy(t2) {
          const e2 = t2.editing.view;
          const i2 = nb.defaultPositions;
          return {
            target: e2.domConverter.viewToDom(e2.document.selection.getSelectedElement()),
            positions: [i2.northArrowSouth, i2.northArrowSouthWest, i2.northArrowSouthEast, i2.southArrowNorth, i2.southArrowNorthWest, i2.southArrowNorthEast]
          };
        }
        class ry extends mp {
          static get requires() {
            return [kb];
          }
          static get pluginName() {
            return "ImageTextAlternativeUI";
          }
          init() {
            this._createButton();
            this._createForm();
          }
          destroy() {
            super.destroy();
            this._form.destroy();
          }
          _createButton() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add("imageTextAlternative", (i2) => {
              const n2 = t2.commands.get("imageTextAlternative");
              const o2 = new hb(i2);
              o2.set({label: e2("lh"), icon: iy, tooltip: true});
              o2.bind("isEnabled").to(n2, "isEnabled");
              this.listenTo(o2, "execute", () => {
                this._showForm();
              });
              return o2;
            });
          }
          _createForm() {
            const t2 = this.editor;
            const e2 = t2.editing.view;
            const i2 = e2.document;
            this._balloon = this.editor.plugins.get("ContextualBalloon");
            this._form = new ey(t2.locale);
            this._form.render();
            this.listenTo(this._form, "submit", () => {
              t2.execute("imageTextAlternative", {newValue: this._form.labeledInput.inputView.element.value});
              this._hideForm(true);
            });
            this.listenTo(this._form, "cancel", () => {
              this._hideForm(true);
            });
            this._form.keystrokes.set("Esc", (t3, e3) => {
              this._hideForm(true);
              e3();
            });
            this.listenTo(t2.ui, "update", () => {
              if (!vv(i2.selection)) {
                this._hideForm(true);
              } else if (this._isVisible) {
                ny(t2);
              }
            });
            Db({
              emitter: this._form,
              activator: () => this._isVisible,
              contextElements: [this._balloon.view.element],
              callback: () => this._hideForm()
            });
          }
          _showForm() {
            if (this._isVisible) {
              return;
            }
            const t2 = this.editor;
            const e2 = t2.commands.get("imageTextAlternative");
            const i2 = this._form.labeledInput;
            if (!this._isInBalloon) {
              this._balloon.add({view: this._form, position: oy(t2)});
            }
            i2.value = i2.inputView.element.value = e2.value || "";
            this._form.labeledInput.select();
          }
          _hideForm(t2) {
            if (!this._isInBalloon) {
              return;
            }
            if (this._form.focusTracker.isFocused) {
              this._form.saveButtonView.focus();
            }
            this._balloon.remove(this._form);
            if (t2) {
              this.editor.editing.view.focus();
            }
          }
          get _isVisible() {
            return this._balloon.visibleView === this._form;
          }
          get _isInBalloon() {
            return this._balloon.hasView(this._form);
          }
        }
        class sy extends mp {
          static get requires() {
            return [$v, ry];
          }
          static get pluginName() {
            return "ImageTextAlternative";
          }
        }
        var ay = i(66);
        class cy extends mp {
          static get requires() {
            return [Nv, Fv, sy];
          }
          static get pluginName() {
            return "Image";
          }
        }
        class ly extends mp {
          static get requires() {
            return [kb];
          }
          static get pluginName() {
            return "WidgetToolbarRepository";
          }
          init() {
            const t2 = this.editor;
            if (t2.plugins.has("BalloonToolbar")) {
              const e2 = t2.plugins.get("BalloonToolbar");
              this.listenTo(e2, "show", (e3) => {
                if (hy(t2.editing.view.document.selection)) {
                  e3.stop();
                }
              }, {priority: "high"});
            }
            this._toolbarDefinitions = new Map();
            this._balloon = this.editor.plugins.get("ContextualBalloon");
            this.on("change:isEnabled", () => {
              this._updateToolbarsVisibility();
            });
            this.listenTo(t2.ui, "update", () => {
              this._updateToolbarsVisibility();
            });
            this.listenTo(t2.ui.focusTracker, "change:isFocused", () => {
              this._updateToolbarsVisibility();
            }, {priority: "low"});
          }
          destroy() {
            super.destroy();
            for (const t2 of this._toolbarDefinitions.values()) {
              t2.view.destroy();
            }
          }
          register(t2, {ariaLabel: e2, items: i2, getRelatedElement: n2, balloonClassName: o2 = "ck-toolbar-container"}) {
            const r2 = this.editor;
            const s2 = r2.t;
            const a2 = new Xb(r2.locale);
            a2.ariaLabel = e2 || s2("kf");
            if (this._toolbarDefinitions.has(t2)) {
              throw new ss["b"]("widget-toolbar-duplicated: Toolbar with the given id was already added.", this, {toolbarId: t2});
            }
            a2.fillFromConfig(i2, r2.ui.componentFactory);
            this._toolbarDefinitions.set(t2, {view: a2, getRelatedElement: n2, balloonClassName: o2});
          }
          _updateToolbarsVisibility() {
            let t2 = 0;
            let e2 = null;
            let i2 = null;
            for (const n2 of this._toolbarDefinitions.values()) {
              const o2 = n2.getRelatedElement(this.editor.editing.view.document.selection);
              if (!this.isEnabled || !o2) {
                if (this._isToolbarInBalloon(n2)) {
                  this._hideToolbar(n2);
                }
              } else if (!this.editor.ui.focusTracker.isFocused) {
                if (this._isToolbarVisible(n2)) {
                  this._hideToolbar(n2);
                }
              } else {
                const r2 = o2.getAncestors().length;
                if (r2 > t2) {
                  t2 = r2;
                  e2 = o2;
                  i2 = n2;
                }
              }
            }
            if (i2) {
              this._showToolbar(i2, e2);
            }
          }
          _hideToolbar(t2) {
            this._balloon.remove(t2.view);
            this.stopListening(this._balloon, "change:visibleView");
          }
          _showToolbar(t2, e2) {
            if (this._isToolbarVisible(t2)) {
              dy(this.editor, e2);
            } else if (!this._isToolbarInBalloon(t2)) {
              this._balloon.add({
                view: t2.view,
                position: uy(this.editor, e2),
                balloonClassName: t2.balloonClassName
              });
              this.listenTo(this._balloon, "change:visibleView", () => {
                for (const t3 of this._toolbarDefinitions.values()) {
                  if (this._isToolbarVisible(t3)) {
                    const e3 = t3.getRelatedElement(this.editor.editing.view.document.selection);
                    dy(this.editor, e3);
                  }
                }
              });
            }
          }
          _isToolbarVisible(t2) {
            return this._balloon.visibleView === t2.view;
          }
          _isToolbarInBalloon(t2) {
            return this._balloon.hasView(t2.view);
          }
        }
        function dy(t2, e2) {
          const i2 = t2.plugins.get("ContextualBalloon");
          const n2 = uy(t2, e2);
          i2.updatePosition(n2);
        }
        function uy(t2, e2) {
          const i2 = t2.editing.view;
          const n2 = nb.defaultPositions;
          return {
            target: i2.domConverter.mapViewToDom(e2),
            positions: [n2.northArrowSouth, n2.northArrowSouthWest, n2.northArrowSouthEast, n2.southArrowNorth, n2.southArrowNorthWest, n2.southArrowNorthEast]
          };
        }
        function hy(t2) {
          const e2 = t2.getSelectedElement();
          return !!(e2 && Q_(e2));
        }
        class fy extends mp {
          static get requires() {
            return [ly];
          }
          static get pluginName() {
            return "ImageToolbar";
          }
          afterInit() {
            const t2 = this.editor;
            const e2 = t2.t;
            const i2 = t2.plugins.get(ly);
            i2.register("image", {
              ariaLabel: e2("a"),
              items: t2.config.get("image.toolbar") || [],
              getRelatedElement: vv
            });
          }
        }
        class gy extends jw {
          constructor(t2, e2) {
            super(t2);
            this.defaultStyle = false;
            this.styles = e2.reduce((t3, e3) => {
              t3[e3.name] = e3;
              if (e3.isDefault) {
                this.defaultStyle = e3.name;
              }
              return t3;
            }, {});
          }
          refresh() {
            const t2 = this.editor.model.document.selection.getSelectedElement();
            this.isEnabled = yv(t2);
            if (!t2) {
              this.value = false;
            } else if (t2.hasAttribute("imageStyle")) {
              const e2 = t2.getAttribute("imageStyle");
              this.value = this.styles[e2] ? e2 : false;
            } else {
              this.value = this.defaultStyle;
            }
          }
          execute(t2) {
            const e2 = t2.value;
            const i2 = this.editor.model;
            const n2 = i2.document.selection.getSelectedElement();
            i2.change((t3) => {
              if (this.styles[e2].isDefault) {
                t3.removeAttribute("imageStyle", n2);
              } else {
                t3.setAttribute("imageStyle", e2, n2);
              }
            });
          }
        }
        function my(t2) {
          return (e2, i2, n2) => {
            if (!n2.consumable.consume(i2.item, e2.name)) {
              return;
            }
            const o2 = by(i2.attributeNewValue, t2);
            const r2 = by(i2.attributeOldValue, t2);
            const s2 = n2.mapper.toViewElement(i2.item);
            const a2 = n2.writer;
            if (r2) {
              a2.removeClass(r2.className, s2);
            }
            if (o2) {
              a2.addClass(o2.className, s2);
            }
          };
        }
        function py(t2) {
          const e2 = t2.filter((t3) => !t3.isDefault);
          return (t3, i2, n2) => {
            if (!i2.modelRange) {
              return;
            }
            const o2 = i2.viewItem;
            const r2 = Ww(i2.modelRange.getItems());
            if (!n2.schema.checkAttribute(r2, "imageStyle")) {
              return;
            }
            for (const t4 of e2) {
              if (n2.consumable.consume(o2, {classes: t4.className})) {
                n2.writer.setAttribute("imageStyle", t4.name, r2);
              }
            }
          };
        }
        function by(t2, e2) {
          for (const i2 of e2) {
            if (i2.name === t2) {
              return i2;
            }
          }
        }
        var wy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm2.5 3V12h11V7.5h-11zM4.061 6H15.94c.586 0 1.061.407 1.061.91v5.68c0 .503-.475.91-1.061.91H4.06c-.585 0-1.06-.407-1.06-.91V6.91C3 6.406 3.475 6 4.061 6zM2 16.5V15h16v1.5z"/></svg>';
        var ky = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path d="M18 4.5V3H2v1.5h16zm0 3V6h-5.674v1.5H18zm0 3V9h-5.674v1.5H18zm0 3V12h-5.674v1.5H18zm-8.5-6V12h-6V7.5h6zm.818-1.5H2.682C2.305 6 2 6.407 2 6.91v5.68c0 .503.305.91.682.91h7.636c.377 0 .682-.407.682-.91V6.91c0-.503-.305-.91-.682-.91zM18 16.5V15H2v1.5h16z"/></svg>';
        var _y = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm4.5 3V12h7V7.5h-7zM5.758 6h8.484c.419 0 .758.407.758.91v5.681c0 .502-.34.909-.758.909H5.758c-.419 0-.758-.407-.758-.91V6.91c0-.503.34-.91.758-.91zM2 16.5V15h16v1.5z"/></svg>';
        var vy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm0 3V6h5.674v1.5zm0 3V9h5.674v1.5zm0 3V12h5.674v1.5zm8.5-6V12h6V7.5h-6zM9.682 6h7.636c.377 0 .682.407.682.91v5.68c0 .503-.305.91-.682.91H9.682c-.377 0-.682-.407-.682-.91V6.91c0-.503.305-.91.682-.91zM2 16.5V15h16v1.5z"/></svg>';
        const yy = {
          full: {name: "full", title: "Full size image", icon: wy, isDefault: true},
          side: {name: "side", title: "Side image", icon: vy, className: "image-style-side"},
          alignLeft: {name: "alignLeft", title: "Left aligned image", icon: ky, className: "image-style-align-left"},
          alignCenter: {
            name: "alignCenter",
            title: "Centered image",
            icon: _y,
            className: "image-style-align-center"
          },
          alignRight: {
            name: "alignRight",
            title: "Right aligned image",
            icon: vy,
            className: "image-style-align-right"
          }
        };
        const xy = {full: wy, left: ky, right: vy, center: _y};
        function Cy(t2 = []) {
          return t2.map(Ay);
        }
        function Ay(t2) {
          if (typeof t2 == "string") {
            const e2 = t2;
            if (yy[e2]) {
              t2 = Object.assign({}, yy[e2]);
            } else {
              console.warn(Object(ss["a"])("image-style-not-found: There is no such image style of given name."), {name: e2});
              t2 = {name: e2};
            }
          } else if (yy[t2.name]) {
            const e2 = yy[t2.name];
            const i2 = Object.assign({}, t2);
            for (const n2 in e2) {
              if (!t2.hasOwnProperty(n2)) {
                i2[n2] = e2[n2];
              }
            }
            t2 = i2;
          }
          if (typeof t2.icon == "string" && xy[t2.icon]) {
            t2.icon = xy[t2.icon];
          }
          return t2;
        }
        class Ty extends mp {
          static get pluginName() {
            return "ImageStyleEditing";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.schema;
            const i2 = t2.data;
            const n2 = t2.editing;
            t2.config.define("image.styles", ["full", "side"]);
            const o2 = Cy(t2.config.get("image.styles"));
            e2.extend("image", {allowAttributes: "imageStyle"});
            const r2 = my(o2);
            n2.downcastDispatcher.on("attribute:imageStyle:image", r2);
            i2.downcastDispatcher.on("attribute:imageStyle:image", r2);
            i2.upcastDispatcher.on("element:figure", py(o2), {priority: "low"});
            t2.commands.add("imageStyle", new gy(t2, o2));
          }
        }
        var Py = i(68);
        class Sy extends mp {
          static get pluginName() {
            return "ImageStyleUI";
          }
          get localizedDefaultStylesTitles() {
            const t2 = this.editor.t;
            return {
              "Full size image": t2("jy"),
              "Side image": t2("jz"),
              "Left aligned image": t2("ka"),
              "Centered image": t2("kb"),
              "Right aligned image": t2("kc")
            };
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.config.get("image.styles");
            const i2 = Ey(Cy(e2), this.localizedDefaultStylesTitles);
            for (const t3 of i2) {
              this._createButton(t3);
            }
          }
          _createButton(t2) {
            const e2 = this.editor;
            const i2 = `imageStyle:${t2.name}`;
            e2.ui.componentFactory.add(i2, (i3) => {
              const n2 = e2.commands.get("imageStyle");
              const o2 = new hb(i3);
              o2.set({label: t2.title, icon: t2.icon, tooltip: true, isToggleable: true});
              o2.bind("isEnabled").to(n2, "isEnabled");
              o2.bind("isOn").to(n2, "value", (e3) => e3 === t2.name);
              this.listenTo(o2, "execute", () => {
                e2.execute("imageStyle", {value: t2.name});
                e2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        function Ey(t2, e2) {
          for (const i2 of t2) {
            if (e2[i2.title]) {
              i2.title = e2[i2.title];
            }
          }
          return t2;
        }
        class Ry extends mp {
          static get requires() {
            return [Ty, Sy];
          }
          static get pluginName() {
            return "ImageStyle";
          }
        }
        class Oy {
          constructor(t2) {
            this.set("activeHandlePosition", null);
            this.set("proposedWidthPercents", null);
            this.set("proposedWidth", null);
            this.set("proposedHeight", null);
            this.set("proposedHandleHostWidth", null);
            this.set("proposedHandleHostHeight", null);
            this._options = t2;
            this._referenceCoordinates = null;
          }
          begin(t2, e2, i2) {
            const n2 = new vh(e2);
            this.activeHandlePosition = My(t2);
            this._referenceCoordinates = Vy(e2, By(this.activeHandlePosition));
            this.originalWidth = n2.width;
            this.originalHeight = n2.height;
            this.aspectRatio = n2.width / n2.height;
            const o2 = i2.style.width;
            if (o2 && o2.match(/^\d+\.?\d*%$/)) {
              this.originalWidthPercents = parseFloat(o2);
            } else {
              this.originalWidthPercents = Iy(i2, n2);
            }
          }
          update(t2) {
            this.proposedWidth = t2.width;
            this.proposedHeight = t2.height;
            this.proposedWidthPercents = t2.widthPercents;
            this.proposedHandleHostWidth = t2.handleHostWidth;
            this.proposedHandleHostHeight = t2.handleHostHeight;
          }
        }
        vs(Oy, Jc);
        function Iy(t2, e2) {
          const i2 = t2.parentElement;
          const n2 = parseFloat(i2.ownerDocument.defaultView.getComputedStyle(i2).width);
          return e2.width / n2 * 100;
        }
        function Vy(t2, e2) {
          const i2 = new vh(t2);
          const n2 = e2.split("-");
          const o2 = {x: n2[1] == "right" ? i2.right : i2.left, y: n2[0] == "bottom" ? i2.bottom : i2.top};
          o2.x += t2.ownerDocument.defaultView.scrollX;
          o2.y += t2.ownerDocument.defaultView.scrollY;
          return o2;
        }
        function Ny(t2) {
          return `ck-widget__resizer__handle-${t2}`;
        }
        function My(t2) {
          const e2 = ["top-left", "top-right", "bottom-right", "bottom-left"];
          for (const i2 of e2) {
            if (t2.classList.contains(Ny(i2))) {
              return i2;
            }
          }
        }
        function By(t2) {
          const e2 = t2.split("-");
          const i2 = {top: "bottom", bottom: "top", left: "right", right: "left"};
          return `${i2[e2[0]]}-${i2[e2[1]]}`;
        }
        class zy {
          constructor(t2) {
            this._options = t2;
            this._domResizerWrapper = null;
            this._viewResizerWrapper = null;
            this.set("isEnabled", true);
            this.decorate("begin");
            this.decorate("cancel");
            this.decorate("commit");
            this.decorate("updateSize");
            this.on("commit", (t3) => {
              if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
                this._cleanup();
                t3.stop();
              }
            }, {priority: "high"});
          }
          attach() {
            const t2 = this;
            const e2 = this._options.viewElement;
            const i2 = this._options.editor.editing.view;
            i2.change((i3) => {
              const n2 = i3.createUIElement("div", {class: "ck ck-reset_all ck-widget__resizer"}, function(e3) {
                const i4 = this.toDomElement(e3);
                t2._appendHandles(i4);
                t2._appendSizeUI(i4);
                t2._domResizerWrapper = i4;
                t2.on("change:isEnabled", (t3, e4, n3) => {
                  i4.style.display = n3 ? "" : "none";
                });
                i4.style.display = t2.isEnabled ? "" : "none";
                return i4;
              });
              i3.insert(i3.createPositionAt(e2, "end"), n2);
              i3.addClass("ck-widget_with-resizer", e2);
              this._viewResizerWrapper = n2;
            });
          }
          begin(t2) {
            this.state = new Oy(this._options);
            this._sizeUI.bindToState(this._options, this.state);
            this.state.begin(t2, this._getHandleHost(), this._getResizeHost());
          }
          updateSize(t2) {
            const e2 = this._proposeNewSize(t2);
            const i2 = this._options.editor.editing.view;
            i2.change((t3) => {
              const i3 = this._options.unit || "%";
              const n3 = (i3 === "%" ? e2.widthPercents : e2.width) + i3;
              t3.setStyle("width", n3, this._options.viewElement);
            });
            const n2 = this._getHandleHost();
            const o2 = new vh(n2);
            e2.handleHostWidth = Math.round(o2.width);
            e2.handleHostHeight = Math.round(o2.height);
            const r2 = new vh(n2);
            e2.width = Math.round(r2.width);
            e2.height = Math.round(r2.height);
            this.redraw(o2);
            this.state.update(e2);
          }
          commit() {
            const t2 = this._options.unit || "%";
            const e2 = (t2 === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + t2;
            this._options.onCommit(e2);
            this._cleanup();
          }
          cancel() {
            this._cleanup();
          }
          destroy() {
            this.cancel();
          }
          redraw(t2) {
            const e2 = this._domResizerWrapper;
            if (i2(e2)) {
              this._options.editor.editing.view.change((i3) => {
                const n2 = e2.parentElement;
                const o2 = this._getHandleHost();
                const r2 = t2 || new vh(o2);
                i3.setStyle("width", r2.width + "px", this._viewResizerWrapper);
                i3.setStyle("height", r2.height + "px", this._viewResizerWrapper);
                const s2 = {left: o2.offsetLeft, top: o2.offsetTop, height: o2.offsetHeight, width: o2.offsetWidth};
                if (!n2.isSameNode(o2)) {
                  i3.setStyle("left", s2.left + "px", this._viewResizerWrapper);
                  i3.setStyle("top", s2.top + "px", this._viewResizerWrapper);
                  i3.setStyle("height", s2.height + "px", this._viewResizerWrapper);
                  i3.setStyle("width", s2.width + "px", this._viewResizerWrapper);
                }
              });
            }
            function i2(t3) {
              return t3 && t3.ownerDocument && t3.ownerDocument.contains(t3);
            }
          }
          containsHandle(t2) {
            return this._domResizerWrapper.contains(t2);
          }
          static isResizeHandle(t2) {
            return t2.classList.contains("ck-widget__resizer__handle");
          }
          _cleanup() {
            this._sizeUI.dismiss();
            this._sizeUI.isVisible = false;
          }
          _proposeNewSize(t2) {
            const e2 = this.state;
            const i2 = Dy(t2);
            const n2 = this._options.isCentered ? this._options.isCentered(this) : true;
            const o2 = {
              x: e2._referenceCoordinates.x - (i2.x + e2.originalWidth),
              y: i2.y - e2.originalHeight - e2._referenceCoordinates.y
            };
            if (n2 && e2.activeHandlePosition.endsWith("-right")) {
              o2.x = i2.x - (e2._referenceCoordinates.x + e2.originalWidth);
            }
            if (n2) {
              o2.x *= 2;
            }
            const r2 = {width: Math.abs(e2.originalWidth + o2.x), height: Math.abs(e2.originalHeight + o2.y)};
            r2.dominant = r2.width / e2.aspectRatio > r2.height ? "width" : "height";
            r2.max = r2[r2.dominant];
            const s2 = {width: r2.width, height: r2.height};
            if (r2.dominant == "width") {
              s2.height = s2.width / e2.aspectRatio;
            } else {
              s2.width = s2.height * e2.aspectRatio;
            }
            return {
              width: Math.round(s2.width),
              height: Math.round(s2.height),
              widthPercents: Math.min(Math.round(e2.originalWidthPercents / e2.originalWidth * s2.width * 100) / 100, 100)
            };
          }
          _getResizeHost() {
            const t2 = this._domResizerWrapper.parentElement;
            return this._options.getResizeHost(t2);
          }
          _getHandleHost() {
            const t2 = this._domResizerWrapper.parentElement;
            return this._options.getHandleHost(t2);
          }
          _appendHandles(t2) {
            const e2 = ["top-left", "top-right", "bottom-right", "bottom-left"];
            for (const i2 of e2) {
              t2.appendChild(new _p({
                tag: "div",
                attributes: {class: `ck-widget__resizer__handle ${Fy(i2)}`}
              }).render());
            }
          }
          _appendSizeUI(t2) {
            const e2 = new Ly();
            e2.render();
            this._sizeUI = e2;
            t2.appendChild(e2.element);
          }
        }
        vs(zy, Jc);
        class Ly extends Gp {
          constructor() {
            super();
            const t2 = this.bindTemplate;
            this.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-size-view", t2.to("activeHandlePosition", (t3) => t3 ? `ck-orientation-${t3}` : "")],
                style: {display: t2.if("isVisible", "none", (t3) => !t3)}
              },
              children: [{text: t2.to("label")}]
            });
          }
          bindToState(t2, e2) {
            this.bind("isVisible").to(e2, "proposedWidth", e2, "proposedHeight", (t3, e3) => t3 !== null && e3 !== null);
            this.bind("label").to(e2, "proposedHandleHostWidth", e2, "proposedHandleHostHeight", e2, "proposedWidthPercents", (e3, i2, n2) => {
              if (t2.unit === "px") {
                return `${e3}\xD7${i2}`;
              } else {
                return `${n2}%`;
              }
            });
            this.bind("activeHandlePosition").to(e2);
          }
          dismiss() {
            this.unbind();
            this.isVisible = false;
          }
        }
        function Fy(t2) {
          return `ck-widget__resizer__handle-${t2}`;
        }
        function Dy(t2) {
          return {x: t2.pageX, y: t2.pageY};
        }
        var jy = "Expected a function";
        function Hy(t2, e2, i2) {
          var n2 = true, o2 = true;
          if (typeof t2 != "function") {
            throw new TypeError(jy);
          }
          if (ct(i2)) {
            n2 = "leading" in i2 ? !!i2.leading : n2;
            o2 = "trailing" in i2 ? !!i2.trailing : o2;
          }
          return uh(t2, e2, {leading: n2, maxWait: e2, trailing: o2});
        }
        var Wy = Hy;
        var qy = i(70);
        class Uy extends mp {
          static get pluginName() {
            return "WidgetResize";
          }
          init() {
            this.set("_visibleResizer", null);
            this.set("_activeResizer", null);
            this._resizers = new Map();
            const t2 = Id.window.document;
            this.editor.model.schema.setAttributeProperties("width", {isFormatting: true});
            this._observer = Object.create(qd);
            this._observer.listenTo(t2, "mousedown", this._mouseDownListener.bind(this));
            this._observer.listenTo(t2, "mousemove", this._mouseMoveListener.bind(this));
            this._observer.listenTo(t2, "mouseup", this._mouseUpListener.bind(this));
            const e2 = () => {
              if (this._visibleResizer) {
                this._visibleResizer.redraw();
              }
            };
            const i2 = Wy(e2, 200);
            this.on("change:_visibleResizer", e2);
            this.editor.ui.on("update", i2);
            this._observer.listenTo(Id.window, "resize", i2);
            const n2 = this.editor.editing.view.document.selection;
            n2.on("change", () => {
              const t3 = n2.getSelectedElement();
              this._visibleResizer = this._getResizerByViewElement(t3) || null;
            });
          }
          destroy() {
            this._observer.stopListening();
            for (const t2 of this._resizers.values()) {
              t2.destroy();
            }
          }
          attachTo(t2) {
            const e2 = new zy(t2);
            const i2 = this.editor.plugins;
            e2.attach();
            if (i2.has("WidgetToolbarRepository")) {
              const t3 = i2.get("WidgetToolbarRepository");
              e2.on("begin", () => {
                t3.forceDisabled("resize");
              }, {priority: "lowest"});
              e2.on("cancel", () => {
                t3.clearForceDisabled("resize");
              }, {priority: "highest"});
              e2.on("commit", () => {
                t3.clearForceDisabled("resize");
              }, {priority: "highest"});
            }
            this._resizers.set(t2.viewElement, e2);
            return e2;
          }
          _getResizerByHandle(t2) {
            for (const e2 of this._resizers.values()) {
              if (e2.containsHandle(t2)) {
                return e2;
              }
            }
          }
          _getResizerByViewElement(t2) {
            return this._resizers.get(t2);
          }
          _mouseDownListener(t2, e2) {
            if (!zy.isResizeHandle(e2.target)) {
              return;
            }
            const i2 = e2.target;
            this._activeResizer = this._getResizerByHandle(i2);
            if (this._activeResizer) {
              this._activeResizer.begin(i2);
            }
          }
          _mouseMoveListener(t2, e2) {
            if (this._activeResizer) {
              this._activeResizer.updateSize(e2);
            }
          }
          _mouseUpListener() {
            if (this._activeResizer) {
              this._activeResizer.commit();
              this._activeResizer = null;
            }
          }
        }
        vs(Uy, Jc);
        class $y extends jw {
          refresh() {
            const t2 = this.editor.model.document.selection.getSelectedElement();
            this.isEnabled = yv(t2);
            if (!t2 || !t2.hasAttribute("width")) {
              this.value = null;
            } else {
              this.value = {width: t2.getAttribute("width"), height: null};
            }
          }
          execute(t2) {
            const e2 = this.editor.model;
            const i2 = e2.document.selection.getSelectedElement();
            e2.change((e3) => {
              e3.setAttribute("width", t2.width, i2);
            });
          }
        }
        var Gy = i(72);
        class Ky extends mp {
          static get requires() {
            return [Uy];
          }
          static get pluginName() {
            return "ImageResize";
          }
          init() {
            const t2 = this.editor;
            const e2 = new $y(t2);
            this._registerSchema();
            this._registerConverters();
            t2.commands.add("imageResize", e2);
            t2.editing.downcastDispatcher.on("insert:image", (i2, n2, o2) => {
              const r2 = o2.mapper.toViewElement(n2.item);
              const s2 = t2.plugins.get(Uy).attachTo({
                unit: t2.config.get("image.resizeUnit") || "%",
                modelElement: n2.item,
                viewElement: r2,
                editor: t2,
                getHandleHost(t3) {
                  return t3.querySelector("img");
                },
                getResizeHost(t3) {
                  return t3;
                },
                isCentered() {
                  const t3 = n2.item.getAttribute("imageStyle");
                  return !t3 || t3 == "full" || t3 == "alignCenter";
                },
                onCommit(e3) {
                  t2.execute("imageResize", {width: e3});
                }
              });
              s2.on("updateSize", () => {
                if (!r2.hasClass("image_resized")) {
                  t2.editing.view.change((t3) => {
                    t3.addClass("image_resized", r2);
                  });
                }
              });
              s2.bind("isEnabled").to(e2);
            }, {priority: "low"});
          }
          _registerSchema() {
            this.editor.model.schema.extend("image", {allowAttributes: "width"});
          }
          _registerConverters() {
            const t2 = this.editor;
            t2.conversion.for("downcast").add((t3) => t3.on("attribute:width:image", (t4, e2, i2) => {
              if (!i2.consumable.consume(e2.item, t4.name)) {
                return;
              }
              const n2 = i2.writer;
              const o2 = i2.mapper.toViewElement(e2.item);
              if (e2.attributeNewValue !== null) {
                n2.setStyle("width", e2.attributeNewValue, o2);
                n2.addClass("image_resized", o2);
              } else {
                n2.removeStyle("width", o2);
                n2.removeClass("image_resized", o2);
              }
            }));
            t2.conversion.for("upcast").attributeToAttribute({
              view: {name: "figure", styles: {width: /.+/}},
              model: {key: "width", value: (t3) => t3.getStyle("width")}
            });
          }
        }
        class Jy extends Gp {
          constructor(t2) {
            super(t2);
            this.buttonView = new hb(t2);
            this._fileInputView = new Yy(t2);
            this._fileInputView.bind("acceptedType").to(this);
            this._fileInputView.bind("allowMultipleFiles").to(this);
            this._fileInputView.delegate("done").to(this);
            this.setTemplate({
              tag: "span",
              attributes: {class: "ck-file-dialog-button"},
              children: [this.buttonView, this._fileInputView]
            });
            this.buttonView.on("execute", () => {
              this._fileInputView.open();
            });
          }
          focus() {
            this.buttonView.focus();
          }
        }
        class Yy extends Gp {
          constructor(t2) {
            super(t2);
            this.set("acceptedType");
            this.set("allowMultipleFiles", false);
            const e2 = this.bindTemplate;
            this.setTemplate({
              tag: "input",
              attributes: {
                class: ["ck-hidden"],
                type: "file",
                tabindex: "-1",
                accept: e2.to("acceptedType"),
                multiple: e2.to("allowMultipleFiles")
              },
              on: {
                change: e2.to(() => {
                  if (this.element && this.element.files && this.element.files.length) {
                    this.fire("done", this.element.files);
                  }
                  this.element.value = "";
                })
              }
            });
          }
          open() {
            this.element.click();
          }
        }
        var Qy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';
        function Xy(t2) {
          const e2 = t2.map((t3) => t3.replace("+", "\\+"));
          return new RegExp(`^image\\/(${e2.join("|")})$`);
        }
        function Zy(t2) {
          return new Promise((e2, i2) => {
            const n2 = t2.getAttribute("src");
            fetch(n2).then((t3) => t3.blob()).then((t3) => {
              const o2 = ex(t3, n2);
              const r2 = o2.replace("image/", "");
              const s2 = `image.${r2}`;
              const a2 = ix(t3, s2, o2);
              a2 ? e2(a2) : i2();
            }).catch(i2);
          });
        }
        function tx(t2) {
          if (!t2.is("element", "img") || !t2.getAttribute("src")) {
            return false;
          }
          return t2.getAttribute("src").match(/^data:image\/\w+;base64,/g) || t2.getAttribute("src").match(/^blob:/g);
        }
        function ex(t2, e2) {
          if (t2.type) {
            return t2.type;
          } else if (e2.match(/data:(image\/\w+);base64/)) {
            return e2.match(/data:(image\/\w+);base64/)[1].toLowerCase();
          } else {
            return "image/jpeg";
          }
        }
        function ix(t2, e2, i2) {
          try {
            return new File([t2], e2, {type: i2});
          } catch (t3) {
            return null;
          }
        }
        class nx extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add("imageUpload", (i2) => {
              const n2 = new Jy(i2);
              Object.defineProperty(n2.buttonView, "isEnabled", {
                get: () => true
              });
              let sourceElement = this.editor.sourceElement;
              const isVideo = sourceElement.classList.contains("videoBlock");
              const o2 = t2.commands.get("imageUpload");
              const r2 = t2.config.get("image.upload.types");
              const s2 = Xy(r2);
              if (isVideo)
                n2.set({acceptedType: `video/*`, allowMultipleFiles: true});
              else
                n2.set({acceptedType: r2.map((t3) => `image/${t3}`).join(","), allowMultipleFiles: true});
              n2.buttonView.set({label: isVideo ? "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0432\u0438\u0434\u0435\u043E" : e2("kd"), icon: Qy, tooltip: true});
              n2.buttonView.bind("isEnabled").to(o2);
              n2.on("done", (e3, i3) => {
                let n3;
                if (isVideo) {
                  let blob = Array.from(i3)[0];
                  let fileName = (Date.now() / 1e3 + Math.random()).toString(36).replace(".", "x") + "." + blob.name.split(".").pop();
                  const formData = new FormData();
                  formData.append("video", blob, fileName);
                  let wrapperElement = sourceElement.parentNode;
                  wrapperElement.setAttribute("url", fileName);
                  wrapperElement.classList.add("ckeditor-uploading");
                  fetch("/api/videos/" + fileName, {
                    method: "PUT",
                    body: formData
                  }).then(() => {
                    wrapperElement.classList.remove("ckeditor-uploading");
                    let state = a.ok ? "complete" : "error";
                    wrapperElement.classList.add(`ckeditor-uploading-${state}`);
                    setTimeout(() => {
                      wrapperElement.classList.remove(`ckeditor-uploading-complete`);
                      wrapperElement.classList.remove(`ckeditor-uploading-error`);
                    }, 1e3);
                    if (a.ok) {
                      let video = document.createElement("video");
                      let canvas = document.createElement("canvas");
                      video.preload = "metadata";
                      video.src = URL.createObjectURL(blob);
                      video.muted = true;
                      video.playsInline = true;
                      video.play().then(function() {
                        video.currentTime = Math.floor(video.duration / 2);
                        video.pause();
                        video.addEventListener("seeked", function() {
                          canvas.width = video.videoWidth;
                          canvas.height = video.videoHeight;
                          if (canvas.width > 500 || canvas.height > 500) {
                            canvas.width = canvas.width / 2 | 0;
                            canvas.height = canvas.height / 2 | 0;
                          }
                          let ctx = canvas.getContext("2d");
                          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                          video.src = "";
                          canvas.toBlob((blob2) => {
                            t2.execute("imageUpload", {file: [blob2]});
                          });
                        });
                      });
                    }
                  });
                } else {
                  n3 = Array.from(i3).filter((t3) => s2.test(t3.type));
                  n3.length && t2.execute("imageUpload", {file: n3});
                }
              });
              return n2;
            });
          }
        }
        var ox = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>';
        var rx = i(74);
        var sx = i(76);
        var ax = i(78);
        class cx extends mp {
          constructor(t2) {
            super(t2);
            this.placeholder = "data:image/svg+xml;utf8," + encodeURIComponent(ox);
          }
          init() {
            const t2 = this.editor;
            t2.editing.downcastDispatcher.on("attribute:uploadStatus:image", (...t3) => this.uploadStatusChange(...t3));
          }
          uploadStatusChange(t2, e2, i2) {
            const n2 = this.editor;
            const o2 = e2.item;
            const r2 = o2.getAttribute("uploadId");
            if (!i2.consumable.consume(e2.item, t2.name)) {
              return;
            }
            const s2 = n2.plugins.get(lk);
            const a2 = r2 ? e2.attributeNewValue : null;
            const c2 = this.placeholder;
            const l2 = n2.editing.mapper.toViewElement(o2);
            const d2 = i2.writer;
            if (a2 == "reading") {
              lx(l2, d2);
              ux(c2, l2, d2);
              return;
            }
            if (a2 == "uploading") {
              const t3 = s2.loaders.get(r2);
              lx(l2, d2);
              if (!t3) {
                ux(c2, l2, d2);
              } else {
                hx(l2, d2);
                fx(l2, d2, t3, n2.editing.view);
                _x(l2, d2, t3);
              }
              return;
            }
            if (a2 == "complete" && s2.loaders.get(r2) && !Al.isEdge) {
              mx(l2, d2, n2.editing.view);
            }
            gx(l2, d2);
            hx(l2, d2);
            dx(l2, d2);
          }
        }
        function lx(t2, e2) {
          if (!t2.hasClass("ck-appear")) {
            e2.addClass("ck-appear", t2);
          }
        }
        function dx(t2, e2) {
          e2.removeClass("ck-appear", t2);
        }
        function ux(t2, e2, i2) {
          if (!e2.hasClass("ck-image-upload-placeholder")) {
            i2.addClass("ck-image-upload-placeholder", e2);
          }
          const n2 = Av(e2);
          if (n2.getAttribute("src") !== t2) {
            i2.setAttribute("src", t2, n2);
          }
          if (!wx(e2, "placeholder")) {
            i2.insert(i2.createPositionAfter(n2), bx(i2));
          }
        }
        function hx(t2, e2) {
          if (t2.hasClass("ck-image-upload-placeholder")) {
            e2.removeClass("ck-image-upload-placeholder", t2);
          }
          kx(t2, e2, "placeholder");
        }
        function fx(t2, e2, i2, n2) {
          const o2 = px(e2);
          e2.insert(e2.createPositionAt(t2, "end"), o2);
          i2.on("change:uploadedPercent", (t3, e3, i3) => {
            n2.change((t4) => {
              t4.setStyle("width", i3 + "%", o2);
            });
          });
        }
        function gx(t2, e2) {
          kx(t2, e2, "progressBar");
        }
        function mx(t2, e2, i2) {
          const n2 = e2.createUIElement("div", {class: "ck-image-upload-complete-icon"});
          e2.insert(e2.createPositionAt(t2, "end"), n2);
          setTimeout(() => {
            i2.change((t3) => t3.remove(t3.createRangeOn(n2)));
          }, 3e3);
        }
        function px(t2) {
          const e2 = t2.createUIElement("div", {class: "ck-progress-bar"});
          t2.setCustomProperty("progressBar", true, e2);
          return e2;
        }
        function bx(t2) {
          const e2 = t2.createUIElement("div", {class: "ck-upload-placeholder-loader"});
          t2.setCustomProperty("placeholder", true, e2);
          return e2;
        }
        function wx(t2, e2) {
          for (const i2 of t2.getChildren()) {
            if (i2.getCustomProperty(e2)) {
              return i2;
            }
          }
        }
        function kx(t2, e2, i2) {
          const n2 = wx(t2, i2);
          if (n2) {
            e2.remove(e2.createRangeOn(n2));
          }
        }
        function _x(t2, e2, i2) {
          if (i2.data) {
            const n2 = Av(t2);
            e2.setAttribute("src", i2.data, n2);
          }
        }
        class vx extends sk {
          static get pluginName() {
            return "Notification";
          }
          init() {
            this.on("show:warning", (t2, e2) => {
              window.alert(e2.message);
            }, {priority: "lowest"});
          }
          showSuccess(t2, e2 = {}) {
            this._showNotification({message: t2, type: "success", namespace: e2.namespace, title: e2.title});
          }
          showInfo(t2, e2 = {}) {
            this._showNotification({message: t2, type: "info", namespace: e2.namespace, title: e2.title});
          }
          showWarning(t2, e2 = {}) {
            this._showNotification({message: t2, type: "warning", namespace: e2.namespace, title: e2.title});
          }
          _showNotification(t2) {
            const e2 = `show:${t2.type}` + (t2.namespace ? `:${t2.namespace}` : "");
            this.fire(e2, {message: t2.message, type: t2.type, title: t2.title || ""});
          }
        }
        class yx {
          constructor(t2) {
            this.files = xx(t2);
            this._native = t2;
          }
          get types() {
            return this._native.types;
          }
          getData(t2) {
            return this._native.getData(t2);
          }
          setData(t2, e2) {
            this._native.setData(t2, e2);
          }
        }
        function xx(t2) {
          const e2 = t2.files ? Array.from(t2.files) : [];
          const i2 = t2.items ? Array.from(t2.items) : [];
          if (e2.length) {
            return e2;
          }
          return i2.filter((t3) => t3.kind === "file").map((t3) => t3.getAsFile());
        }
        class Cx extends Ju {
          constructor(t2) {
            super(t2);
            const e2 = this.document;
            this.domEventType = ["paste", "copy", "cut", "drop", "dragover"];
            this.listenTo(e2, "paste", i2, {priority: "low"});
            this.listenTo(e2, "drop", i2, {priority: "low"});
            function i2(t3, i3) {
              i3.preventDefault();
              const n2 = i3.dropRange ? [i3.dropRange] : Array.from(e2.selection.getRanges());
              const o2 = new ts(e2, "clipboardInput");
              e2.fire(o2, {dataTransfer: i3.dataTransfer, targetRanges: n2});
              if (o2.stop.called) {
                i3.stopPropagation();
              }
            }
          }
          onDomEvent(t2) {
            const e2 = {dataTransfer: new yx(t2.clipboardData ? t2.clipboardData : t2.dataTransfer)};
            if (t2.type == "drop") {
              e2.dropRange = Ax(this.view, t2);
            }
            this.fire(t2.type, t2, e2);
          }
        }
        function Ax(t2, e2) {
          const i2 = e2.target.ownerDocument;
          const n2 = e2.clientX;
          const o2 = e2.clientY;
          let r2;
          if (i2.caretRangeFromPoint && i2.caretRangeFromPoint(n2, o2)) {
            r2 = i2.caretRangeFromPoint(n2, o2);
          } else if (e2.rangeParent) {
            r2 = i2.createRange();
            r2.setStart(e2.rangeParent, e2.rangeOffset);
            r2.collapse(true);
          }
          if (r2) {
            return t2.domConverter.domRangeToView(r2);
          } else {
            return t2.document.selection.getFirstRange();
          }
        }
        function Tx(t2) {
          t2 = t2.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "</p><p>").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
          if (t2.indexOf("</p><p>") > -1) {
            t2 = `<p>${t2}</p>`;
          }
          return t2;
        }
        function Px(t2) {
          return t2.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t3, e2) => {
            if (e2.length == 1) {
              return " ";
            }
            return e2;
          });
        }
        const Sx = ["figcaption", "li"];
        function Ex(t2) {
          let e2 = "";
          if (t2.is("text") || t2.is("textProxy")) {
            e2 = t2.data;
          } else if (t2.is("img") && t2.hasAttribute("alt")) {
            e2 = t2.getAttribute("alt");
          } else {
            let i2 = null;
            for (const n2 of t2.getChildren()) {
              const t3 = Ex(n2);
              if (i2 && (i2.is("containerElement") || n2.is("containerElement"))) {
                if (Sx.includes(i2.name) || Sx.includes(n2.name)) {
                  e2 += "\n";
                } else {
                  e2 += "\n\n";
                }
              }
              e2 += t3;
              i2 = n2;
            }
          }
          return e2;
        }
        class Rx extends mp {
          static get pluginName() {
            return "Clipboard";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.document;
            const i2 = t2.editing.view;
            const n2 = i2.document;
            this._htmlDataProcessor = new gp(n2);
            i2.addObserver(Cx);
            this.listenTo(n2, "clipboardInput", (e3) => {
              if (t2.isReadOnly) {
                e3.stop();
              }
            }, {priority: "highest"});
            this.listenTo(n2, "clipboardInput", (t3, e3) => {
              const n3 = e3.dataTransfer;
              let o3 = "";
              if (n3.getData("text/html")) {
                o3 = Px(n3.getData("text/html"));
              } else if (n3.getData("text/plain")) {
                o3 = Tx(n3.getData("text/plain"));
              }
              o3 = this._htmlDataProcessor.toView(o3);
              this.fire("inputTransformation", {content: o3, dataTransfer: n3});
              i2.scrollToTheSelection();
            }, {priority: "low"});
            this.listenTo(this, "inputTransformation", (t3, e3) => {
              if (!e3.content.isEmpty) {
                const t4 = this.editor.data;
                const i3 = this.editor.model;
                const n3 = t4.toModel(e3.content, "$clipboardHolder");
                if (n3.childCount == 0) {
                  return;
                }
                i3.insertContent(n3);
              }
            }, {priority: "low"});
            function o2(i3, o3) {
              const r2 = o3.dataTransfer;
              o3.preventDefault();
              const s2 = t2.data.toView(t2.model.getSelectedContent(e2.selection));
              n2.fire("clipboardOutput", {dataTransfer: r2, content: s2, method: i3.name});
            }
            this.listenTo(n2, "copy", o2, {priority: "low"});
            this.listenTo(n2, "cut", (e3, i3) => {
              if (t2.isReadOnly) {
                i3.preventDefault();
              } else {
                o2(e3, i3);
              }
            }, {priority: "low"});
            this.listenTo(n2, "clipboardOutput", (i3, n3) => {
              if (!n3.content.isEmpty) {
                n3.dataTransfer.setData("text/html", this._htmlDataProcessor.toData(n3.content));
                n3.dataTransfer.setData("text/plain", Ex(n3.content));
              }
              if (n3.method == "cut") {
                t2.model.deleteContent(e2.selection);
              }
            }, {priority: "low"});
          }
        }
        class Ox {
          constructor(t2) {
            this.document = t2;
          }
          createDocumentFragment(t2) {
            return new ql(this.document, t2);
          }
          createElement(t2, e2, i2) {
            return new zc(this.document, t2, e2, i2);
          }
          createText(t2) {
            return new Ls(this.document, t2);
          }
          clone(t2, e2 = false) {
            return t2._clone(e2);
          }
          appendChild(t2, e2) {
            return e2._appendChild(t2);
          }
          insertChild(t2, e2, i2) {
            return i2._insertChild(t2, e2);
          }
          removeChildren(t2, e2, i2) {
            return i2._removeChildren(t2, e2);
          }
          remove(t2) {
            const e2 = t2.parent;
            if (e2) {
              return this.removeChildren(e2.getChildIndex(t2), 1, e2);
            }
            return [];
          }
          replace(t2, e2) {
            const i2 = t2.parent;
            if (i2) {
              const n2 = i2.getChildIndex(t2);
              this.removeChildren(n2, 1, i2);
              this.insertChild(n2, e2, i2);
              return true;
            }
            return false;
          }
          unwrapElement(t2) {
            const e2 = t2.parent;
            if (e2) {
              const i2 = e2.getChildIndex(t2);
              this.remove(t2);
              this.insertChild(i2, t2.getChildren(), e2);
            }
          }
          rename(t2, e2) {
            const i2 = new zc(this.document, t2, e2.getAttributes(), e2.getChildren());
            return this.replace(e2, i2) ? i2 : null;
          }
          setAttribute(t2, e2, i2) {
            i2._setAttribute(t2, e2);
          }
          removeAttribute(t2, e2) {
            e2._removeAttribute(t2);
          }
          addClass(t2, e2) {
            e2._addClass(t2);
          }
          removeClass(t2, e2) {
            e2._removeClass(t2);
          }
          setStyle(t2, e2, i2) {
            if (N(t2) && i2 === void 0) {
              i2 = e2;
            }
            i2._setStyle(t2, e2);
          }
          removeStyle(t2, e2) {
            e2._removeStyle(t2);
          }
          setCustomProperty(t2, e2, i2) {
            i2._setCustomProperty(t2, e2);
          }
          removeCustomProperty(t2, e2) {
            return e2._removeCustomProperty(t2);
          }
          createPositionAt(t2, e2) {
            return dl._createAt(t2, e2);
          }
          createPositionAfter(t2) {
            return dl._createAfter(t2);
          }
          createPositionBefore(t2) {
            return dl._createBefore(t2);
          }
          createRange(t2, e2) {
            return new ul(t2, e2);
          }
          createRangeOn(t2) {
            return ul._createOn(t2);
          }
          createRangeIn(t2) {
            return ul._createIn(t2);
          }
          createSelection(t2, e2, i2) {
            return new gl(t2, e2, i2);
          }
        }
        class Ix extends jw {
          refresh() {
            this.isEnabled = Cv(this.editor.model);
          }
          execute(t2) {
            const e2 = this.editor;
            e2.model.deleteContent(e2.model.document.selection);
            const i2 = e2.model;
            const n2 = e2.plugins.get(lk);
            i2.change((e3) => {
              const o2 = Array.isArray(t2.file) ? t2.file : [t2.file];
              for (const t3 of o2) {
                Vx(e3, i2, n2, t3);
              }
            });
          }
        }
        function Vx(t2, e2, i2, n2) {
          const o2 = i2.createLoader(n2);
          if (!o2) {
            return;
          }
          xv(t2, e2, {uploadId: o2.id});
        }
        class Nx extends mp {
          static get requires() {
            return [lk, vx, Rx];
          }
          static get pluginName() {
            return "ImageUploadEditing";
          }
          constructor(t2) {
            super(t2);
            t2.config.define("image", {upload: {types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]}});
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.document;
            const i2 = t2.model.schema;
            const n2 = t2.conversion;
            const o2 = t2.plugins.get(lk);
            const r2 = Xy(t2.config.get("image.upload.types"));
            i2.extend("image", {allowAttributes: ["uploadId", "uploadStatus"]});
            t2.commands.add("imageUpload", new Ix(t2));
            n2.for("upcast").attributeToAttribute({view: {name: "img", key: "uploadId"}, model: "uploadId"});
            this.listenTo(t2.editing.view.document, "clipboardInput", (e3, i3) => {
              if (Mx(i3.dataTransfer)) {
                return;
              }
              const n3 = Array.from(i3.dataTransfer.files).filter((t3) => {
                if (!t3) {
                  return false;
                }
                return r2.test(t3.type);
              });
              const o3 = i3.targetRanges.map((e4) => t2.editing.mapper.toModelRange(e4));
              t2.model.change((i4) => {
                i4.setSelection(o3);
                if (n3.length) {
                  e3.stop();
                  t2.model.enqueueChange("default", () => {
                    t2.execute("imageUpload", {file: n3});
                  });
                }
              });
            });
            this.listenTo(t2.plugins.get(Rx), "inputTransformation", (e3, i3) => {
              const n3 = Array.from(t2.editing.view.createRangeIn(i3.content)).filter((t3) => tx(t3.item) && !t3.item.getAttribute("uploadProcessed")).map((t3) => ({
                promise: Zy(t3.item),
                imageElement: t3.item
              }));
              if (!n3.length) {
                return;
              }
              const r3 = new Ox(t2.editing.view.document);
              for (const t3 of n3) {
                r3.setAttribute("uploadProcessed", true, t3.imageElement);
                const e4 = o2.createLoader(t3.promise);
                if (e4) {
                  r3.setAttribute("src", "", t3.imageElement);
                  r3.setAttribute("uploadId", e4.id, t3.imageElement);
                }
              }
            });
            t2.editing.view.document.on("dragover", (t3, e3) => {
              e3.preventDefault();
            });
            e2.on("change", () => {
              const i3 = e2.differ.getChanges({includeChangesInGraveyard: true});
              for (const e3 of i3) {
                if (e3.type == "insert" && e3.name != "$text") {
                  const i4 = e3.position.nodeAfter;
                  const n3 = e3.position.root.rootName == "$graveyard";
                  for (const e4 of Bx(t2, i4)) {
                    const t3 = e4.getAttribute("uploadId");
                    if (!t3) {
                      continue;
                    }
                    const i5 = o2.loaders.get(t3);
                    if (!i5) {
                      continue;
                    }
                    if (n3) {
                      i5.abort();
                    } else if (i5.status == "idle") {
                      this._readAndUpload(i5, e4);
                    }
                  }
                }
              }
            });
          }
          _readAndUpload(t2, e2) {
            const i2 = this.editor;
            const n2 = i2.model;
            const o2 = i2.locale.t;
            const r2 = i2.plugins.get(lk);
            const s2 = i2.plugins.get(vx);
            n2.enqueueChange("transparent", (t3) => {
              t3.setAttribute("uploadStatus", "reading", e2);
            });
            return t2.read().then(() => {
              const o3 = t2.upload();
              if (Al.isSafari) {
                const t3 = i2.editing.mapper.toViewElement(e2);
                const n3 = Av(t3);
                i2.editing.view.once("render", () => {
                  if (!n3.parent) {
                    return;
                  }
                  const t4 = i2.editing.view.domConverter.mapViewToDom(n3.parent);
                  if (!t4) {
                    return;
                  }
                  const e3 = t4.style.display;
                  t4.style.display = "none";
                  t4._ckHack = t4.offsetHeight;
                  t4.style.display = e3;
                });
              }
              n2.enqueueChange("transparent", (t3) => {
                t3.setAttribute("uploadStatus", "uploading", e2);
              });
              return o3;
            }).then((t3) => {
              n2.enqueueChange("transparent", (i3) => {
                i3.setAttributes({uploadStatus: "complete", src: t3.default}, e2);
                this._parseAndSetSrcsetAttributeOnImage(t3, e2, i3);
              });
              a2();
            }).catch((i3) => {
              if (t2.status !== "error" && t2.status !== "aborted") {
                throw i3;
              }
              if (t2.status == "error" && i3) {
                s2.showWarning(i3, {title: o2("ke"), namespace: "upload"});
              }
              a2();
              n2.enqueueChange("transparent", (t3) => {
                t3.remove(e2);
              });
            });
            function a2() {
              n2.enqueueChange("transparent", (t3) => {
                t3.removeAttribute("uploadId", e2);
                t3.removeAttribute("uploadStatus", e2);
              });
              r2.destroyLoader(t2);
            }
          }
          _parseAndSetSrcsetAttributeOnImage(t2, e2, i2) {
            let n2 = 0;
            const o2 = Object.keys(t2).filter((t3) => {
              const e3 = parseInt(t3, 10);
              if (!isNaN(e3)) {
                n2 = Math.max(n2, e3);
                return true;
              }
            }).map((e3) => `${t2[e3]} ${e3}w`).join(", ");
            if (o2 != "") {
              i2.setAttribute("srcset", {data: o2, width: n2}, e2);
            }
          }
        }
        function Mx(t2) {
          return Array.from(t2.types).includes("text/html") && t2.getData("text/html") !== "";
        }
        function Bx(t2, e2) {
          return Array.from(t2.model.createRangeOn(e2)).filter((t3) => t3.item.is("image")).map((t3) => t3.item);
        }
        class zx extends mp {
          static get pluginName() {
            return "ImageUpload";
          }
          static get requires() {
            return [Nx, nx, cx];
          }
        }
        class Lx extends jw {
          constructor(t2) {
            super(t2);
            this._childCommands = [];
          }
          refresh() {
          }
          execute(...t2) {
            const e2 = this._getFirstEnabledCommand();
            e2.execute(t2);
          }
          registerChildCommand(t2) {
            this._childCommands.push(t2);
            t2.on("change:isEnabled", () => this._checkEnabled());
            this._checkEnabled();
          }
          _checkEnabled() {
            this.isEnabled = !!this._getFirstEnabledCommand();
          }
          _getFirstEnabledCommand() {
            return this._childCommands.find((t2) => t2.isEnabled);
          }
        }
        class Fx extends mp {
          static get pluginName() {
            return "IndentEditing";
          }
          init() {
            const t2 = this.editor;
            t2.commands.add("indent", new Lx(t2));
            t2.commands.add("outdent", new Lx(t2));
          }
        }
        var Dx = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95L5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
        var jx = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
        class Hx extends mp {
          static get pluginName() {
            return "IndentUI";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.locale;
            const i2 = t2.t;
            const n2 = e2.uiLanguageDirection == "ltr" ? Dx : jx;
            const o2 = e2.uiLanguageDirection == "ltr" ? jx : Dx;
            this._defineButton("indent", i2("jg"), n2);
            this._defineButton("outdent", i2("jh"), o2);
          }
          _defineButton(t2, e2, i2) {
            const n2 = this.editor;
            n2.ui.componentFactory.add(t2, (o2) => {
              const r2 = n2.commands.get(t2);
              const s2 = new hb(o2);
              s2.set({label: e2, icon: i2, tooltip: true});
              s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled");
              this.listenTo(s2, "execute", () => {
                n2.execute(t2);
                n2.editing.view.focus();
              });
              return s2;
            });
          }
        }
        class Wx extends mp {
          static get pluginName() {
            return "Indent";
          }
          static get requires() {
            return [Fx, Hx];
          }
        }
        class qx extends jw {
          constructor(t2, e2) {
            super(t2);
            this._indentBehavior = e2;
          }
          refresh() {
            const t2 = this.editor;
            const e2 = t2.model;
            const i2 = Ww(e2.document.selection.getSelectedBlocks());
            if (!i2 || !e2.schema.checkAttribute(i2, "blockIndent")) {
              this.isEnabled = false;
              return;
            }
            this.isEnabled = this._indentBehavior.checkEnabled(i2.getAttribute("blockIndent"));
          }
          execute() {
            const t2 = this.editor.model;
            const e2 = Ux(t2);
            t2.change((t3) => {
              for (const i2 of e2) {
                const e3 = i2.getAttribute("blockIndent");
                const n2 = this._indentBehavior.getNextIndent(e3);
                if (n2) {
                  t3.setAttribute("blockIndent", n2, i2);
                } else {
                  t3.removeAttribute("blockIndent", i2);
                }
              }
            });
          }
        }
        function Ux(t2) {
          const e2 = t2.document.selection;
          const i2 = t2.schema;
          const n2 = Array.from(e2.getSelectedBlocks());
          return n2.filter((t3) => i2.checkAttribute(t3, "blockIndent"));
        }
        class $x {
          constructor(t2) {
            this.isForward = t2.direction === "forward";
            this.offset = t2.offset;
            this.unit = t2.unit;
          }
          checkEnabled(t2) {
            const e2 = parseFloat(t2 || 0);
            return this.isForward || e2 > 0;
          }
          getNextIndent(t2) {
            const e2 = parseFloat(t2 || 0);
            const i2 = !t2 || t2.endsWith(this.unit);
            if (!i2) {
              return this.isForward ? this.offset + this.unit : void 0;
            }
            const n2 = this.isForward ? this.offset : -this.offset;
            const o2 = e2 + n2;
            return o2 > 0 ? o2 + this.unit : void 0;
          }
        }
        class Gx {
          constructor(t2) {
            this.isForward = t2.direction === "forward";
            this.classes = t2.classes;
          }
          checkEnabled(t2) {
            const e2 = this.classes.indexOf(t2);
            if (this.isForward) {
              return e2 < this.classes.length - 1;
            } else {
              return e2 >= 0;
            }
          }
          getNextIndent(t2) {
            const e2 = this.classes.indexOf(t2);
            const i2 = this.isForward ? 1 : -1;
            return this.classes[e2 + i2];
          }
        }
        const Kx = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
        const Jx = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
        const Yx = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
        const Qx = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
        const Xx = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
        const Zx = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "rebeccapurple", "currentcolor", "transparent"]);
        function tC(t2) {
          if (t2.startsWith("#")) {
            return Kx.test(t2);
          }
          if (t2.startsWith("rgb")) {
            return Jx.test(t2) || Yx.test(t2);
          }
          if (t2.startsWith("hsl")) {
            return Qx.test(t2) || Xx.test(t2);
          }
          return Zx.has(t2.toLowerCase());
        }
        const eC = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
        function iC(t2) {
          return eC.includes(t2);
        }
        const nC = /^([+-]?[0-9]*[.]?[0-9]+(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
        function oC(t2) {
          return nC.test(t2);
        }
        const rC = /^[+-]?[0-9]*[.]?[0-9]+%$/;
        function sC(t2) {
          return rC.test(t2);
        }
        const aC = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];
        function cC(t2) {
          return aC.includes(t2);
        }
        const lC = ["center", "top", "bottom", "left", "right"];
        function dC(t2) {
          return lC.includes(t2);
        }
        const uC = ["fixed", "scroll", "local"];
        function hC(t2) {
          return uC.includes(t2);
        }
        const fC = /^url\(/;
        function gC(t2) {
          return fC.test(t2);
        }
        function mC(t2 = "") {
          if (t2 === "") {
            return {top: void 0, right: void 0, bottom: void 0, left: void 0};
          }
          const e2 = kC(t2);
          const i2 = e2[0];
          const n2 = e2[2] || i2;
          const o2 = e2[1] || i2;
          const r2 = e2[3] || o2;
          return {top: i2, bottom: n2, right: o2, left: r2};
        }
        function pC(t2) {
          return (e2) => {
            const {top: i2, right: n2, bottom: o2, left: r2} = e2;
            const s2 = [];
            if (![i2, n2, r2, o2].every((t3) => !!t3)) {
              if (i2) {
                s2.push([t2 + "-top", i2]);
              }
              if (n2) {
                s2.push([t2 + "-right", n2]);
              }
              if (o2) {
                s2.push([t2 + "-bottom", o2]);
              }
              if (r2) {
                s2.push([t2 + "-left", r2]);
              }
            } else {
              s2.push([t2, bC(e2)]);
            }
            return s2;
          };
        }
        function bC({top: t2, right: e2, bottom: i2, left: n2}) {
          const o2 = [];
          if (n2 !== e2) {
            o2.push(t2, e2, i2, n2);
          } else if (i2 !== t2) {
            o2.push(t2, e2, i2);
          } else if (e2 !== t2) {
            o2.push(t2, e2);
          } else {
            o2.push(t2);
          }
          return o2.join(" ");
        }
        function wC(t2) {
          return (e2) => ({path: t2, value: mC(e2)});
        }
        function kC(t2) {
          return t2.replace(/, /g, ",").split(" ").map((t3) => t3.replace(/,/g, ", "));
        }
        function _C(t2) {
          t2.setNormalizer("margin", wC("margin"));
          t2.setNormalizer("margin-top", (t3) => ({path: "margin.top", value: t3}));
          t2.setNormalizer("margin-right", (t3) => ({path: "margin.right", value: t3}));
          t2.setNormalizer("margin-bottom", (t3) => ({path: "margin.bottom", value: t3}));
          t2.setNormalizer("margin-left", (t3) => ({path: "margin.left", value: t3}));
          t2.setReducer("margin", pC("margin"));
          t2.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
        }
        class vC extends mp {
          constructor(t2) {
            super(t2);
            t2.config.define("indentBlock", {offset: 40, unit: "px"});
          }
          static get pluginName() {
            return "IndentBlock";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.config.get("indentBlock");
            const i2 = !e2.classes || !e2.classes.length;
            const n2 = Object.assign({direction: "forward"}, e2);
            const o2 = Object.assign({direction: "backward"}, e2);
            if (i2) {
              t2.data.addStyleProcessorRules(_C);
              this._setupConversionUsingOffset(t2.conversion);
              t2.commands.add("indentBlock", new qx(t2, new $x(n2)));
              t2.commands.add("outdentBlock", new qx(t2, new $x(o2)));
            } else {
              this._setupConversionUsingClasses(e2.classes);
              t2.commands.add("indentBlock", new qx(t2, new Gx(n2)));
              t2.commands.add("outdentBlock", new qx(t2, new Gx(o2)));
            }
          }
          afterInit() {
            const t2 = this.editor;
            const e2 = t2.model.schema;
            const i2 = t2.commands.get("indent");
            const n2 = t2.commands.get("outdent");
            const o2 = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
            o2.forEach((t3) => {
              if (e2.isRegistered(t3)) {
                e2.extend(t3, {allowAttributes: "blockIndent"});
              }
            });
            i2.registerChildCommand(t2.commands.get("indentBlock"));
            n2.registerChildCommand(t2.commands.get("outdentBlock"));
          }
          _setupConversionUsingOffset() {
            const t2 = this.editor.conversion;
            const e2 = this.editor.locale;
            const i2 = e2.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
            t2.for("upcast").attributeToAttribute({
              view: {styles: {[i2]: /[\s\S]+/}},
              model: {key: "blockIndent", value: (t3) => t3.getStyle(i2)}
            });
            t2.for("downcast").attributeToAttribute({
              model: "blockIndent",
              view: (t3) => ({key: "style", value: {[i2]: t3}})
            });
          }
          _setupConversionUsingClasses(t2) {
            const e2 = {model: {key: "blockIndent", values: []}, view: {}};
            for (const i2 of t2) {
              e2.model.values.push(i2);
              e2.view[i2] = {key: "class", value: [i2]};
            }
            this.editor.conversion.attributeToAttribute(e2);
          }
        }
        const yC = "italic";
        class xC extends mp {
          static get pluginName() {
            return "ItalicEditing";
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", {allowAttributes: yC});
            t2.model.schema.setAttributeProperties(yC, {isFormatting: true, copyOnEnter: true});
            t2.conversion.attributeToElement({
              model: yC,
              view: "i",
              upcastAlso: ["em", {styles: {"font-style": "italic"}}]
            });
            t2.commands.add(yC, new yk(t2, yC));
            t2.keystrokes.set("CTRL+I", yC);
          }
        }
        var CC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.586 14.633l.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
        const AC = "italic";
        class TC extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add(AC, (i2) => {
              const n2 = t2.commands.get(AC);
              const o2 = new hb(i2);
              o2.set({label: e2("jj"), icon: CC, keystroke: "CTRL+I", tooltip: true, isToggleable: true});
              o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute(AC);
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class PC extends mp {
          static get requires() {
            return [xC, TC];
          }
          static get pluginName() {
            return "Italic";
          }
        }
        function SC(t2, e2, i2) {
          return i2.createRange(EC(t2, e2, true, i2), EC(t2, e2, false, i2));
        }
        function EC(t2, e2, i2, n2) {
          let o2 = t2.textNode || (i2 ? t2.nodeBefore : t2.nodeAfter);
          let r2 = null;
          while (o2 && o2.getAttribute("linkHref") == e2) {
            r2 = o2;
            o2 = i2 ? o2.previousSibling : o2.nextSibling;
          }
          return r2 ? n2.createPositionAt(r2, i2 ? "before" : "after") : t2;
        }
        class RC extends jw {
          constructor(t2) {
            super(t2);
            this.manualDecorators = new ys();
          }
          restoreManualDecoratorStates() {
            for (const t2 of this.manualDecorators) {
              t2.value = this._getDecoratorStateFromModel(t2.id);
            }
          }
          refresh() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            this.value = e2.selection.getAttribute("linkHref");
            for (const t3 of this.manualDecorators) {
              t3.value = this._getDecoratorStateFromModel(t3.id);
            }
            this.isEnabled = t2.schema.checkAttributeInSelection(e2.selection, "linkHref");
          }
          execute(t2, e2 = {}) {
            const i2 = this.editor.model;
            const n2 = i2.document.selection;
            const o2 = [];
            const r2 = [];
            for (const t3 in e2) {
              if (e2[t3]) {
                o2.push(t3);
              } else {
                r2.push(t3);
              }
            }
            i2.change((e3) => {
              if (n2.isCollapsed) {
                const s2 = n2.getFirstPosition();
                if (n2.hasAttribute("linkHref")) {
                  const a2 = SC(s2, n2.getAttribute("linkHref"), i2);
                  e3.setAttribute("linkHref", t2, a2);
                  o2.forEach((t3) => {
                    e3.setAttribute(t3, true, a2);
                  });
                  r2.forEach((t3) => {
                    e3.removeAttribute(t3, a2);
                  });
                  e3.setSelection(a2);
                } else if (t2 !== "") {
                  const r3 = Hs(n2.getAttributes());
                  r3.set("linkHref", t2);
                  o2.forEach((t3) => {
                    r3.set(t3, true);
                  });
                  const a2 = e3.createText(t2, r3);
                  i2.insertContent(a2, s2);
                  e3.setSelection(e3.createRangeOn(a2));
                }
              } else {
                const s2 = i2.schema.getValidRanges(n2.getRanges(), "linkHref");
                for (const i3 of s2) {
                  e3.setAttribute("linkHref", t2, i3);
                  o2.forEach((t3) => {
                    e3.setAttribute(t3, true, i3);
                  });
                  r2.forEach((t3) => {
                    e3.removeAttribute(t3, i3);
                  });
                }
              }
            });
          }
          _getDecoratorStateFromModel(t2) {
            const e2 = this.editor.model.document;
            return e2.selection.getAttribute(t2) || false;
          }
        }
        class OC extends jw {
          refresh() {
            this.isEnabled = this.editor.model.document.selection.hasAttribute("linkHref");
          }
          execute() {
            const t2 = this.editor;
            const e2 = this.editor.model;
            const i2 = e2.document.selection;
            const n2 = t2.commands.get("link");
            e2.change((t3) => {
              const o2 = i2.isCollapsed ? [SC(i2.getFirstPosition(), i2.getAttribute("linkHref"), e2)] : i2.getRanges();
              for (const e3 of o2) {
                t3.removeAttribute("linkHref", e3);
                if (n2) {
                  for (const i3 of n2.manualDecorators) {
                    t3.removeAttribute(i3.id, e3);
                  }
                }
              }
            });
          }
        }
        function IC(t2, e2, i2) {
          var n2 = t2.length;
          i2 = i2 === void 0 ? n2 : i2;
          return !e2 && i2 >= n2 ? t2 : Oa(t2, e2, i2);
        }
        var VC = IC;
        var NC = "\\ud800-\\udfff", MC = "\\u0300-\\u036f", BC = "\\ufe20-\\ufe2f", zC = "\\u20d0-\\u20ff", LC = MC + BC + zC, FC = "\\ufe0e\\ufe0f";
        var DC = "\\u200d";
        var jC = RegExp("[" + DC + NC + LC + FC + "]");
        function HC(t2) {
          return jC.test(t2);
        }
        var WC = HC;
        function qC(t2) {
          return t2.split("");
        }
        var UC = qC;
        var $C = "\\ud800-\\udfff", GC = "\\u0300-\\u036f", KC = "\\ufe20-\\ufe2f", JC = "\\u20d0-\\u20ff", YC = GC + KC + JC, QC = "\\ufe0e\\ufe0f";
        var XC = "[" + $C + "]", ZC = "[" + YC + "]", tA = "\\ud83c[\\udffb-\\udfff]", eA = "(?:" + ZC + "|" + tA + ")", iA = "[^" + $C + "]", nA = "(?:\\ud83c[\\udde6-\\uddff]){2}", oA = "[\\ud800-\\udbff][\\udc00-\\udfff]", rA = "\\u200d";
        var sA = eA + "?", aA = "[" + QC + "]?", cA = "(?:" + rA + "(?:" + [iA, nA, oA].join("|") + ")" + aA + sA + ")*", lA = aA + sA + cA, dA = "(?:" + [iA + ZC + "?", ZC, nA, oA, XC].join("|") + ")";
        var uA = RegExp(tA + "(?=" + tA + ")|" + dA + lA, "g");
        function hA(t2) {
          return t2.match(uA) || [];
        }
        var fA = hA;
        function gA(t2) {
          return WC(t2) ? fA(t2) : UC(t2);
        }
        var mA = gA;
        function pA(t2) {
          return function(e2) {
            e2 = _a(e2);
            var i2 = WC(e2) ? mA(e2) : void 0;
            var n2 = i2 ? i2[0] : e2.charAt(0);
            var o2 = i2 ? VC(i2, 1).join("") : e2.slice(1);
            return n2[t2]() + o2;
          };
        }
        var bA = pA;
        var wA = bA("toUpperCase");
        var kA = wA;
        const _A = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
        const vA = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
        function yA(t2) {
          return t2.is("attributeElement") && !!t2.getCustomProperty("link");
        }
        function xA(t2, e2) {
          const i2 = e2.createAttributeElement("a", {href: t2}, {priority: 5});
          e2.setCustomProperty("link", true, i2);
          return i2;
        }
        function CA(t2) {
          t2 = String(t2);
          return AA(t2) ? t2 : "#";
        }
        function AA(t2) {
          const e2 = t2.replace(_A, "");
          return e2.match(vA);
        }
        function TA(t2, e2) {
          const i2 = {"Open in a new tab": t2("mm"), Downloadable: t2("mn")};
          e2.forEach((t3) => {
            if (t3.label && i2[t3.label]) {
              t3.label = i2[t3.label];
            }
            return t3;
          });
          return e2;
        }
        function PA(t2) {
          const e2 = [];
          if (t2) {
            for (const [i2, n2] of Object.entries(t2)) {
              const t3 = Object.assign({}, n2, {id: `link${kA(i2)}`});
              e2.push(t3);
            }
          }
          return e2;
        }
        class SA {
          constructor() {
            this._definitions = new Set();
          }
          get length() {
            return this._definitions.size;
          }
          add(t2) {
            if (Array.isArray(t2)) {
              t2.forEach((t3) => this._definitions.add(t3));
            } else {
              this._definitions.add(t2);
            }
          }
          getDispatcher() {
            return (t2) => {
              t2.on("attribute:linkHref", (t3, e2, i2) => {
                if (!i2.consumable.test(e2.item, "attribute:linkHref")) {
                  return;
                }
                const n2 = i2.writer;
                const o2 = n2.document.selection;
                for (const t4 of this._definitions) {
                  const r2 = n2.createAttributeElement("a", t4.attributes, {priority: 5});
                  n2.setCustomProperty("link", true, r2);
                  if (t4.callback(e2.attributeNewValue)) {
                    if (e2.item.is("selection")) {
                      n2.wrap(o2.getFirstRange(), r2);
                    } else {
                      n2.wrap(i2.mapper.toViewRange(e2.range), r2);
                    }
                  } else {
                    n2.unwrap(i2.mapper.toViewRange(e2.range), r2);
                  }
                }
              }, {priority: "high"});
            };
          }
        }
        class EA {
          constructor({id: t2, label: e2, attributes: i2}) {
            this.id = t2;
            this.set("value");
            this.label = e2;
            this.attributes = i2;
          }
        }
        vs(EA, Jc);
        function RA({view: t2, model: e2, emitter: i2, attribute: n2, locale: o2}) {
          const r2 = new OA(e2, i2, n2);
          const s2 = e2.document.selection;
          i2.listenTo(t2.document, "keydown", (t3, e3) => {
            if (!s2.isCollapsed) {
              return;
            }
            if (e3.shiftKey || e3.altKey || e3.ctrlKey) {
              return;
            }
            const i3 = e3.keyCode == Nl.arrowright;
            const n3 = e3.keyCode == Nl.arrowleft;
            if (!i3 && !n3) {
              return;
            }
            const a2 = s2.getFirstPosition();
            const c2 = o2.contentLanguageDirection;
            let l2;
            if (c2 === "ltr" && i3 || c2 === "rtl" && n3) {
              l2 = r2.handleForwardMovement(a2, e3);
            } else {
              l2 = r2.handleBackwardMovement(a2, e3);
            }
            if (l2) {
              t3.stop();
            }
          }, {priority: os.get("high") + 1});
        }
        class OA {
          constructor(t2, e2, i2) {
            this.model = t2;
            this.attribute = i2;
            this._modelSelection = t2.document.selection;
            this._overrideUid = null;
            this._isNextGravityRestorationSkipped = false;
            e2.listenTo(this._modelSelection, "change:range", (t3, e3) => {
              if (this._isNextGravityRestorationSkipped) {
                this._isNextGravityRestorationSkipped = false;
                return;
              }
              if (!this._isGravityOverridden) {
                return;
              }
              if (!e3.directChange && IA(this._modelSelection.getFirstPosition(), i2)) {
                return;
              }
              this._restoreGravity();
            });
          }
          handleForwardMovement(t2, e2) {
            const i2 = this.attribute;
            if (this._isGravityOverridden) {
              return;
            }
            if (t2.isAtStart && this._hasSelectionAttribute) {
              return;
            }
            if (MA(t2, i2) && this._hasSelectionAttribute) {
              this._preventCaretMovement(e2);
              this._removeSelectionAttribute();
              return true;
            }
            if (VA(t2, i2)) {
              this._preventCaretMovement(e2);
              this._overrideGravity();
              return true;
            }
            if (NA(t2, i2) && this._hasSelectionAttribute) {
              this._preventCaretMovement(e2);
              this._overrideGravity();
              return true;
            }
          }
          handleBackwardMovement(t2, e2) {
            const i2 = this.attribute;
            if (this._isGravityOverridden) {
              if (MA(t2, i2) && this._hasSelectionAttribute) {
                this._preventCaretMovement(e2);
                this._restoreGravity();
                this._removeSelectionAttribute();
                return true;
              } else {
                this._preventCaretMovement(e2);
                this._restoreGravity();
                if (t2.isAtStart) {
                  this._removeSelectionAttribute();
                }
                return true;
              }
            } else {
              if (MA(t2, i2) && !this._hasSelectionAttribute) {
                this._preventCaretMovement(e2);
                this._setSelectionAttributeFromTheNodeBefore(t2);
                return true;
              }
              if (t2.isAtEnd && NA(t2, i2)) {
                if (this._hasSelectionAttribute) {
                  if (BA(t2, i2)) {
                    this._skipNextAutomaticGravityRestoration();
                    this._overrideGravity();
                  }
                  return;
                } else {
                  this._preventCaretMovement(e2);
                  this._setSelectionAttributeFromTheNodeBefore(t2);
                  return true;
                }
              }
              if (t2.isAtStart) {
                if (this._hasSelectionAttribute) {
                  this._removeSelectionAttribute();
                  this._preventCaretMovement(e2);
                  return true;
                }
                return;
              }
              if (BA(t2, i2)) {
                this._skipNextAutomaticGravityRestoration();
                this._overrideGravity();
              }
            }
          }
          get _isGravityOverridden() {
            return !!this._overrideUid;
          }
          get _hasSelectionAttribute() {
            return this._modelSelection.hasAttribute(this.attribute);
          }
          _overrideGravity() {
            this._overrideUid = this.model.change((t2) => t2.overrideSelectionGravity());
          }
          _restoreGravity() {
            this.model.change((t2) => {
              t2.restoreSelectionGravity(this._overrideUid);
              this._overrideUid = null;
            });
          }
          _preventCaretMovement(t2) {
            t2.preventDefault();
          }
          _removeSelectionAttribute() {
            this.model.change((t2) => {
              t2.removeSelectionAttribute(this.attribute);
            });
          }
          _setSelectionAttributeFromTheNodeBefore(t2) {
            const e2 = this.attribute;
            this.model.change((i2) => {
              i2.setSelectionAttribute(this.attribute, t2.nodeBefore.getAttribute(e2));
            });
          }
          _skipNextAutomaticGravityRestoration() {
            this._isNextGravityRestorationSkipped = true;
          }
        }
        function IA(t2, e2) {
          return VA(t2, e2) || NA(t2, e2);
        }
        function VA(t2, e2) {
          const {nodeBefore: i2, nodeAfter: n2} = t2;
          const o2 = i2 ? i2.hasAttribute(e2) : false;
          const r2 = n2 ? n2.hasAttribute(e2) : false;
          return r2 && (!o2 || i2.getAttribute(e2) !== n2.getAttribute(e2));
        }
        function NA(t2, e2) {
          const {nodeBefore: i2, nodeAfter: n2} = t2;
          const o2 = i2 ? i2.hasAttribute(e2) : false;
          const r2 = n2 ? n2.hasAttribute(e2) : false;
          return o2 && (!r2 || i2.getAttribute(e2) !== n2.getAttribute(e2));
        }
        function MA(t2, e2) {
          const {nodeBefore: i2, nodeAfter: n2} = t2;
          const o2 = i2 ? i2.hasAttribute(e2) : false;
          const r2 = n2 ? n2.hasAttribute(e2) : false;
          if (!r2 || !o2) {
            return;
          }
          return n2.getAttribute(e2) !== i2.getAttribute(e2);
        }
        function BA(t2, e2) {
          return IA(t2.getShiftedBy(-1), e2);
        }
        var zA = i(80);
        const LA = "ck-link_selected";
        const FA = "automatic";
        const DA = "manual";
        const jA = /^(https?:)?\/\//;
        class HA extends mp {
          static get pluginName() {
            return "LinkEditing";
          }
          constructor(t2) {
            super(t2);
            t2.config.define("link", {addTargetToExternalLinks: false});
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.locale;
            t2.model.schema.extend("$text", {allowAttributes: "linkHref"});
            t2.conversion.for("dataDowncast").attributeToElement({model: "linkHref", view: xA});
            t2.conversion.for("editingDowncast").attributeToElement({
              model: "linkHref",
              view: (t3, e3) => xA(CA(t3), e3)
            });
            t2.conversion.for("upcast").elementToAttribute({
              view: {name: "a", attributes: {href: true}},
              model: {key: "linkHref", value: (t3) => t3.getAttribute("href")}
            });
            t2.commands.add("link", new RC(t2));
            t2.commands.add("unlink", new OC(t2));
            const i2 = TA(t2.t, PA(t2.config.get("link.decorators")));
            this._enableAutomaticDecorators(i2.filter((t3) => t3.mode === FA));
            this._enableManualDecorators(i2.filter((t3) => t3.mode === DA));
            RA({view: t2.editing.view, model: t2.model, emitter: this, attribute: "linkHref", locale: e2});
            this._setupLinkHighlight();
          }
          _enableAutomaticDecorators(t2) {
            const e2 = this.editor;
            const i2 = new SA();
            if (e2.config.get("link.addTargetToExternalLinks")) {
              i2.add({
                id: "linkIsExternal",
                mode: FA,
                callback: (t3) => jA.test(t3),
                attributes: {target: "_blank", rel: "noopener noreferrer"}
              });
            }
            i2.add(t2);
            if (i2.length) {
              e2.conversion.for("downcast").add(i2.getDispatcher());
            }
          }
          _enableManualDecorators(t2) {
            if (!t2.length) {
              return;
            }
            const e2 = this.editor;
            const i2 = e2.commands.get("link");
            const n2 = i2.manualDecorators;
            t2.forEach((t3) => {
              e2.model.schema.extend("$text", {allowAttributes: t3.id});
              n2.add(new EA(t3));
              e2.conversion.for("downcast").attributeToElement({
                model: t3.id,
                view: (e3, i3) => {
                  if (e3) {
                    const e4 = n2.get(t3.id).attributes;
                    const o2 = i3.createAttributeElement("a", e4, {priority: 5});
                    i3.setCustomProperty("link", true, o2);
                    return o2;
                  }
                }
              });
              e2.conversion.for("upcast").elementToAttribute({
                view: {
                  name: "a",
                  attributes: n2.get(t3.id).attributes
                },
                model: {key: t3.id}
              });
            });
          }
          _setupLinkHighlight() {
            const t2 = this.editor;
            const e2 = t2.editing.view;
            const i2 = new Set();
            e2.document.registerPostFixer((e3) => {
              const n2 = t2.model.document.selection;
              let o2 = false;
              if (n2.hasAttribute("linkHref")) {
                const r2 = SC(n2.getFirstPosition(), n2.getAttribute("linkHref"), t2.model);
                const s2 = t2.editing.mapper.toViewRange(r2);
                for (const t3 of s2.getItems()) {
                  if (t3.is("a") && !t3.hasClass(LA)) {
                    e3.addClass(LA, t3);
                    i2.add(t3);
                    o2 = true;
                  }
                }
              }
              return o2;
            });
            t2.conversion.for("editingDowncast").add((t3) => {
              t3.on("insert", n2, {priority: "highest"});
              t3.on("remove", n2, {priority: "highest"});
              t3.on("attribute", n2, {priority: "highest"});
              t3.on("selection", n2, {priority: "highest"});
              function n2() {
                e2.change((t4) => {
                  for (const e3 of i2.values()) {
                    t4.removeClass(LA, e3);
                    i2.delete(e3);
                  }
                });
              }
            });
          }
        }
        class WA extends Ju {
          constructor(t2) {
            super(t2);
            this.domEventType = "click";
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        var qA = i(82);
        class UA extends Gp {
          constructor(t2, e2 = []) {
            super(t2);
            const i2 = t2.t;
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this.urlInputView = this._createUrlInput();
            this.saveButtonView = this._createButton(i2("lo"), Xv, "ck-button-save");
            this.saveButtonView.type = "submit";
            this.cancelButtonView = this._createButton(i2("lp"), Zv, "ck-button-cancel", "cancel");
            this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e2);
            this.children = this._createFormChildren(e2);
            this._focusables = new bp();
            this._focusCycler = new yb({
              focusables: this._focusables,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: "shift + tab", focusNext: "tab"}
            });
            const n2 = ["ck", "ck-link-form"];
            if (e2.length) {
              n2.push("ck-link-form_layout-vertical");
            }
            this.setTemplate({tag: "form", attributes: {class: n2, tabindex: "-1"}, children: this.children});
          }
          getDecoratorSwitchesState() {
            return Array.from(this._manualDecoratorSwitches).reduce((t2, e2) => {
              t2[e2.name] = e2.isOn;
              return t2;
            }, {});
          }
          render() {
            super.render();
            Qv({view: this});
            const t2 = [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView];
            t2.forEach((t3) => {
              this._focusables.add(t3);
              this.focusTracker.add(t3.element);
            });
            this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createUrlInput() {
            const t2 = this.locale.t;
            const e2 = new Kv(this.locale, Yv);
            e2.label = t2("lq");
            e2.inputView.placeholder = "https://example.com";
            return e2;
          }
          _createButton(t2, e2, i2, n2) {
            const o2 = new hb(this.locale);
            o2.set({label: t2, icon: e2, tooltip: true});
            o2.extendTemplate({attributes: {class: i2}});
            if (n2) {
              o2.delegate("execute").to(this, n2);
            }
            return o2;
          }
          _createManualDecoratorSwitches(t2) {
            const e2 = this.createCollection();
            for (const i2 of t2) {
              const t3 = new Fb(this.locale);
              t3.set({name: i2.id, label: i2.label, withText: true});
              t3.bind("isOn").to(i2, "value");
              t3.on("execute", () => {
                i2.set("value", !t3.isOn);
              });
              e2.add(t3);
            }
            return e2;
          }
          _createFormChildren(t2) {
            const e2 = this.createCollection();
            e2.add(this.urlInputView);
            if (t2.length) {
              const t3 = new Gp();
              t3.setTemplate({
                tag: "ul",
                children: this._manualDecoratorSwitches.map((t4) => ({
                  tag: "li",
                  children: [t4],
                  attributes: {class: ["ck", "ck-list__item"]}
                })),
                attributes: {class: ["ck", "ck-reset", "ck-list"]}
              });
              e2.add(t3);
            }
            e2.add(this.saveButtonView);
            e2.add(this.cancelButtonView);
            return e2;
          }
        }
        var $A = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562l-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
        var GA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.3 17.37l-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506L13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5L9.375 17H19v1.5H8z"/></svg>';
        var KA = i(84);
        class JA extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = t2.t;
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this.previewButtonView = this._createPreviewButton();
            this.unlinkButtonView = this._createButton(e2("lk"), $A, "unlink");
            this.editButtonView = this._createButton(e2("ll"), GA, "edit");
            this.set("href");
            this._focusables = new bp();
            this._focusCycler = new yb({
              focusables: this._focusables,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: "shift + tab", focusNext: "tab"}
            });
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck", "ck-link-actions"], tabindex: "-1"},
              children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
            });
          }
          render() {
            super.render();
            const t2 = [this.previewButtonView, this.editButtonView, this.unlinkButtonView];
            t2.forEach((t3) => {
              this._focusables.add(t3);
              this.focusTracker.add(t3.element);
            });
            this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createButton(t2, e2, i2) {
            const n2 = new hb(this.locale);
            n2.set({label: t2, icon: e2, tooltip: true});
            n2.delegate("execute").to(this, i2);
            return n2;
          }
          _createPreviewButton() {
            const t2 = new hb(this.locale);
            const e2 = this.bindTemplate;
            const i2 = this.t;
            t2.set({withText: true, tooltip: i2("lm")});
            t2.extendTemplate({
              attributes: {
                class: ["ck", "ck-link-actions__preview"],
                href: e2.to("href", (t3) => t3 && CA(t3)),
                target: "_blank",
                rel: "noopener noreferrer"
              }
            });
            t2.bind("label").to(this, "href", (t3) => t3 || i2("ln"));
            t2.bind("isEnabled").to(this, "href", (t3) => !!t3);
            t2.template.tag = "a";
            t2.template.eventListeners = {};
            return t2;
          }
        }
        var YA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
        const QA = "Ctrl+K";
        class XA extends mp {
          static get requires() {
            return [kb];
          }
          static get pluginName() {
            return "LinkUI";
          }
          init() {
            const t2 = this.editor;
            t2.editing.view.addObserver(WA);
            this.actionsView = this._createActionsView();
            this.formView = this._createFormView();
            this._balloon = t2.plugins.get(kb);
            this._createToolbarLinkButton();
            this._enableUserBalloonInteractions();
          }
          destroy() {
            super.destroy();
            this.formView.destroy();
          }
          _createActionsView() {
            const t2 = this.editor;
            const e2 = new JA(t2.locale);
            const i2 = t2.commands.get("link");
            const n2 = t2.commands.get("unlink");
            e2.bind("href").to(i2, "value");
            e2.editButtonView.bind("isEnabled").to(i2);
            e2.unlinkButtonView.bind("isEnabled").to(n2);
            this.listenTo(e2, "edit", () => {
              this._addFormView();
            });
            this.listenTo(e2, "unlink", () => {
              t2.execute("unlink");
              this._hideUI();
            });
            e2.keystrokes.set("Esc", (t3, e3) => {
              this._hideUI();
              e3();
            });
            e2.keystrokes.set(QA, (t3, e3) => {
              this._addFormView();
              e3();
            });
            return e2;
          }
          _createFormView() {
            const t2 = this.editor;
            const e2 = t2.commands.get("link");
            const i2 = new UA(t2.locale, e2.manualDecorators);
            i2.urlInputView.bind("value").to(e2, "value");
            i2.urlInputView.bind("isReadOnly").to(e2, "isEnabled", (t3) => !t3);
            i2.saveButtonView.bind("isEnabled").to(e2);
            this.listenTo(i2, "submit", () => {
              t2.execute("link", i2.urlInputView.inputView.element.value, i2.getDecoratorSwitchesState());
              this._closeFormView();
            });
            this.listenTo(i2, "cancel", () => {
              this._closeFormView();
            });
            i2.keystrokes.set("Esc", (t3, e3) => {
              this._closeFormView();
              e3();
            });
            return i2;
          }
          _createToolbarLinkButton() {
            const t2 = this.editor;
            const e2 = t2.commands.get("link");
            const i2 = t2.t;
            t2.keystrokes.set(QA, (t3, e3) => {
              e3();
              this._showUI(true);
            });
            t2.ui.componentFactory.add("link", (t3) => {
              const n2 = new hb(t3);
              n2.isEnabled = true;
              n2.label = i2("lf");
              n2.icon = YA;
              n2.keystroke = QA;
              n2.tooltip = true;
              n2.isToggleable = true;
              n2.bind("isEnabled").to(e2, "isEnabled");
              n2.bind("isOn").to(e2, "value", (t4) => !!t4);
              this.listenTo(n2, "execute", () => this._showUI(true));
              return n2;
            });
          }
          _enableUserBalloonInteractions() {
            const t2 = this.editor.editing.view.document;
            this.listenTo(t2, "click", () => {
              const t3 = this._getSelectedLinkElement();
              if (t3) {
                this._showUI();
              }
            });
            this.editor.keystrokes.set("Tab", (t3, e2) => {
              if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
                this.actionsView.focus();
                e2();
              }
            }, {priority: "high"});
            this.editor.keystrokes.set("Esc", (t3, e2) => {
              if (this._isUIVisible) {
                this._hideUI();
                e2();
              }
            });
            Db({
              emitter: this.formView,
              activator: () => this._isUIInPanel,
              contextElements: [this._balloon.view.element],
              callback: () => this._hideUI()
            });
          }
          _addActionsView() {
            if (this._areActionsInPanel) {
              return;
            }
            this._balloon.add({view: this.actionsView, position: this._getBalloonPositionData()});
          }
          _addFormView() {
            if (this._isFormInPanel) {
              return;
            }
            const t2 = this.editor;
            const e2 = t2.commands.get("link");
            this._balloon.add({view: this.formView, position: this._getBalloonPositionData()});
            if (this._balloon.visibleView === this.formView) {
              this.formView.urlInputView.select();
            }
            this.formView.urlInputView.inputView.element.value = e2.value || "";
          }
          _closeFormView() {
            const t2 = this.editor.commands.get("link");
            t2.restoreManualDecoratorStates();
            if (t2.value !== void 0) {
              this._removeFormView();
            } else {
              this._hideUI();
            }
          }
          _removeFormView() {
            if (this._isFormInPanel) {
              this.formView.saveButtonView.focus();
              this._balloon.remove(this.formView);
              this.editor.editing.view.focus();
            }
          }
          _showUI(t2 = false) {
            if (!this._getSelectedLinkElement()) {
              this._addActionsView();
              if (t2) {
                this._balloon.showStack("main");
              }
              this._addFormView();
            } else {
              if (this._areActionsVisible) {
                this._addFormView();
              } else {
                this._addActionsView();
              }
              if (t2) {
                this._balloon.showStack("main");
              }
            }
            this._startUpdatingUI();
          }
          _hideUI() {
            if (!this._isUIInPanel) {
              return;
            }
            const t2 = this.editor;
            this.stopListening(t2.ui, "update");
            this.stopListening(this._balloon, "change:visibleView");
            t2.editing.view.focus();
            this._removeFormView();
            this._balloon.remove(this.actionsView);
          }
          _startUpdatingUI() {
            const t2 = this.editor;
            const e2 = t2.editing.view.document;
            let i2 = this._getSelectedLinkElement();
            let n2 = r2();
            const o2 = () => {
              const t3 = this._getSelectedLinkElement();
              const e3 = r2();
              if (i2 && !t3 || !i2 && e3 !== n2) {
                this._hideUI();
              } else if (this._isUIVisible) {
                this._balloon.updatePosition(this._getBalloonPositionData());
              }
              i2 = t3;
              n2 = e3;
            };
            function r2() {
              return e2.selection.focus.getAncestors().reverse().find((t3) => t3.is("element"));
            }
            this.listenTo(t2.ui, "update", o2);
            this.listenTo(this._balloon, "change:visibleView", o2);
          }
          get _isFormInPanel() {
            return this._balloon.hasView(this.formView);
          }
          get _areActionsInPanel() {
            return this._balloon.hasView(this.actionsView);
          }
          get _areActionsVisible() {
            return this._balloon.visibleView === this.actionsView;
          }
          get _isUIInPanel() {
            return this._isFormInPanel || this._areActionsInPanel;
          }
          get _isUIVisible() {
            const t2 = this._balloon.visibleView;
            return t2 == this.formView || this._areActionsVisible;
          }
          _getBalloonPositionData() {
            const t2 = this.editor.editing.view;
            const e2 = t2.document;
            const i2 = this._getSelectedLinkElement();
            const n2 = i2 ? t2.domConverter.mapViewToDom(i2) : t2.domConverter.viewRangeToDom(e2.selection.getFirstRange());
            return {target: n2};
          }
          _getSelectedLinkElement() {
            const t2 = this.editor.editing.view;
            const e2 = t2.document.selection;
            if (e2.isCollapsed) {
              return ZA(e2.getFirstPosition());
            } else {
              const i2 = e2.getFirstRange().getTrimmed();
              const n2 = ZA(i2.start);
              const o2 = ZA(i2.end);
              if (!n2 || n2 != o2) {
                return null;
              }
              if (t2.createRangeIn(n2).getTrimmed().isEqual(i2)) {
                return n2;
              } else {
                return null;
              }
            }
          }
        }
        function ZA(t2) {
          return t2.getAncestors().find((t3) => yA(t3));
        }
        class tT extends mp {
          static get requires() {
            return [HA, XA];
          }
          static get pluginName() {
            return "Link";
          }
        }
        class eT extends jw {
          constructor(t2, e2) {
            super(t2);
            this.type = e2;
          }
          refresh() {
            this.value = this._getValue();
            this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            const i2 = Array.from(e2.selection.getSelectedBlocks()).filter((e3) => nT(e3, t2.schema));
            const n2 = this.value === true;
            t2.change((t3) => {
              if (n2) {
                let e3 = i2[i2.length - 1].nextSibling;
                let n3 = Number.POSITIVE_INFINITY;
                let o2 = [];
                while (e3 && e3.name == "listItem" && e3.getAttribute("listIndent") !== 0) {
                  const t4 = e3.getAttribute("listIndent");
                  if (t4 < n3) {
                    n3 = t4;
                  }
                  const i3 = t4 - n3;
                  o2.push({element: e3, listIndent: i3});
                  e3 = e3.nextSibling;
                }
                o2 = o2.reverse();
                for (const e4 of o2) {
                  t3.setAttribute("listIndent", e4.listIndent, e4.element);
                }
              }
              if (!n2) {
                let t4 = Number.POSITIVE_INFINITY;
                for (const e3 of i2) {
                  if (e3.is("listItem") && e3.getAttribute("listIndent") < t4) {
                    t4 = e3.getAttribute("listIndent");
                  }
                }
                t4 = t4 === 0 ? 1 : t4;
                iT(i2, true, t4);
                iT(i2, false, t4);
              }
              for (const e3 of i2.reverse()) {
                if (n2 && e3.name == "listItem") {
                  t3.rename(e3, "paragraph");
                } else if (!n2 && e3.name != "listItem") {
                  t3.setAttributes({listType: this.type, listIndent: 0}, e3);
                  t3.rename(e3, "listItem");
                } else if (!n2 && e3.name == "listItem" && e3.getAttribute("listType") != this.type) {
                  t3.setAttribute("listType", this.type, e3);
                }
              }
            });
          }
          _getValue() {
            const t2 = Ww(this.editor.model.document.selection.getSelectedBlocks());
            return !!t2 && t2.is("listItem") && t2.getAttribute("listType") == this.type;
          }
          _checkEnabled() {
            if (this.value) {
              return true;
            }
            const t2 = this.editor.model.document.selection;
            const e2 = this.editor.model.schema;
            const i2 = Ww(t2.getSelectedBlocks());
            if (!i2) {
              return false;
            }
            return nT(i2, e2);
          }
        }
        function iT(t2, e2, i2) {
          const n2 = e2 ? t2[0] : t2[t2.length - 1];
          if (n2.is("listItem")) {
            let o2 = n2[e2 ? "previousSibling" : "nextSibling"];
            let r2 = n2.getAttribute("listIndent");
            while (o2 && o2.is("listItem") && o2.getAttribute("listIndent") >= i2) {
              if (r2 > o2.getAttribute("listIndent")) {
                r2 = o2.getAttribute("listIndent");
              }
              if (o2.getAttribute("listIndent") == r2) {
                t2[e2 ? "unshift" : "push"](o2);
              }
              o2 = o2[e2 ? "previousSibling" : "nextSibling"];
            }
          }
        }
        function nT(t2, e2) {
          return e2.checkChild(t2.parent, "listItem") && !e2.isObject(t2);
        }
        class oT extends jw {
          constructor(t2, e2) {
            super(t2);
            this._indentBy = e2 == "forward" ? 1 : -1;
          }
          refresh() {
            this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            let i2 = Array.from(e2.selection.getSelectedBlocks());
            t2.change((t3) => {
              const e3 = i2[i2.length - 1];
              let n2 = e3.nextSibling;
              while (n2 && n2.name == "listItem" && n2.getAttribute("listIndent") > e3.getAttribute("listIndent")) {
                i2.push(n2);
                n2 = n2.nextSibling;
              }
              if (this._indentBy < 0) {
                i2 = i2.reverse();
              }
              for (const e4 of i2) {
                const i3 = e4.getAttribute("listIndent") + this._indentBy;
                if (i3 < 0) {
                  t3.rename(e4, "paragraph");
                } else {
                  t3.setAttribute("listIndent", i3, e4);
                }
              }
            });
          }
          _checkEnabled() {
            const t2 = Ww(this.editor.model.document.selection.getSelectedBlocks());
            if (!t2 || !t2.is("listItem")) {
              return false;
            }
            if (this._indentBy > 0) {
              const e2 = t2.getAttribute("listIndent");
              const i2 = t2.getAttribute("listType");
              let n2 = t2.previousSibling;
              while (n2 && n2.is("listItem") && n2.getAttribute("listIndent") >= e2) {
                if (n2.getAttribute("listIndent") == e2) {
                  return n2.getAttribute("listType") == i2;
                }
                n2 = n2.previousSibling;
              }
              return false;
            }
            return true;
          }
        }
        function rT(t2) {
          const e2 = t2.createContainerElement("li");
          e2.getFillerOffset = hT;
          return e2;
        }
        function sT(t2, e2) {
          const i2 = e2.mapper;
          const n2 = e2.writer;
          const o2 = t2.getAttribute("listType") == "numbered" ? "ol" : "ul";
          const r2 = rT(n2);
          const s2 = n2.createContainerElement(o2, null);
          n2.insert(n2.createPositionAt(s2, 0), r2);
          i2.bindElements(t2, r2);
          return r2;
        }
        function aT(t2, e2, i2, n2) {
          const o2 = e2.parent;
          const r2 = i2.mapper;
          const s2 = i2.writer;
          let a2 = r2.toViewPosition(n2.createPositionBefore(t2));
          const c2 = dT(t2.previousSibling, {
            sameIndent: true,
            smallerIndent: true,
            listIndent: t2.getAttribute("listIndent")
          });
          const l2 = t2.previousSibling;
          if (c2 && c2.getAttribute("listIndent") == t2.getAttribute("listIndent")) {
            const t3 = r2.toViewElement(c2);
            a2 = s2.breakContainer(s2.createPositionAfter(t3));
          } else {
            if (l2 && l2.name == "listItem") {
              a2 = r2.toViewPosition(n2.createPositionAt(l2, "end"));
            } else {
              a2 = r2.toViewPosition(n2.createPositionBefore(t2));
            }
          }
          a2 = lT(a2);
          s2.insert(a2, o2);
          if (l2 && l2.name == "listItem") {
            const t3 = r2.toViewElement(l2);
            const i3 = s2.createRange(s2.createPositionAt(t3, 0), a2);
            const n3 = i3.getWalker({ignoreElementEnd: true});
            for (const t4 of n3) {
              if (t4.item.is("li")) {
                const i4 = s2.breakContainer(s2.createPositionBefore(t4.item));
                const o3 = t4.item.parent;
                const r3 = s2.createPositionAt(e2, "end");
                cT(s2, r3.nodeBefore, r3.nodeAfter);
                s2.move(s2.createRangeOn(o3), r3);
                n3.position = i4;
              }
            }
          } else {
            const i3 = o2.nextSibling;
            if (i3 && (i3.is("ul") || i3.is("ol"))) {
              let n3 = null;
              for (const e3 of i3.getChildren()) {
                const i4 = r2.toModelElement(e3);
                if (i4 && i4.getAttribute("listIndent") > t2.getAttribute("listIndent")) {
                  n3 = e3;
                } else {
                  break;
                }
              }
              if (n3) {
                s2.breakContainer(s2.createPositionAfter(n3));
                s2.move(s2.createRangeOn(n3.parent), s2.createPositionAt(e2, "end"));
              }
            }
          }
          cT(s2, o2, o2.nextSibling);
          cT(s2, o2.previousSibling, o2);
        }
        function cT(t2, e2, i2) {
          if (!e2 || !i2 || e2.name != "ul" && e2.name != "ol") {
            return null;
          }
          if (e2.name != i2.name || e2.getAttribute("class") !== i2.getAttribute("class")) {
            return null;
          }
          return t2.mergeContainers(t2.createPositionAfter(e2));
        }
        function lT(t2) {
          return t2.getLastMatchingPosition((t3) => t3.item.is("uiElement"));
        }
        function dT(t2, e2) {
          const i2 = !!e2.sameIndent;
          const n2 = !!e2.smallerIndent;
          const o2 = e2.listIndent;
          let r2 = t2;
          while (r2 && r2.name == "listItem") {
            const t3 = r2.getAttribute("listIndent");
            if (i2 && o2 == t3 || n2 && o2 > t3) {
              return r2;
            }
            r2 = r2.previousSibling;
          }
          return null;
        }
        function uT(t2, e2, i2, n2) {
          t2.ui.componentFactory.add(e2, (o2) => {
            const r2 = t2.commands.get(e2);
            const s2 = new hb(o2);
            s2.set({label: i2, icon: n2, tooltip: true, isToggleable: true});
            s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled");
            s2.on("execute", () => {
              t2.execute(e2);
              t2.editing.view.focus();
            });
            return s2;
          });
        }
        function hT() {
          const t2 = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
          if (this.isEmpty || t2) {
            return 0;
          }
          return Hc.call(this);
        }
        function fT(t2) {
          return (e2, i2, n2) => {
            const o2 = n2.consumable;
            if (!o2.test(i2.item, "insert") || !o2.test(i2.item, "attribute:listType") || !o2.test(i2.item, "attribute:listIndent")) {
              return;
            }
            o2.consume(i2.item, "insert");
            o2.consume(i2.item, "attribute:listType");
            o2.consume(i2.item, "attribute:listIndent");
            const r2 = i2.item;
            const s2 = sT(r2, n2);
            aT(r2, s2, n2, t2);
          };
        }
        function gT(t2) {
          return (e2, i2, n2) => {
            const o2 = n2.mapper.toViewPosition(i2.position).getLastMatchingPosition((t3) => !t3.item.is("li"));
            const r2 = o2.nodeAfter;
            const s2 = n2.writer;
            s2.breakContainer(s2.createPositionBefore(r2));
            s2.breakContainer(s2.createPositionAfter(r2));
            const a2 = r2.parent;
            const c2 = a2.previousSibling;
            const l2 = s2.createRangeOn(a2);
            const d2 = s2.remove(l2);
            if (c2 && c2.nextSibling) {
              cT(s2, c2, c2.nextSibling);
            }
            const u2 = n2.mapper.toModelElement(r2);
            ET(u2.getAttribute("listIndent") + 1, i2.position, l2.start, r2, n2, t2);
            for (const t3 of s2.createRangeIn(d2).getItems()) {
              n2.mapper.unbindViewElement(t3);
            }
            e2.stop();
          };
        }
        function mT(t2, e2, i2) {
          if (!i2.consumable.consume(e2.item, "attribute:listType")) {
            return;
          }
          const n2 = i2.mapper.toViewElement(e2.item);
          const o2 = i2.writer;
          o2.breakContainer(o2.createPositionBefore(n2));
          o2.breakContainer(o2.createPositionAfter(n2));
          const r2 = n2.parent;
          const s2 = e2.attributeNewValue == "numbered" ? "ol" : "ul";
          o2.rename(s2, r2);
        }
        function pT(t2, e2, i2) {
          const n2 = i2.mapper.toViewElement(e2.item);
          const o2 = n2.parent;
          const r2 = i2.writer;
          cT(r2, o2, o2.nextSibling);
          cT(r2, o2.previousSibling, o2);
          for (const t3 of e2.item.getChildren()) {
            i2.consumable.consume(t3, "insert");
          }
        }
        function bT(t2) {
          return (e2, i2, n2) => {
            if (!n2.consumable.consume(i2.item, "attribute:listIndent")) {
              return;
            }
            const o2 = n2.mapper.toViewElement(i2.item);
            const r2 = n2.writer;
            r2.breakContainer(r2.createPositionBefore(o2));
            r2.breakContainer(r2.createPositionAfter(o2));
            const s2 = o2.parent;
            const a2 = s2.previousSibling;
            const c2 = r2.createRangeOn(s2);
            r2.remove(c2);
            if (a2 && a2.nextSibling) {
              cT(r2, a2, a2.nextSibling);
            }
            ET(i2.attributeOldValue + 1, i2.range.start, c2.start, o2, n2, t2);
            aT(i2.item, o2, n2, t2);
            for (const t3 of i2.item.getChildren()) {
              n2.consumable.consume(t3, "insert");
            }
          };
        }
        function wT(t2, e2, i2) {
          if (e2.item.name != "listItem") {
            let t3 = i2.mapper.toViewPosition(e2.range.start);
            const n2 = i2.writer;
            const o2 = [];
            while (t3.parent.name == "ul" || t3.parent.name == "ol") {
              t3 = n2.breakContainer(t3);
              if (t3.parent.name != "li") {
                break;
              }
              const e3 = t3;
              const i3 = n2.createPositionAt(t3.parent, "end");
              if (!e3.isEqual(i3)) {
                const t4 = n2.remove(n2.createRange(e3, i3));
                o2.push(t4);
              }
              t3 = n2.createPositionAfter(t3.parent);
            }
            if (o2.length > 0) {
              for (let e3 = 0; e3 < o2.length; e3++) {
                const i3 = t3.nodeBefore;
                const r2 = n2.insert(t3, o2[e3]);
                t3 = r2.end;
                if (e3 > 0) {
                  const e4 = cT(n2, i3, i3.nextSibling);
                  if (e4 && e4.parent == i3) {
                    t3.offset--;
                  }
                }
              }
              cT(n2, t3.nodeBefore, t3.nodeAfter);
            }
          }
        }
        function kT(t2, e2, i2) {
          const n2 = i2.mapper.toViewPosition(e2.position);
          const o2 = n2.nodeBefore;
          const r2 = n2.nodeAfter;
          cT(i2.writer, o2, r2);
        }
        function _T(t2, e2, i2) {
          if (i2.consumable.consume(e2.viewItem, {name: true})) {
            const t3 = i2.writer;
            const n2 = t3.createElement("listItem");
            const o2 = OT(e2.viewItem);
            t3.setAttribute("listIndent", o2, n2);
            const r2 = e2.viewItem.parent && e2.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
            t3.setAttribute("listType", r2, n2);
            const s2 = i2.splitToAllowedParent(n2, e2.modelCursor);
            if (!s2) {
              return;
            }
            t3.insert(n2, s2.position);
            const a2 = PT(n2, e2.viewItem.getChildren(), i2);
            e2.modelRange = t3.createRange(e2.modelCursor, a2);
            if (s2.cursorParent) {
              e2.modelCursor = t3.createPositionAt(s2.cursorParent, 0);
            } else {
              e2.modelCursor = e2.modelRange.end;
            }
          }
        }
        function vT(t2, e2, i2) {
          if (i2.consumable.test(e2.viewItem, {name: true})) {
            const t3 = Array.from(e2.viewItem.getChildren());
            for (const e3 of t3) {
              const t4 = !(e3.is("li") || RT(e3));
              if (t4) {
                e3._remove();
              }
            }
          }
        }
        function yT(t2, e2, i2) {
          if (i2.consumable.test(e2.viewItem, {name: true})) {
            if (e2.viewItem.childCount === 0) {
              return;
            }
            const t3 = [...e2.viewItem.getChildren()];
            let i3 = false;
            let n2 = true;
            for (const e3 of t3) {
              if (i3 && !RT(e3)) {
                e3._remove();
              }
              if (e3.is("text")) {
                if (n2) {
                  e3._data = e3.data.replace(/^\s+/, "");
                }
                if (!e3.nextSibling || RT(e3.nextSibling)) {
                  e3._data = e3.data.replace(/\s+$/, "");
                }
              } else if (RT(e3)) {
                i3 = true;
              }
              n2 = false;
            }
          }
        }
        function xT(t2) {
          return (e2, i2) => {
            if (i2.isPhantom) {
              return;
            }
            const n2 = i2.modelPosition.nodeBefore;
            if (n2 && n2.is("listItem")) {
              const e3 = i2.mapper.toViewElement(n2);
              const o2 = e3.getAncestors().find(RT);
              const r2 = t2.createPositionAt(e3, 0).getWalker();
              for (const t3 of r2) {
                if (t3.type == "elementStart" && t3.item.is("li")) {
                  i2.viewPosition = t3.previousPosition;
                  break;
                } else if (t3.type == "elementEnd" && t3.item == o2) {
                  i2.viewPosition = t3.nextPosition;
                  break;
                }
              }
            }
          };
        }
        function CT(t2) {
          return (e2, i2) => {
            const n2 = i2.viewPosition;
            const o2 = n2.parent;
            const r2 = i2.mapper;
            if (o2.name == "ul" || o2.name == "ol") {
              if (!n2.isAtEnd) {
                const e3 = r2.toModelElement(n2.nodeAfter);
                i2.modelPosition = t2.createPositionBefore(e3);
              } else {
                const e3 = r2.toModelElement(n2.nodeBefore);
                const o3 = r2.getModelLength(n2.nodeBefore);
                i2.modelPosition = t2.createPositionBefore(e3).getShiftedBy(o3);
              }
              e2.stop();
            } else if (o2.name == "li" && n2.nodeBefore && (n2.nodeBefore.name == "ul" || n2.nodeBefore.name == "ol")) {
              const s2 = r2.toModelElement(o2);
              let a2 = 1;
              let c2 = n2.nodeBefore;
              while (c2 && RT(c2)) {
                a2 += r2.getModelLength(c2);
                c2 = c2.previousSibling;
              }
              i2.modelPosition = t2.createPositionBefore(s2).getShiftedBy(a2);
              e2.stop();
            }
          };
        }
        function AT(t2, e2) {
          const i2 = t2.document.differ.getChanges();
          const n2 = new Map();
          let o2 = false;
          for (const n3 of i2) {
            if (n3.type == "insert" && n3.name == "listItem") {
              r2(n3.position);
            } else if (n3.type == "insert" && n3.name != "listItem") {
              if (n3.name != "$text") {
                const i4 = n3.position.nodeAfter;
                if (i4.hasAttribute("listIndent")) {
                  e2.removeAttribute("listIndent", i4);
                  o2 = true;
                }
                if (i4.hasAttribute("listType")) {
                  e2.removeAttribute("listType", i4);
                  o2 = true;
                }
                for (const e3 of Array.from(t2.createRangeIn(i4)).filter((t3) => t3.item.is("listItem"))) {
                  r2(e3.previousPosition);
                }
              }
              const i3 = n3.position.getShiftedBy(n3.length);
              r2(i3);
            } else if (n3.type == "remove" && n3.name == "listItem") {
              r2(n3.position);
            } else if (n3.type == "attribute" && n3.attributeKey == "listIndent") {
              r2(n3.range.start);
            } else if (n3.type == "attribute" && n3.attributeKey == "listType") {
              r2(n3.range.start);
            }
          }
          for (const t3 of n2.values()) {
            s2(t3);
            a2(t3);
          }
          return o2;
          function r2(t3) {
            const e3 = t3.nodeBefore;
            if (!e3 || !e3.is("listItem")) {
              const e4 = t3.nodeAfter;
              if (e4 && e4.is("listItem")) {
                n2.set(e4, e4);
              }
            } else {
              let i3 = e3;
              if (n2.has(i3)) {
                return;
              }
              while (i3.previousSibling && i3.previousSibling.is("listItem")) {
                i3 = i3.previousSibling;
                if (n2.has(i3)) {
                  return;
                }
              }
              n2.set(t3.nodeBefore, i3);
            }
          }
          function s2(t3) {
            let i3 = 0;
            let n3 = null;
            while (t3 && t3.is("listItem")) {
              const r3 = t3.getAttribute("listIndent");
              if (r3 > i3) {
                let s3;
                if (n3 === null) {
                  n3 = r3 - i3;
                  s3 = i3;
                } else {
                  if (n3 > r3) {
                    n3 = r3;
                  }
                  s3 = r3 - n3;
                }
                e2.setAttribute("listIndent", s3, t3);
                o2 = true;
              } else {
                n3 = null;
                i3 = t3.getAttribute("listIndent") + 1;
              }
              t3 = t3.nextSibling;
            }
          }
          function a2(t3) {
            let i3 = [];
            let n3 = null;
            while (t3 && t3.is("listItem")) {
              const r3 = t3.getAttribute("listIndent");
              if (n3 && n3.getAttribute("listIndent") > r3) {
                i3 = i3.slice(0, r3 + 1);
              }
              if (r3 != 0) {
                if (i3[r3]) {
                  const n4 = i3[r3];
                  if (t3.getAttribute("listType") != n4) {
                    e2.setAttribute("listType", n4, t3);
                    o2 = true;
                  }
                } else {
                  i3[r3] = t3.getAttribute("listType");
                }
              }
              n3 = t3;
              t3 = t3.nextSibling;
            }
          }
        }
        function TT(t2, [e2, i2]) {
          let n2 = e2.is("documentFragment") ? e2.getChild(0) : e2;
          let o2;
          if (!i2) {
            o2 = this.document.selection;
          } else {
            o2 = this.createSelection(i2);
          }
          if (n2 && n2.is("listItem")) {
            const t3 = o2.getFirstPosition();
            let e3 = null;
            if (t3.parent.is("listItem")) {
              e3 = t3.parent;
            } else if (t3.nodeBefore && t3.nodeBefore.is("listItem")) {
              e3 = t3.nodeBefore;
            }
            if (e3) {
              const t4 = e3.getAttribute("listIndent");
              if (t4 > 0) {
                while (n2 && n2.is("listItem")) {
                  n2._setAttribute("listIndent", n2.getAttribute("listIndent") + t4);
                  n2 = n2.nextSibling;
                }
              }
            }
          }
        }
        function PT(t2, e2, i2) {
          const {writer: n2, schema: o2} = i2;
          let r2 = n2.createPositionAfter(t2);
          for (const s2 of e2) {
            if (s2.name == "ul" || s2.name == "ol") {
              r2 = i2.convertItem(s2, r2).modelCursor;
            } else {
              const e3 = i2.convertItem(s2, n2.createPositionAt(t2, "end"));
              const a2 = e3.modelRange.start.nodeAfter;
              const c2 = a2 && a2.is("element") && !o2.checkChild(t2, a2.name);
              if (c2) {
                if (e3.modelCursor.parent.is("listItem")) {
                  t2 = e3.modelCursor.parent;
                } else {
                  t2 = ST(e3.modelCursor);
                }
                r2 = n2.createPositionAfter(t2);
              }
            }
          }
          return r2;
        }
        function ST(t2) {
          const e2 = new Wh({startPosition: t2});
          let i2;
          do {
            i2 = e2.next();
          } while (!i2.value.item.is("listItem"));
          return i2.value.item;
        }
        function ET(t2, e2, i2, n2, o2, r2) {
          const s2 = dT(e2.nodeBefore, {sameIndent: true, smallerIndent: true, listIndent: t2, foo: "b"});
          const a2 = o2.mapper;
          const c2 = o2.writer;
          const l2 = s2 ? s2.getAttribute("listIndent") : null;
          let d2;
          if (!s2) {
            d2 = i2;
          } else if (l2 == t2) {
            const t3 = a2.toViewElement(s2).parent;
            d2 = c2.createPositionAfter(t3);
          } else {
            const t3 = r2.createPositionAt(s2, "end");
            d2 = a2.toViewPosition(t3);
          }
          d2 = lT(d2);
          for (const t3 of [...n2.getChildren()]) {
            if (RT(t3)) {
              d2 = c2.move(c2.createRangeOn(t3), d2).end;
              cT(c2, t3, t3.nextSibling);
              cT(c2, t3.previousSibling, t3);
            }
          }
        }
        function RT(t2) {
          return t2.is("ol") || t2.is("ul");
        }
        function OT(t2) {
          let e2 = 0;
          let i2 = t2.parent;
          while (i2) {
            if (i2.is("li")) {
              e2++;
            } else {
              const t3 = i2.previousSibling;
              if (t3 && t3.is("li")) {
                e2++;
              }
            }
            i2 = i2.parent;
          }
          return e2;
        }
        class IT extends mp {
          static get pluginName() {
            return "ListEditing";
          }
          static get requires() {
            return [V_];
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.register("listItem", {
              inheritAllFrom: "$block",
              allowAttributes: ["listType", "listIndent"]
            });
            const e2 = t2.data;
            const i2 = t2.editing;
            t2.model.document.registerPostFixer((e3) => AT(t2.model, e3));
            i2.mapper.registerViewToModelLength("li", VT);
            e2.mapper.registerViewToModelLength("li", VT);
            i2.mapper.on("modelToViewPosition", xT(i2.view));
            i2.mapper.on("viewToModelPosition", CT(t2.model));
            e2.mapper.on("modelToViewPosition", xT(i2.view));
            t2.conversion.for("editingDowncast").add((e3) => {
              e3.on("insert", wT, {priority: "high"});
              e3.on("insert:listItem", fT(t2.model));
              e3.on("attribute:listType:listItem", mT, {priority: "high"});
              e3.on("attribute:listType:listItem", pT, {priority: "low"});
              e3.on("attribute:listIndent:listItem", bT(t2.model));
              e3.on("remove:listItem", gT(t2.model));
              e3.on("remove", kT, {priority: "low"});
            });
            t2.conversion.for("dataDowncast").add((e3) => {
              e3.on("insert", wT, {priority: "high"});
              e3.on("insert:listItem", fT(t2.model));
            });
            t2.conversion.for("upcast").add((t3) => {
              t3.on("element:ul", vT, {priority: "high"});
              t3.on("element:ol", vT, {priority: "high"});
              t3.on("element:li", yT, {priority: "high"});
              t3.on("element:li", _T);
            });
            t2.model.on("insertContent", TT, {priority: "high"});
            t2.commands.add("numberedList", new eT(t2, "numbered"));
            t2.commands.add("bulletedList", new eT(t2, "bulleted"));
            t2.commands.add("indentList", new oT(t2, "forward"));
            t2.commands.add("outdentList", new oT(t2, "backward"));
            const n2 = i2.view.document;
            this.listenTo(n2, "enter", (t3, e3) => {
              const i3 = this.editor.model.document;
              const n3 = i3.selection.getLastPosition().parent;
              if (i3.selection.isCollapsed && n3.name == "listItem" && n3.isEmpty) {
                this.editor.execute("outdentList");
                e3.preventDefault();
                t3.stop();
              }
            });
            this.listenTo(n2, "delete", (t3, e3) => {
              if (e3.direction !== "backward") {
                return;
              }
              const i3 = this.editor.model.document.selection;
              if (!i3.isCollapsed) {
                return;
              }
              const n3 = i3.getFirstPosition();
              if (!n3.isAtStart) {
                return;
              }
              const o3 = n3.parent;
              if (o3.name !== "listItem") {
                return;
              }
              const r2 = o3.previousSibling && o3.previousSibling.name === "listItem";
              if (r2) {
                return;
              }
              this.editor.execute("outdentList");
              e3.preventDefault();
              t3.stop();
            }, {priority: "high"});
            const o2 = (t3) => (e3, i3) => {
              const n3 = this.editor.commands.get(t3);
              if (n3.isEnabled) {
                this.editor.execute(t3);
                i3();
              }
            };
            t2.keystrokes.set("Tab", o2("indentList"));
            t2.keystrokes.set("Shift+Tab", o2("outdentList"));
          }
          afterInit() {
            const t2 = this.editor.commands;
            const e2 = t2.get("indent");
            const i2 = t2.get("outdent");
            if (e2) {
              e2.registerChildCommand(t2.get("indentList"));
            }
            if (i2) {
              i2.registerChildCommand(t2.get("outdentList"));
            }
          }
        }
        function VT(t2) {
          let e2 = 1;
          for (const i2 of t2.getChildren()) {
            if (i2.name == "ul" || i2.name == "ol") {
              for (const t3 of i2.getChildren()) {
                e2 += VT(t3);
              }
            }
          }
          return e2;
        }
        var NT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
        var MT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
        class BT extends mp {
          init() {
            const t2 = this.editor.t;
            uT(this.editor, "numberedList", t2("lc"), NT);
            uT(this.editor, "bulletedList", t2("ld"), MT);
          }
        }
        class zT extends mp {
          static get requires() {
            return [IT, BT];
          }
          static get pluginName() {
            return "List";
          }
        }
        var LT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>';
        const FT = "removeFormat";
        class DT extends mp {
          static get pluginName() {
            return "RemoveFormatUI";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add(FT, (i2) => {
              const n2 = t2.commands.get(FT);
              const o2 = new hb(i2);
              o2.set({label: e2("la"), icon: LT, tooltip: true});
              o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute(FT);
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class jT extends jw {
          refresh() {
            const t2 = this.editor.model;
            this.isEnabled = !!Ww(this._getFormattingItems(t2.document.selection, t2.schema));
          }
          execute() {
            const t2 = this.editor.model;
            const e2 = t2.schema;
            t2.change((i2) => {
              for (const n2 of this._getFormattingItems(t2.document.selection, e2)) {
                if (n2.is("selection")) {
                  for (const t3 of this._getFormattingAttributes(n2, e2)) {
                    i2.removeSelectionAttribute(t3);
                  }
                } else {
                  const t3 = i2.createRangeOn(n2);
                  for (const o2 of this._getFormattingAttributes(n2, e2)) {
                    i2.removeAttribute(o2, t3);
                  }
                }
              }
            });
          }
          *_getFormattingItems(t2, e2) {
            const i2 = (t3) => !!Ww(this._getFormattingAttributes(t3, e2));
            for (const e3 of t2.getRanges()) {
              for (const t3 of e3.getItems()) {
                if (i2(t3)) {
                  yield t3;
                }
              }
            }
            if (i2(t2)) {
              yield t2;
            }
          }
          *_getFormattingAttributes(t2, e2) {
            for (const [i2] of t2.getAttributes()) {
              const t3 = e2.getAttributeProperties(i2);
              if (t3 && t3.isFormatting) {
                yield i2;
              }
            }
          }
        }
        class HT extends mp {
          static get pluginName() {
            return "RemoveFormatEditing";
          }
          init() {
            const t2 = this.editor;
            t2.commands.add("removeFormat", new jT(t2));
          }
        }
        class WT extends mp {
          static get requires() {
            return [HT, DT];
          }
          static get pluginName() {
            return "RemoveFormat";
          }
        }
        class qT {
          constructor(t2, e2 = 20) {
            this.model = t2;
            this.size = 0;
            this.limit = e2;
            this.isLocked = false;
            this._changeCallback = (t3, e3) => {
              if (e3.type != "transparent" && e3 !== this._batch) {
                this._reset(true);
              }
            };
            this._selectionChangeCallback = () => {
              this._reset();
            };
            this.model.document.on("change", this._changeCallback);
            this.model.document.selection.on("change:range", this._selectionChangeCallback);
            this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
          }
          get batch() {
            if (!this._batch) {
              this._batch = this.model.createBatch();
            }
            return this._batch;
          }
          input(t2) {
            this.size += t2;
            if (this.size >= this.limit) {
              this._reset(true);
            }
          }
          lock() {
            this.isLocked = true;
          }
          unlock() {
            this.isLocked = false;
          }
          destroy() {
            this.model.document.off("change", this._changeCallback);
            this.model.document.selection.off("change:range", this._selectionChangeCallback);
            this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
          }
          _reset(t2) {
            if (!this.isLocked || t2) {
              this._batch = null;
              this.size = 0;
            }
          }
        }
        class UT extends jw {
          constructor(t2, e2) {
            super(t2);
            this._buffer = new qT(t2.model, e2);
            this._batches = new WeakSet();
          }
          get buffer() {
            return this._buffer;
          }
          destroy() {
            super.destroy();
            this._buffer.destroy();
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = e2.document;
            const n2 = t2.text || "";
            const o2 = n2.length;
            const r2 = t2.range ? e2.createSelection(t2.range) : i2.selection;
            const s2 = t2.resultRange;
            e2.enqueueChange(this._buffer.batch, (t3) => {
              this._buffer.lock();
              e2.deleteContent(r2);
              if (n2) {
                e2.insertContent(t3.createText(n2, i2.selection.getAttributes()), r2);
              }
              if (s2) {
                t3.setSelection(s2);
              } else if (!r2.is("documentSelection")) {
                t3.setSelection(r2);
              }
              this._buffer.unlock();
              this._buffer.input(o2);
              this._batches.add(this._buffer.batch);
            });
          }
        }
        function $T(t2) {
          let e2 = null;
          const i2 = t2.model;
          const n2 = t2.editing.view;
          const o2 = t2.commands.get("input");
          if (Al.isAndroid) {
            n2.document.on("beforeinput", (t3, e3) => r2(e3), {priority: "lowest"});
          } else {
            n2.document.on("keydown", (t3, e3) => r2(e3), {priority: "lowest"});
          }
          n2.document.on("compositionstart", s2, {priority: "lowest"});
          n2.document.on("compositionend", () => {
            e2 = i2.createSelection(i2.document.selection);
          }, {priority: "lowest"});
          function r2(t3) {
            const r3 = i2.document;
            const s3 = n2.document.isComposing;
            const c2 = e2 && e2.isEqual(r3.selection);
            e2 = null;
            if (!o2.isEnabled) {
              return;
            }
            if (KT(t3) || r3.selection.isCollapsed) {
              return;
            }
            if (s3 && t3.keyCode === 229) {
              return;
            }
            if (!s3 && t3.keyCode === 229 && c2) {
              return;
            }
            a2();
          }
          function s2() {
            const t3 = i2.document;
            const e3 = t3.selection.rangeCount === 1 ? t3.selection.getFirstRange().isFlat : true;
            if (t3.selection.isCollapsed || e3) {
              return;
            }
            a2();
          }
          function a2() {
            const t3 = o2.buffer;
            t3.lock();
            i2.enqueueChange(t3.batch, () => {
              i2.deleteContent(i2.document.selection);
            });
            t3.unlock();
          }
        }
        const GT = [Ml("arrowUp"), Ml("arrowRight"), Ml("arrowDown"), Ml("arrowLeft"), 9, 16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 45, 91, 93, 144, 145, 173, 174, 175, 176, 177, 178, 179, 255];
        for (let t2 = 112; t2 <= 135; t2++) {
          GT.push(t2);
        }
        function KT(t2) {
          if (t2.ctrlKey) {
            return true;
          }
          return GT.includes(t2.keyCode);
        }
        function JT(t2, e2) {
          const i2 = [];
          let n2 = 0;
          let o2;
          t2.forEach((t3) => {
            if (t3 == "equal") {
              r2();
              n2++;
            } else if (t3 == "insert") {
              if (s2("insert")) {
                o2.values.push(e2[n2]);
              } else {
                r2();
                o2 = {type: "insert", index: n2, values: [e2[n2]]};
              }
              n2++;
            } else {
              if (s2("delete")) {
                o2.howMany++;
              } else {
                r2();
                o2 = {type: "delete", index: n2, howMany: 1};
              }
            }
          });
          r2();
          return i2;
          function r2() {
            if (o2) {
              i2.push(o2);
              o2 = null;
            }
          }
          function s2(t3) {
            return o2 && o2.type == t3;
          }
        }
        function YT(t2) {
          if (t2.length == 0) {
            return false;
          }
          for (const e2 of t2) {
            if (e2.type === "children" && !QT(e2)) {
              return true;
            }
          }
          return false;
        }
        function QT(t2) {
          if (t2.newChildren.length - t2.oldChildren.length != 1) {
            return;
          }
          const e2 = _d(t2.oldChildren, t2.newChildren, XT);
          const i2 = JT(e2, t2.newChildren);
          if (i2.length > 1) {
            return;
          }
          const n2 = i2[0];
          if (!(!!n2.values[0] && n2.values[0].is("text"))) {
            return;
          }
          return n2;
        }
        function XT(t2, e2) {
          if (!!t2 && t2.is("text") && !!e2 && e2.is("text")) {
            return t2.data === e2.data;
          } else {
            return t2 === e2;
          }
        }
        function ZT(t2) {
          t2.editing.view.document.on("mutations", (e2, i2, n2) => {
            new tP(t2).handle(i2, n2);
          });
        }
        class tP {
          constructor(t2) {
            this.editor = t2;
            this.editing = this.editor.editing;
          }
          handle(t2, e2) {
            if (YT(t2)) {
              this._handleContainerChildrenMutations(t2, e2);
            } else {
              for (const i2 of t2) {
                this._handleTextMutation(i2, e2);
                this._handleTextNodeInsertion(i2);
              }
            }
          }
          _handleContainerChildrenMutations(t2, e2) {
            const i2 = eP(t2);
            if (!i2) {
              return;
            }
            const n2 = this.editor.editing.view.domConverter;
            const o2 = n2.mapViewToDom(i2);
            const r2 = new zd(this.editor.editing.view.document);
            const s2 = this.editor.data.toModel(r2.domToView(o2)).getChild(0);
            const a2 = this.editor.editing.mapper.toModelElement(i2);
            if (!a2) {
              return;
            }
            const c2 = Array.from(s2.getChildren());
            const l2 = Array.from(a2.getChildren());
            const d2 = c2[c2.length - 1];
            const u2 = l2[l2.length - 1];
            if (d2 && d2.is("softBreak") && u2 && !u2.is("softBreak")) {
              c2.pop();
            }
            const h2 = this.editor.model.schema;
            if (!iP(c2, h2) || !iP(l2, h2)) {
              return;
            }
            const f2 = c2.map((t3) => t3.is("text") ? t3.data : "@").join("").replace(/\u00A0/g, " ");
            const g2 = l2.map((t3) => t3.is("text") ? t3.data : "@").join("").replace(/\u00A0/g, " ");
            if (g2 === f2) {
              return;
            }
            const m2 = _d(g2, f2);
            const {firstChangeAt: p2, insertions: b2, deletions: w2} = nP(m2);
            let k2 = null;
            if (e2) {
              k2 = this.editing.mapper.toModelRange(e2.getFirstRange());
            }
            const _2 = f2.substr(p2, b2);
            const v2 = this.editor.model.createRange(this.editor.model.createPositionAt(a2, p2), this.editor.model.createPositionAt(a2, p2 + w2));
            this.editor.execute("input", {text: _2, range: v2, resultRange: k2});
          }
          _handleTextMutation(t2, e2) {
            if (t2.type != "text") {
              return;
            }
            const i2 = t2.newText.replace(/\u00A0/g, " ");
            const n2 = t2.oldText.replace(/\u00A0/g, " ");
            if (n2 === i2) {
              return;
            }
            const o2 = _d(n2, i2);
            const {firstChangeAt: r2, insertions: s2, deletions: a2} = nP(o2);
            let c2 = null;
            if (e2) {
              c2 = this.editing.mapper.toModelRange(e2.getFirstRange());
            }
            const l2 = this.editing.view.createPositionAt(t2.node, r2);
            const d2 = this.editing.mapper.toModelPosition(l2);
            const u2 = this.editor.model.createRange(d2, d2.getShiftedBy(a2));
            const h2 = i2.substr(r2, s2);
            this.editor.execute("input", {text: h2, range: u2, resultRange: c2});
          }
          _handleTextNodeInsertion(t2) {
            if (t2.type != "children") {
              return;
            }
            const e2 = QT(t2);
            const i2 = this.editing.view.createPositionAt(t2.node, e2.index);
            const n2 = this.editing.mapper.toModelPosition(i2);
            const o2 = e2.values[0].data;
            this.editor.execute("input", {text: o2.replace(/\u00A0/g, " "), range: this.editor.model.createRange(n2)});
          }
        }
        function eP(t2) {
          const e2 = t2.map((t3) => t3.node).reduce((t3, e3) => t3.getCommonAncestor(e3, {includeSelf: true}));
          if (!e2) {
            return;
          }
          return e2.getAncestors({
            includeSelf: true,
            parentFirst: true
          }).find((t3) => t3.is("containerElement") || t3.is("rootElement"));
        }
        function iP(t2, e2) {
          return t2.every((t3) => e2.isInline(t3));
        }
        function nP(t2) {
          let e2 = null;
          let i2 = null;
          for (let n3 = 0; n3 < t2.length; n3++) {
            const o3 = t2[n3];
            if (o3 != "equal") {
              e2 = e2 === null ? n3 : e2;
              i2 = n3;
            }
          }
          let n2 = 0;
          let o2 = 0;
          for (let r2 = e2; r2 <= i2; r2++) {
            if (t2[r2] != "insert") {
              n2++;
            }
            if (t2[r2] != "delete") {
              o2++;
            }
          }
          return {insertions: o2, deletions: n2, firstChangeAt: e2};
        }
        class oP extends mp {
          static get pluginName() {
            return "Input";
          }
          init() {
            const t2 = this.editor;
            const e2 = new UT(t2, t2.config.get("typing.undoStep") || 20);
            t2.commands.add("input", e2);
            $T(t2);
            ZT(t2);
          }
          isInput(t2) {
            const e2 = this.editor.commands.get("input");
            return e2._batches.has(t2);
          }
        }
        class rP extends jw {
          constructor(t2, e2) {
            super(t2);
            this.direction = e2;
            this._buffer = new qT(t2.model, t2.config.get("typing.undoStep"));
          }
          get buffer() {
            return this._buffer;
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = e2.document;
            e2.enqueueChange(this._buffer.batch, (n2) => {
              this._buffer.lock();
              const o2 = n2.createSelection(t2.selection || i2.selection);
              const r2 = o2.isCollapsed;
              if (o2.isCollapsed) {
                e2.modifySelection(o2, {direction: this.direction, unit: t2.unit});
              }
              if (this._shouldEntireContentBeReplacedWithParagraph(t2.sequence || 1)) {
                this._replaceEntireContentWithParagraph(n2);
                return;
              }
              if (o2.isCollapsed) {
                return;
              }
              let s2 = 0;
              o2.getFirstRange().getMinimalFlatRanges().forEach((t3) => {
                s2 += fl(t3.getWalker({singleCharacters: true, ignoreElementEnd: true, shallow: true}));
              });
              e2.deleteContent(o2, {doNotResetEntireContent: r2, direction: this.direction});
              this._buffer.input(s2);
              n2.setSelection(o2);
              this._buffer.unlock();
            });
          }
          _shouldEntireContentBeReplacedWithParagraph(t2) {
            if (t2 > 1) {
              return false;
            }
            const e2 = this.editor.model;
            const i2 = e2.document;
            const n2 = i2.selection;
            const o2 = e2.schema.getLimitElement(n2);
            const r2 = n2.isCollapsed && n2.containsEntireContent(o2);
            if (!r2) {
              return false;
            }
            if (!e2.schema.checkChild(o2, "paragraph")) {
              return false;
            }
            const s2 = o2.getChild(0);
            if (s2 && s2.name === "paragraph") {
              return false;
            }
            return true;
          }
          _replaceEntireContentWithParagraph(t2) {
            const e2 = this.editor.model;
            const i2 = e2.document;
            const n2 = i2.selection;
            const o2 = e2.schema.getLimitElement(n2);
            const r2 = t2.createElement("paragraph");
            t2.remove(t2.createRangeIn(o2));
            t2.insert(r2, o2);
            t2.setSelection(r2, 0);
          }
        }
        class sP extends Gd {
          constructor(t2) {
            super(t2);
            const e2 = t2.document;
            let i2 = 0;
            e2.on("keyup", (t3, e3) => {
              if (e3.keyCode == Nl.delete || e3.keyCode == Nl.backspace) {
                i2 = 0;
              }
            });
            e2.on("keydown", (t3, e3) => {
              const o2 = {};
              if (e3.keyCode == Nl.delete) {
                o2.direction = "forward";
                o2.unit = "character";
              } else if (e3.keyCode == Nl.backspace) {
                o2.direction = "backward";
                o2.unit = "codePoint";
              } else {
                return;
              }
              const r2 = Al.isMac ? e3.altKey : e3.ctrlKey;
              o2.unit = r2 ? "word" : o2.unit;
              o2.sequence = ++i2;
              n2(t3, e3.domEvent, o2);
            });
            if (Al.isAndroid) {
              e2.on("beforeinput", (e3, i3) => {
                if (i3.domEvent.inputType != "deleteContentBackward") {
                  return;
                }
                const o2 = {unit: "codepoint", direction: "backward", sequence: 1};
                const r2 = i3.domTarget.ownerDocument.defaultView.getSelection();
                if (r2.anchorNode == r2.focusNode && r2.anchorOffset + 1 != r2.focusOffset) {
                  o2.selectionToRemove = t2.domConverter.domSelectionToView(r2);
                }
                n2(e3, i3.domEvent, o2);
              });
            }
            function n2(t3, i3, n3) {
              let o2;
              e2.once("delete", (t4) => o2 = t4, {priority: Number.POSITIVE_INFINITY});
              e2.fire("delete", new Ku(e2, i3, n3));
              if (o2 && o2.stop.called) {
                t3.stop();
              }
            }
          }
          observe() {
          }
        }
        class aP extends mp {
          static get pluginName() {
            return "Delete";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.editing.view;
            const i2 = e2.document;
            e2.addObserver(sP);
            t2.commands.add("forwardDelete", new rP(t2, "forward"));
            t2.commands.add("delete", new rP(t2, "backward"));
            this.listenTo(i2, "delete", (i3, n2) => {
              const o2 = {unit: n2.unit, sequence: n2.sequence};
              if (n2.selectionToRemove) {
                const e3 = t2.model.createSelection();
                const i4 = [];
                for (const e4 of n2.selectionToRemove.getRanges()) {
                  i4.push(t2.editing.mapper.toModelRange(e4));
                }
                e3.setTo(i4);
                o2.selection = e3;
              }
              t2.execute(n2.direction == "forward" ? "forwardDelete" : "delete", o2);
              n2.preventDefault();
              e2.scrollToTheSelection();
            });
            if (Al.isAndroid) {
              let t3 = null;
              this.listenTo(i2, "delete", (e3, i3) => {
                const n2 = i3.domTarget.ownerDocument.defaultView.getSelection();
                t3 = {
                  anchorNode: n2.anchorNode,
                  anchorOffset: n2.anchorOffset,
                  focusNode: n2.focusNode,
                  focusOffset: n2.focusOffset
                };
              }, {priority: "lowest"});
              this.listenTo(i2, "keyup", (e3, i3) => {
                if (t3) {
                  const e4 = i3.domTarget.ownerDocument.defaultView.getSelection();
                  e4.collapse(t3.anchorNode, t3.anchorOffset);
                  e4.extend(t3.focusNode, t3.focusOffset);
                  t3 = null;
                }
              });
            }
          }
        }
        class cP extends mp {
          static get requires() {
            return [oP, aP];
          }
          static get pluginName() {
            return "Typing";
          }
        }
        class lP extends Gp {
          constructor(t2, e2) {
            super(t2);
            const i2 = t2.t;
            this.labelView = new Mk(t2);
            this.labelView.text = i2("b");
            this.groupDropdownView = this._createGroupDropdown(e2);
            this.groupDropdownView.panelPosition = t2.uiLanguageDirection === "rtl" ? "se" : "sw";
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck", "ck-special-characters-navigation"]},
              children: [this.labelView, this.groupDropdownView]
            });
          }
          get currentGroupName() {
            return this.groupDropdownView.value;
          }
          _createGroupDropdown(t2) {
            const e2 = this.locale;
            const i2 = e2.t;
            const n2 = Wb(e2);
            const o2 = this._getCharacterGroupListItemDefinitions(n2, t2);
            n2.set("value", o2.first.model.label);
            n2.buttonView.bind("label").to(n2, "value");
            n2.buttonView.set({isOn: false, withText: true, tooltip: i2("le")});
            n2.on("execute", (t3) => {
              n2.value = t3.source.label;
            });
            n2.delegate("execute").to(this);
            Ub(n2, o2);
            return n2;
          }
          _getCharacterGroupListItemDefinitions(t2, e2) {
            const i2 = new ys();
            for (const n2 of e2) {
              const e3 = {type: "button", model: new e_({label: n2, withText: true})};
              e3.model.bind("isOn").to(t2, "value", (t3) => t3 === e3.model.label);
              i2.add(e3);
            }
            return i2;
          }
        }
        var dP = i(86);
        class uP extends Gp {
          constructor(t2) {
            super(t2);
            this.tiles = this.createCollection();
            this.setTemplate({
              tag: "div",
              children: [{
                tag: "div",
                attributes: {class: ["ck", "ck-character-grid__tiles"]},
                children: this.tiles
              }],
              attributes: {class: ["ck", "ck-character-grid"]}
            });
          }
          createTile(t2, e2) {
            const i2 = new hb(this.locale);
            i2.set({label: t2, withText: true, class: "ck-character-grid__tile"});
            i2.extendTemplate({attributes: {title: e2}, on: {mouseover: i2.bindTemplate.to("mouseover")}});
            i2.on("mouseover", () => {
              this.fire("tileHover", {name: e2, character: t2});
            });
            i2.on("execute", () => {
              this.fire("execute", {name: e2, character: t2});
            });
            return i2;
          }
        }
        var hP = i(88);
        class fP extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("character", null);
            this.set("name", null);
            this.bind("code").to(this, "character", gP);
            this.setTemplate({
              tag: "div",
              children: [{
                tag: "span",
                attributes: {class: ["ck-character-info__name"]},
                children: [{text: e2.to("name", (t3) => t3 ? t3 : "\u200B")}]
              }, {
                tag: "span",
                attributes: {class: ["ck-character-info__code"]},
                children: [{text: e2.to("code")}]
              }],
              attributes: {class: ["ck", "ck-character-info"]}
            });
          }
        }
        function gP(t2) {
          if (t2 === null) {
            return "";
          }
          const e2 = t2.codePointAt(0).toString(16);
          return "U+" + ("0000" + e2).slice(-4);
        }
        var mP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>';
        var pP = i(90);
        const bP = "\u0412\u0441\u0435";
        class wP extends mp {
          static get requires() {
            return [cP];
          }
          static get pluginName() {
            return "SpecialCharacters";
          }
          constructor(t2) {
            super(t2);
            this._characters = new Map();
            this._groups = new Map();
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            const i2 = t2.commands.get("input");
            t2.ui.componentFactory.add("specialCharacters", (n2) => {
              const o2 = Wb(n2);
              let r2;
              o2.buttonView.set({label: e2("b"), icon: mP, tooltip: true});
              o2.bind("isEnabled").to(i2);
              o2.on("execute", (e3, i3) => {
                t2.execute("input", {text: i3.character});
                t2.editing.view.focus();
              });
              o2.on("change:isOpen", () => {
                if (!r2) {
                  r2 = this._createDropdownPanelContent(n2, o2);
                  o2.panelView.children.add(r2.navigationView);
                  o2.panelView.children.add(r2.gridView);
                  o2.panelView.children.add(r2.infoView);
                }
                r2.infoView.set({character: null, name: null});
              });
              return o2;
            });
          }
          addItems(t2, e2) {
            if (t2 === bP) {
              throw new ss["b"](`special-character-invalid-group-name: The name "${bP}" is reserved and cannot be used.`);
            }
            const i2 = this._getGroup(t2);
            for (const t3 of e2) {
              i2.add(t3.title);
              this._characters.set(t3.title, t3.character);
            }
          }
          getGroups() {
            return this._groups.keys();
          }
          getCharactersForGroup(t2) {
            if (t2 === bP) {
              return new Set(this._characters.keys());
            }
            return this._groups.get(t2);
          }
          getCharacter(t2) {
            return this._characters.get(t2);
          }
          _getGroup(t2) {
            if (!this._groups.has(t2)) {
              this._groups.set(t2, new Set());
            }
            return this._groups.get(t2);
          }
          _updateGrid(t2, e2) {
            e2.tiles.clear();
            const i2 = this.getCharactersForGroup(t2);
            for (const t3 of i2) {
              const i3 = this.getCharacter(t3);
              e2.tiles.add(e2.createTile(i3, t3));
            }
          }
          _createDropdownPanelContent(t2, e2) {
            const i2 = [...this.getGroups()];
            i2.unshift(bP);
            const n2 = new lP(t2, i2);
            const o2 = new uP(t2);
            const r2 = new fP(t2);
            o2.delegate("execute").to(e2);
            o2.on("tileHover", (t3, e3) => {
              r2.set(e3);
            });
            n2.on("execute", () => {
              this._updateGrid(n2.currentGroupName, o2);
            });
            this._updateGrid(n2.currentGroupName, o2);
            return {navigationView: n2, gridView: o2, infoView: r2};
          }
        }
        class kP extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.plugins.get("SpecialCharacters").addItems("\u0412\u0430\u043B\u044E\u0442\u0430", [{character: "$", title: e2("u")}, {
              character: "\u20AC",
              title: e2("v")
            }, {character: "\xA5", title: e2("w")}, {character: "\xA3", title: e2("x")}, {
              character: "\xA2",
              title: e2("y")
            }, {character: "\u20A0", title: e2("z")}, {character: "\u20A1", title: e2("aa")}, {
              character: "\u20A2",
              title: e2("ab")
            }, {character: "\u20A3", title: e2("ac")}, {character: "\u20A4", title: e2("ad")}, {
              character: "\xA4",
              title: e2("ae")
            }, {character: "\u20BF", title: e2("af")}, {character: "\u20A5", title: e2("ag")}, {
              character: "\u20A6",
              title: e2("ah")
            }, {character: "\u20A7", title: e2("ai")}, {character: "\u20A8", title: e2("aj")}, {
              character: "\u20A9",
              title: e2("ak")
            }, {character: "\u20AA", title: e2("al")}, {character: "\u20AB", title: e2("am")}, {
              character: "\u20AD",
              title: e2("an")
            }, {character: "\u20AE", title: e2("ao")}, {character: "\u20AF", title: e2("ap")}, {
              character: "\u20B0",
              title: e2("aq")
            }, {character: "\u20B1", title: e2("ar")}, {character: "\u20B2", title: e2("as")}, {
              character: "\u20B3",
              title: e2("at")
            }, {character: "\u20B4", title: e2("au")}, {character: "\u20B5", title: e2("av")}, {
              character: "\u20B6",
              title: e2("aw")
            }, {character: "\u20B7", title: e2("ax")}, {character: "\u20B8", title: e2("ay")}, {
              character: "\u20B9",
              title: e2("az")
            }, {character: "\u20BA", title: e2("ba")}, {character: "\u20BB", title: e2("bb")}, {
              character: "\u20BC",
              title: e2("bc")
            }, {character: "\u20BD", title: e2("bd")}]);
          }
        }
        class _P extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.plugins.get("SpecialCharacters").addItems("\u041C\u0430\u0442\u0435\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438\u0435", [{
              character: "<",
              title: e2("gc")
            }, {character: ">", title: e2("gd")}, {character: "\u2264", title: e2("ge")}, {
              character: "\u2265",
              title: e2("gf")
            }, {character: "\u2013", title: e2("gg")}, {character: "\u2014", title: e2("gh")}, {
              character: "\xAF",
              title: e2("gi")
            }, {character: "\u203E", title: e2("gj")}, {character: "\xB0", title: e2("gk")}, {
              character: "\u2212",
              title: e2("gl")
            }, {character: "\xB1", title: e2("gm")}, {character: "\xF7", title: e2("gn")}, {
              character: "\u2044",
              title: e2("go")
            }, {character: "\xD7", title: e2("gp")}, {character: "\u0192", title: e2("gq")}, {
              character: "\u222B",
              title: e2("gr")
            }, {character: "\u2211", title: e2("gs")}, {character: "\u221E", title: e2("gt")}, {
              character: "\u221A",
              title: e2("gu")
            }, {character: "\u223C", title: e2("gv")}, {character: "\u2245", title: e2("gw")}, {
              character: "\u2248",
              title: e2("gx")
            }, {character: "\u2260", title: e2("gy")}, {character: "\u2261", title: e2("gz")}, {
              character: "\u2208",
              title: e2("ha")
            }, {character: "\u2209", title: e2("hb")}, {character: "\u220B", title: e2("hc")}, {
              character: "\u220F",
              title: e2("hd")
            }, {character: "\u2227", title: e2("he")}, {character: "\u2228", title: e2("hf")}, {
              character: "\xAC",
              title: e2("hg")
            }, {character: "\u2229", title: e2("hh")}, {character: "\u222A", title: e2("hi")}, {
              character: "\u2202",
              title: e2("hj")
            }, {character: "\u2200", title: e2("hk")}, {character: "\u2203", title: e2("hl")}, {
              character: "\u2205",
              title: e2("hm")
            }, {character: "\u2207", title: e2("hn")}, {character: "\u2217", title: e2("ho")}, {
              character: "\u221D",
              title: e2("hp")
            }, {character: "\u2220", title: e2("hq")}, {character: "\xBC", title: e2("hr")}, {
              character: "\xBD",
              title: e2("hs")
            }, {character: "\xBE", title: e2("ht")}]);
          }
        }
        class vP extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.plugins.get("SpecialCharacters").addItems("\u0421\u0442\u0440\u0435\u043B\u043A\u0438", [{title: e2("c"), character: "\u21D0"}, {
              title: e2("d"),
              character: "\u21D2"
            }, {title: e2("e"), character: "\u21D1"}, {title: e2("f"), character: "\u21D3"}, {
              title: e2("g"),
              character: "\u21E0"
            }, {title: e2("h"), character: "\u21E2"}, {title: e2("i"), character: "\u21E1"}, {
              title: e2("j"),
              character: "\u21E3"
            }, {title: e2("k"), character: "\u21E4"}, {title: e2("l"), character: "\u21E5"}, {
              title: e2("m"),
              character: "\u2912"
            }, {title: e2("n"), character: "\u2913"}, {title: e2("o"), character: "\u21A8"}, {
              title: e2("p"),
              character: "\u{1F519}"
            }, {title: e2("q"), character: "\u{1F51A}"}, {title: e2("r"), character: "\u{1F51B}"}, {
              title: e2("s"),
              character: "\u{1F51C}"
            }, {title: e2("t"), character: "\u{1F51D}"}]);
          }
        }
        class yP extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.plugins.get("SpecialCharacters").addItems("\u041B\u0430\u0442\u0438\u043D\u0441\u043A\u0438\u0435 \u0441\u0438\u043C\u0432\u043E\u043B\u044B", [{
              character: "\u0100",
              title: e2("be")
            }, {character: "\u0101", title: e2("bf")}, {character: "\u0102", title: e2("bg")}, {
              character: "\u0103",
              title: e2("bh")
            }, {character: "\u0104", title: e2("bi")}, {character: "\u0105", title: e2("bj")}, {
              character: "\u0106",
              title: e2("bk")
            }, {character: "\u0107", title: e2("bl")}, {character: "\u0108", title: e2("bm")}, {
              character: "\u0109",
              title: e2("bn")
            }, {character: "\u010A", title: e2("bo")}, {character: "\u010B", title: e2("bp")}, {
              character: "\u010C",
              title: e2("bq")
            }, {character: "\u010D", title: e2("br")}, {character: "\u010E", title: e2("bs")}, {
              character: "\u010F",
              title: e2("bt")
            }, {character: "\u0110", title: e2("bu")}, {character: "\u0111", title: e2("bv")}, {
              character: "\u0112",
              title: e2("bw")
            }, {character: "\u0113", title: e2("bx")}, {character: "\u0114", title: e2("by")}, {
              character: "\u0115",
              title: e2("bz")
            }, {character: "\u0116", title: e2("ca")}, {character: "\u0117", title: e2("cb")}, {
              character: "\u0118",
              title: e2("cc")
            }, {character: "\u0119", title: e2("cd")}, {character: "\u011A", title: e2("ce")}, {
              character: "\u011B",
              title: e2("cf")
            }, {character: "\u011C", title: e2("cg")}, {character: "\u011D", title: e2("ch")}, {
              character: "\u011E",
              title: e2("ci")
            }, {character: "\u011F", title: e2("cj")}, {character: "\u0120", title: e2("ck")}, {
              character: "\u0121",
              title: e2("cl")
            }, {character: "\u0122", title: e2("cm")}, {character: "\u0123", title: e2("cn")}, {
              character: "\u0124",
              title: e2("co")
            }, {character: "\u0125", title: e2("cp")}, {character: "\u0126", title: e2("cq")}, {
              character: "\u0127",
              title: e2("cr")
            }, {character: "\u0128", title: e2("cs")}, {character: "\u0129", title: e2("ct")}, {
              character: "\u012A",
              title: e2("cu")
            }, {character: "\u012B", title: e2("cv")}, {character: "\u012C", title: e2("cw")}, {
              character: "\u012D",
              title: e2("cx")
            }, {character: "\u012E", title: e2("cy")}, {character: "\u012F", title: e2("cz")}, {
              character: "\u0130",
              title: e2("da")
            }, {character: "\u0131", title: e2("db")}, {character: "\u0132", title: e2("dc")}, {
              character: "\u0133",
              title: e2("dd")
            }, {character: "\u0134", title: e2("de")}, {character: "\u0135", title: e2("df")}, {
              character: "\u0136",
              title: e2("dg")
            }, {character: "\u0137", title: e2("dh")}, {character: "\u0138", title: e2("di")}, {
              character: "\u0139",
              title: e2("dj")
            }, {character: "\u013A", title: e2("dk")}, {character: "\u013B", title: e2("dl")}, {
              character: "\u013C",
              title: e2("dm")
            }, {character: "\u013D", title: e2("dn")}, {character: "\u013E", title: e2("do")}, {
              character: "\u013F",
              title: e2("dp")
            }, {character: "\u0140", title: e2("dq")}, {character: "\u0141", title: e2("dr")}, {
              character: "\u0142",
              title: e2("ds")
            }, {character: "\u0143", title: e2("dt")}, {character: "\u0144", title: e2("du")}, {
              character: "\u0145",
              title: e2("dv")
            }, {character: "\u0146", title: e2("dw")}, {character: "\u0147", title: e2("dx")}, {
              character: "\u0148",
              title: e2("dy")
            }, {character: "\u0149", title: e2("dz")}, {character: "\u014A", title: e2("ea")}, {
              character: "\u014B",
              title: e2("eb")
            }, {character: "\u014C", title: e2("ec")}, {character: "\u014D", title: e2("ed")}, {
              character: "\u014E",
              title: e2("ee")
            }, {character: "\u014F", title: e2("ef")}, {character: "\u0150", title: e2("eg")}, {
              character: "\u0151",
              title: e2("eh")
            }, {character: "\u0152", title: e2("ei")}, {character: "\u0153", title: e2("ej")}, {
              character: "\u0154",
              title: e2("ek")
            }, {character: "\u0155", title: e2("el")}, {character: "\u0156", title: e2("em")}, {
              character: "\u0157",
              title: e2("en")
            }, {character: "\u0158", title: e2("eo")}, {character: "\u0159", title: e2("ep")}, {
              character: "\u015A",
              title: e2("eq")
            }, {character: "\u015B", title: e2("er")}, {character: "\u015C", title: e2("es")}, {
              character: "\u015D",
              title: e2("et")
            }, {character: "\u015E", title: e2("eu")}, {character: "\u015F", title: e2("ev")}, {
              character: "\u0160",
              title: e2("ew")
            }, {character: "\u0161", title: e2("ex")}, {character: "\u0162", title: e2("ey")}, {
              character: "\u0163",
              title: e2("ez")
            }, {character: "\u0164", title: e2("fa")}, {character: "\u0165", title: e2("fb")}, {
              character: "\u0166",
              title: e2("fc")
            }, {character: "\u0167", title: e2("fd")}, {character: "\u0168", title: e2("fe")}, {
              character: "\u0169",
              title: e2("ff")
            }, {character: "\u016A", title: e2("fg")}, {character: "\u016B", title: e2("fh")}, {
              character: "\u016C",
              title: e2("fi")
            }, {character: "\u016D", title: e2("fj")}, {character: "\u016E", title: e2("fk")}, {
              character: "\u016F",
              title: e2("fl")
            }, {character: "\u0170", title: e2("fm")}, {character: "\u0171", title: e2("fn")}, {
              character: "\u0172",
              title: e2("fo")
            }, {character: "\u0173", title: e2("fp")}, {character: "\u0174", title: e2("fq")}, {
              character: "\u0175",
              title: e2("fr")
            }, {character: "\u0176", title: e2("fs")}, {character: "\u0177", title: e2("ft")}, {
              character: "\u0178",
              title: e2("fu")
            }, {character: "\u0179", title: e2("fv")}, {character: "\u017A", title: e2("fw")}, {
              character: "\u017B",
              title: e2("fx")
            }, {character: "\u017C", title: e2("fy")}, {character: "\u017D", title: e2("fz")}, {
              character: "\u017E",
              title: e2("ga")
            }, {character: "\u017F", title: e2("gb")}]);
          }
        }
        class xP extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.plugins.get("SpecialCharacters").addItems("\u0422\u0435\u043A\u0441\u0442\u043E\u0432\u044B\u0435 \u0441\u0438\u043C\u0432\u043E\u043B\u044B", [{
              character: "\u2039",
              title: e2("hu")
            }, {character: "\u203A", title: e2("hv")}, {character: "\xAB", title: e2("hw")}, {
              character: "\xBB",
              title: e2("hx")
            }, {character: "\u2018", title: e2("hy")}, {character: "\u2019", title: e2("hz")}, {
              character: "\u201C",
              title: e2("ia")
            }, {character: "\u201D", title: e2("ib")}, {character: "\u201A", title: e2("ic")}, {
              character: "\u201E",
              title: e2("id")
            }, {character: "\xA1", title: e2("ie")}, {character: "\xBF", title: e2("if")}, {
              character: "\u2025",
              title: e2("ig")
            }, {character: "\u2026", title: e2("ih")}, {character: "\u2021", title: e2("ii")}, {
              character: "\u2030",
              title: e2("ij")
            }, {character: "\u2031", title: e2("ik")}, {character: "\u203C", title: e2("il")}, {
              character: "\u2048",
              title: e2("im")
            }, {character: "\u2049", title: e2("in")}, {character: "\u2047", title: e2("io")}, {
              character: "\xA9",
              title: e2("ip")
            }, {character: "\xAE", title: e2("iq")}, {character: "\u2122", title: e2("ir")}, {
              character: "\xA7",
              title: e2("is")
            }, {character: "\xB6", title: e2("it")}, {character: "\u204B", title: e2("iu")}]);
          }
        }
        class CP extends mp {
          static get requires() {
            return [kP, xP, _P, vP, yP];
          }
        }
        const AP = "strikethrough";
        class TP extends mp {
          static get pluginName() {
            return "StrikethroughEditing";
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", {allowAttributes: AP});
            t2.model.schema.setAttributeProperties(AP, {isFormatting: true, copyOnEnter: true});
            t2.conversion.attributeToElement({
              model: AP,
              view: "s",
              upcastAlso: ["del", "strike", {styles: {"text-decoration": "line-through"}}]
            });
            t2.commands.add(AP, new yk(t2, AP));
            t2.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
          }
        }
        var PP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9L6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
        const SP = "strikethrough";
        class EP extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add(SP, (i2) => {
              const n2 = t2.commands.get(SP);
              const o2 = new hb(i2);
              o2.set({label: e2("jk"), icon: PP, keystroke: "CTRL+SHIFT+X", tooltip: true, isToggleable: true});
              o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute(SP);
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class RP extends mp {
          static get requires() {
            return [TP, EP];
          }
          static get pluginName() {
            return "Strikethrough";
          }
        }
        const OP = "subscript";
        class IP extends mp {
          static get pluginName() {
            return "SubscriptEditing";
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", {allowAttributes: OP});
            t2.model.schema.setAttributeProperties(OP, {isFormatting: true, copyOnEnter: true});
            t2.conversion.attributeToElement({
              model: OP,
              view: "sub",
              upcastAlso: [{styles: {"vertical-align": "sub"}}]
            });
            t2.commands.add(OP, new yk(t2, OP));
          }
        }
        var VP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
        const NP = "subscript";
        class MP extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add(NP, (i2) => {
              const n2 = t2.commands.get(NP);
              const o2 = new hb(i2);
              o2.set({label: e2("jl"), icon: VP, tooltip: true, isToggleable: true});
              o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute(NP);
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class BP extends mp {
          static get requires() {
            return [IP, MP];
          }
          static get pluginName() {
            return "Subscript";
          }
        }
        const zP = "superscript";
        class LP extends mp {
          static get pluginName() {
            return "SuperscriptEditing";
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", {allowAttributes: zP});
            t2.model.schema.setAttributeProperties(zP, {isFormatting: true, copyOnEnter: true});
            t2.conversion.attributeToElement({
              model: zP,
              view: "sup",
              upcastAlso: [{styles: {"vertical-align": "super"}}]
            });
            t2.commands.add(zP, new yk(t2, zP));
          }
        }
        var FP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
        const DP = "superscript";
        class jP extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add(DP, (i2) => {
              const n2 = t2.commands.get(DP);
              const o2 = new hb(i2);
              o2.set({label: e2("jm"), icon: FP, tooltip: true, isToggleable: true});
              o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute(DP);
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class HP extends mp {
          static get requires() {
            return [LP, jP];
          }
          static get pluginName() {
            return "Superscript";
          }
        }
        function WP(t2, e2) {
          let i2 = e2.parent;
          while (i2) {
            if (i2.name === t2) {
              return i2;
            }
            i2 = i2.parent;
          }
        }
        function qP(t2, e2, i2, n2, o2 = 1) {
          if (e2 > o2) {
            n2.setAttribute(t2, e2, i2);
          } else {
            n2.removeAttribute(t2, i2);
          }
        }
        function UP(t2, e2, i2 = {}) {
          const n2 = t2.createElement("tableCell", i2);
          t2.insertElement("paragraph", n2);
          t2.insert(n2, e2);
        }
        function $P(t2) {
          if (!t2 || !ct(t2)) {
            return t2;
          }
          const {top: e2, right: i2, bottom: n2, left: o2} = t2;
          if (e2 == i2 && i2 == n2 && n2 == o2) {
            return e2;
          }
        }
        function GP(t2, e2) {
          const i2 = parseFloat(t2);
          if (Number.isNaN(i2)) {
            return t2;
          }
          if (String(i2) !== String(t2)) {
            return t2;
          }
          return `${i2}${e2}`;
        }
        function KP(t2, e2) {
          const i2 = e2.parent.parent;
          const n2 = parseInt(i2.getAttribute("headingColumns") || 0);
          const {column: o2} = t2.getCellLocation(e2);
          return !!n2 && o2 < n2;
        }
        function JP() {
          return (t2) => {
            t2.on("element:table", (t3, e2, i2) => {
              const n2 = e2.viewItem;
              if (!i2.consumable.test(n2, {name: true})) {
                return;
              }
              const {rows: o2, headingRows: r2, headingColumns: s2} = QP(n2);
              const a2 = {};
              if (s2) {
                a2.headingColumns = s2;
              }
              if (r2) {
                a2.headingRows = r2;
              }
              const c2 = i2.writer.createElement("table", a2);
              const l2 = i2.splitToAllowedParent(c2, e2.modelCursor);
              if (!l2) {
                return;
              }
              i2.writer.insert(c2, l2.position);
              i2.consumable.consume(n2, {name: true});
              if (o2.length) {
                o2.forEach((t4) => i2.convertItem(t4, i2.writer.createPositionAt(c2, "end")));
              } else {
                const t4 = i2.writer.createElement("tableRow");
                i2.writer.insert(t4, i2.writer.createPositionAt(c2, "end"));
                UP(i2.writer, i2.writer.createPositionAt(t4, "end"));
              }
              e2.modelRange = i2.writer.createRange(i2.writer.createPositionBefore(c2), i2.writer.createPositionAfter(c2));
              if (l2.cursorParent) {
                e2.modelCursor = i2.writer.createPositionAt(l2.cursorParent, 0);
              } else {
                e2.modelCursor = e2.modelRange.end;
              }
            });
          };
        }
        function YP(t2) {
          return (e2) => {
            e2.on(`element:${t2}`, (t3, e3, i2) => {
              const n2 = e3.viewItem;
              if (!i2.consumable.test(n2, {name: true})) {
                return;
              }
              const o2 = i2.writer.createElement("tableCell");
              const r2 = i2.splitToAllowedParent(o2, e3.modelCursor);
              if (!r2) {
                return;
              }
              i2.writer.insert(o2, r2.position);
              i2.consumable.consume(n2, {name: true});
              const s2 = i2.writer.createPositionAt(o2, 0);
              i2.convertChildren(n2, s2);
              if (!o2.childCount) {
                i2.writer.insertElement("paragraph", s2);
              }
              e3.modelRange = i2.writer.createRange(i2.writer.createPositionBefore(o2), i2.writer.createPositionAfter(o2));
              e3.modelCursor = e3.modelRange.end;
            });
          };
        }
        function QP(t2) {
          const e2 = {headingRows: 0, headingColumns: 0};
          const i2 = [];
          const n2 = [];
          let o2;
          for (const r2 of Array.from(t2.getChildren())) {
            if (r2.name === "tbody" || r2.name === "thead" || r2.name === "tfoot") {
              if (r2.name === "thead" && !o2) {
                o2 = r2;
              }
              const t3 = Array.from(r2.getChildren()).filter((t4) => t4.is("element", "tr"));
              for (const r3 of t3) {
                if (r3.parent.name === "thead" && r3.parent === o2) {
                  e2.headingRows++;
                  i2.push(r3);
                } else {
                  n2.push(r3);
                  const t4 = XP(r3, e2, o2);
                  if (t4 > e2.headingColumns) {
                    e2.headingColumns = t4;
                  }
                }
              }
            }
          }
          e2.rows = [...i2, ...n2];
          return e2;
        }
        function XP(t2) {
          let e2 = 0;
          let i2 = 0;
          const n2 = Array.from(t2.getChildren()).filter((t3) => t3.name === "th" || t3.name === "td");
          while (i2 < n2.length && n2[i2].name === "th") {
            const t3 = n2[i2];
            const o2 = parseInt(t3.getAttribute("colspan") || 1);
            e2 = e2 + o2;
            i2++;
          }
          return e2;
        }
        class ZP {
          constructor(t2, e2 = {}) {
            this.table = t2;
            this.startRow = e2.startRow || 0;
            this.endRow = typeof e2.endRow == "number" ? e2.endRow : void 0;
            this.includeSpanned = !!e2.includeSpanned;
            this.column = typeof e2.column == "number" ? e2.column : void 0;
            this._skipRows = new Set();
            this._row = 0;
            this._column = 0;
            this._cellIndex = 0;
            this._spannedCells = new Map();
            this._nextCellAtColumn = -1;
          }
          [Symbol.iterator]() {
            return this;
          }
          next() {
            const t2 = this.table.getChild(this._row);
            if (!t2 || this._isOverEndRow()) {
              return {done: true};
            }
            let e2, i2, n2;
            if (this._isSpanned(this._row, this._column)) {
              e2 = this._getSpanned(this._row, this._column);
              i2 = !this.includeSpanned || this._shouldSkipRow() || this._shouldSkipColumn();
              n2 = this._formatOutValue(e2, this._column, true);
            } else {
              e2 = t2.getChild(this._cellIndex);
              if (!e2) {
                this._row++;
                this._column = 0;
                this._cellIndex = 0;
                this._nextCellAtColumn = -1;
                return this.next();
              }
              const o2 = parseInt(e2.getAttribute("colspan") || 1);
              const r2 = parseInt(e2.getAttribute("rowspan") || 1);
              if (o2 > 1 || r2 > 1) {
                this._recordSpans(this._row, this._column, r2, o2, e2);
              }
              this._nextCellAtColumn = this._column + o2;
              i2 = this._shouldSkipRow() || this._shouldSkipColumn();
              n2 = this._formatOutValue(e2, this._column, false, r2, o2);
            }
            this._column++;
            if (this._column == this._nextCellAtColumn) {
              this._cellIndex++;
            }
            return i2 ? this.next() : n2;
          }
          skipRow(t2) {
            this._skipRows.add(t2);
          }
          _isOverEndRow() {
            return this.endRow !== void 0 && this._row > this.endRow;
          }
          _formatOutValue(t2, e2, i2, n2 = 1, o2 = 1) {
            return {
              done: false,
              value: {
                cell: t2,
                row: this._row,
                column: e2,
                isSpanned: i2,
                rowspan: n2,
                colspan: o2,
                cellIndex: this._cellIndex
              }
            };
          }
          _shouldSkipRow() {
            const t2 = this._row < this.startRow;
            const e2 = this._skipRows.has(this._row);
            return t2 || e2;
          }
          _shouldSkipColumn() {
            if (this.column === void 0) {
              return false;
            }
            return this.column != this._column;
          }
          _isSpanned(t2, e2) {
            if (!this._spannedCells.has(t2)) {
              return false;
            }
            const i2 = this._spannedCells.get(t2);
            return i2.has(e2);
          }
          _getSpanned(t2, e2) {
            return this._spannedCells.get(t2).get(e2);
          }
          _recordSpans(t2, e2, i2, n2, o2) {
            for (let i3 = e2 + 1; i3 <= e2 + n2 - 1; i3++) {
              this._markSpannedCell(t2, i3, o2);
            }
            for (let r2 = t2 + 1; r2 < t2 + i2; r2++) {
              for (let t3 = e2; t3 <= e2 + n2 - 1; t3++) {
                this._markSpannedCell(r2, t3, o2);
              }
            }
          }
          _markSpannedCell(t2, e2, i2) {
            if (!this._spannedCells.has(t2)) {
              this._spannedCells.set(t2, new Map());
            }
            const n2 = this._spannedCells.get(t2);
            n2.set(e2, i2);
          }
        }
        function tS(t2, e2) {
          e2.setCustomProperty("table", true, t2);
          return X_(t2, e2, {hasSelectionHandle: true});
        }
        function eS(t2) {
          return !!t2.getCustomProperty("table") && Q_(t2);
        }
        function iS(t2) {
          const e2 = t2.getSelectedElement();
          if (e2 && eS(e2)) {
            return e2;
          }
          return null;
        }
        function nS(t2) {
          const e2 = WP("table", t2.getFirstPosition());
          if (e2 && eS(e2.parent)) {
            return e2.parent;
          }
          return null;
        }
        function oS(t2) {
          const e2 = [];
          for (const i2 of aS(t2.getRanges())) {
            const t3 = i2.getContainedElement();
            if (t3 && t3.is("tableCell")) {
              e2.push(t3);
            }
          }
          return e2;
        }
        function rS(t2) {
          const e2 = [];
          for (const i2 of t2.getRanges()) {
            const t3 = WP("tableCell", i2.start);
            if (t3) {
              e2.push(t3);
            }
          }
          return e2;
        }
        function sS(t2) {
          const e2 = oS(t2);
          if (e2.length) {
            return e2;
          }
          return rS(t2);
        }
        function aS(t2) {
          return Array.from(t2).sort(cS);
        }
        function cS(t2, e2) {
          const i2 = t2.start;
          const n2 = e2.start;
          if (i2.isEqual(n2)) {
            return 0;
          }
          return i2.isBefore(n2) ? -1 : 1;
        }
        function lS(t2 = {}) {
          return (e2) => e2.on("insert:table", (e3, i2, n2) => {
            const o2 = i2.item;
            if (!n2.consumable.consume(o2, "insert")) {
              return;
            }
            n2.consumable.consume(o2, "attribute:headingRows:table");
            n2.consumable.consume(o2, "attribute:headingColumns:table");
            const r2 = t2 && t2.asWidget;
            const s2 = n2.writer.createContainerElement("figure", {class: "table"});
            const a2 = n2.writer.createContainerElement("table");
            n2.writer.insert(n2.writer.createPositionAt(s2, 0), a2);
            let c2;
            if (r2) {
              c2 = tS(s2, n2.writer);
            }
            const l2 = new ZP(o2);
            const d2 = {
              headingRows: o2.getAttribute("headingRows") || 0,
              headingColumns: o2.getAttribute("headingColumns") || 0
            };
            const u2 = new Map();
            for (const e4 of l2) {
              const {row: i3, cell: r3} = e4;
              const s3 = vS(_S(i3, d2), a2, n2);
              const c3 = o2.getChild(i3);
              const l3 = u2.get(i3) || wS(c3, i3, s3, n2);
              u2.set(i3, l3);
              n2.consumable.consume(r3, "insert");
              const h3 = n2.writer.createPositionAt(l3, "end");
              bS(e4, d2, h3, n2, t2);
            }
            const h2 = n2.mapper.toViewPosition(i2.range.start);
            n2.mapper.bindElements(o2, r2 ? c2 : s2);
            n2.writer.insert(h2, r2 ? c2 : s2);
          });
        }
        function dS(t2 = {}) {
          return (e2) => e2.on("insert:tableRow", (e3, i2, n2) => {
            const o2 = i2.item;
            if (!n2.consumable.consume(o2, "insert")) {
              return;
            }
            const r2 = o2.parent;
            const s2 = n2.mapper.toViewElement(r2);
            const a2 = TS(s2);
            const c2 = r2.getChildIndex(o2);
            const l2 = new ZP(r2, {startRow: c2, endRow: c2});
            const d2 = {
              headingRows: r2.getAttribute("headingRows") || 0,
              headingColumns: r2.getAttribute("headingColumns") || 0
            };
            const u2 = new Map();
            for (const e4 of l2) {
              const i3 = vS(_S(c2, d2), a2, n2);
              const r3 = u2.get(c2) || wS(o2, c2, i3, n2);
              u2.set(c2, r3);
              n2.consumable.consume(e4.cell, "insert");
              const s3 = n2.writer.createPositionAt(r3, "end");
              bS(e4, d2, s3, n2, t2);
            }
          });
        }
        function uS(t2 = {}) {
          return (e2) => e2.on("insert:tableCell", (e3, i2, n2) => {
            const o2 = i2.item;
            if (!n2.consumable.consume(o2, "insert")) {
              return;
            }
            const r2 = o2.parent;
            const s2 = r2.parent;
            const a2 = s2.getChildIndex(r2);
            const c2 = new ZP(s2, {startRow: a2, endRow: a2});
            const l2 = {
              headingRows: s2.getAttribute("headingRows") || 0,
              headingColumns: s2.getAttribute("headingColumns") || 0
            };
            for (const e4 of c2) {
              if (e4.cell === o2) {
                const i3 = n2.mapper.toViewElement(r2);
                const s3 = n2.writer.createPositionAt(i3, r2.getChildIndex(o2));
                bS(e4, l2, s3, n2, t2);
                return;
              }
            }
          });
        }
        function hS(t2 = {}) {
          const e2 = !!t2.asWidget;
          return (t3) => t3.on("attribute:headingRows:table", (t4, i2, n2) => {
            const o2 = i2.item;
            if (!n2.consumable.consume(i2.item, t4.name)) {
              return;
            }
            const r2 = n2.mapper.toViewElement(o2);
            const s2 = TS(r2);
            const a2 = i2.attributeOldValue;
            const c2 = i2.attributeNewValue;
            if (c2 > a2) {
              const t5 = Array.from(o2.getChildren()).filter(({index: t6}) => l2(t6, a2 - 1, c2));
              const i3 = vS("thead", s2, n2);
              AS(t5, i3, n2, "end");
              for (const i4 of t5) {
                for (const t6 of i4.getChildren()) {
                  mS(t6, "th", n2, e2);
                }
              }
              CS("tbody", s2, n2);
            } else {
              const t5 = Array.from(o2.getChildren()).filter(({index: t6}) => l2(t6, c2 - 1, a2)).reverse();
              const i3 = vS("tbody", s2, n2);
              AS(t5, i3, n2, 0);
              const r3 = new ZP(o2, {startRow: c2 ? c2 - 1 : c2, endRow: a2 - 1});
              const d2 = {
                headingRows: o2.getAttribute("headingRows") || 0,
                headingColumns: o2.getAttribute("headingColumns") || 0
              };
              for (const t6 of r3) {
                pS(t6, d2, n2, e2);
              }
              CS("thead", s2, n2);
            }
            function l2(t5, e3, i3) {
              return t5 > e3 && t5 < i3;
            }
          });
        }
        function fS(t2 = {}) {
          const e2 = !!t2.asWidget;
          return (t3) => t3.on("attribute:headingColumns:table", (t4, i2, n2) => {
            const o2 = i2.item;
            if (!n2.consumable.consume(i2.item, t4.name)) {
              return;
            }
            const r2 = {
              headingRows: o2.getAttribute("headingRows") || 0,
              headingColumns: o2.getAttribute("headingColumns") || 0
            };
            const s2 = i2.attributeOldValue;
            const a2 = i2.attributeNewValue;
            const c2 = (s2 > a2 ? s2 : a2) - 1;
            for (const t5 of new ZP(o2)) {
              if (t5.column > c2) {
                continue;
              }
              pS(t5, r2, n2, e2);
            }
          });
        }
        function gS() {
          return (t2) => t2.on("remove:tableRow", (t3, e2, i2) => {
            t3.stop();
            const n2 = i2.writer;
            const o2 = i2.mapper;
            const r2 = o2.toViewPosition(e2.position).getLastMatchingPosition((t4) => !t4.item.is("tr"));
            const s2 = r2.nodeAfter;
            const a2 = s2.parent;
            const c2 = n2.createRangeOn(s2);
            const l2 = n2.remove(c2);
            for (const t4 of n2.createRangeIn(l2).getItems()) {
              o2.unbindViewElement(t4);
            }
            if (!a2.childCount) {
              n2.remove(n2.createRangeOn(a2));
            }
          }, {priority: "higher"});
        }
        function mS(t2, e2, i2, n2) {
          const o2 = i2.writer;
          const r2 = i2.mapper.toViewElement(t2);
          if (!r2) {
            return;
          }
          let s2;
          if (n2) {
            const t3 = o2.createEditableElement(e2, r2.getAttributes());
            s2 = iv(t3, o2);
            o2.insert(o2.createPositionAfter(r2), s2);
            o2.move(o2.createRangeIn(r2), o2.createPositionAt(s2, 0));
            o2.remove(o2.createRangeOn(r2));
          } else {
            s2 = o2.rename(e2, r2);
          }
          i2.mapper.unbindViewElement(r2);
          i2.mapper.bindElements(t2, s2);
        }
        function pS(t2, e2, i2, n2) {
          const {cell: o2} = t2;
          const r2 = kS(t2, e2);
          const s2 = i2.mapper.toViewElement(o2);
          if (s2 && s2.name !== r2) {
            mS(o2, r2, i2, n2);
          }
        }
        function bS(t2, e2, i2, n2, o2) {
          const r2 = o2 && o2.asWidget;
          const s2 = kS(t2, e2);
          const a2 = r2 ? iv(n2.writer.createEditableElement(s2), n2.writer) : n2.writer.createContainerElement(s2);
          const c2 = t2.cell;
          const l2 = c2.getChild(0);
          const d2 = c2.childCount === 1 && l2.name === "paragraph";
          n2.writer.insert(i2, a2);
          if (d2 && !PS(l2)) {
            const t3 = c2.getChild(0);
            const e3 = n2.writer.createPositionAt(a2, "end");
            n2.consumable.consume(t3, "insert");
            if (o2.asWidget) {
              const i3 = n2.writer.createContainerElement("span", {style: "display:inline-block"});
              n2.mapper.bindElements(t3, i3);
              n2.writer.insert(e3, i3);
              n2.mapper.bindElements(c2, a2);
            } else {
              n2.mapper.bindElements(c2, a2);
              n2.mapper.bindElements(t3, a2);
            }
          } else {
            n2.mapper.bindElements(c2, a2);
          }
        }
        function wS(t2, e2, i2, n2) {
          n2.consumable.consume(t2, "insert");
          const o2 = n2.writer.createContainerElement("tr");
          n2.mapper.bindElements(t2, o2);
          const r2 = t2.parent.getAttribute("headingRows") || 0;
          const s2 = r2 > 0 && e2 >= r2 ? e2 - r2 : e2;
          const a2 = n2.writer.createPositionAt(i2, s2);
          n2.writer.insert(a2, o2);
          return o2;
        }
        function kS(t2, e2) {
          const {row: i2, column: n2} = t2;
          const {headingColumns: o2, headingRows: r2} = e2;
          const s2 = r2 && r2 > i2;
          if (s2) {
            return "th";
          }
          const a2 = o2 && o2 > n2;
          return a2 ? "th" : "td";
        }
        function _S(t2, e2) {
          return t2 < e2.headingRows ? "thead" : "tbody";
        }
        function vS(t2, e2, i2) {
          const n2 = yS(t2, e2);
          return n2 ? n2 : xS(t2, e2, i2);
        }
        function yS(t2, e2) {
          for (const i2 of e2.getChildren()) {
            if (i2.name == t2) {
              return i2;
            }
          }
        }
        function xS(t2, e2, i2) {
          const n2 = i2.writer.createContainerElement(t2);
          const o2 = i2.writer.createPositionAt(e2, t2 == "tbody" ? "end" : 0);
          i2.writer.insert(o2, n2);
          return n2;
        }
        function CS(t2, e2, i2) {
          const n2 = yS(t2, e2);
          if (n2 && n2.childCount === 0) {
            i2.writer.remove(i2.writer.createRangeOn(n2));
          }
        }
        function AS(t2, e2, i2, n2) {
          for (const o2 of t2) {
            const t3 = i2.mapper.toViewElement(o2);
            if (t3) {
              i2.writer.move(i2.writer.createRangeOn(t3), i2.writer.createPositionAt(e2, n2));
            }
          }
        }
        function TS(t2) {
          for (const e2 of t2.getChildren()) {
            if (e2.name === "table") {
              return e2;
            }
          }
        }
        function PS(t2) {
          return !![...t2.getAttributeKeys()].length;
        }
        class SS extends jw {
          refresh() {
            const t2 = this.editor.model;
            const e2 = t2.document.selection;
            const i2 = t2.schema;
            const n2 = ES(e2.getFirstPosition());
            this.isEnabled = i2.checkChild(n2, "table");
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = e2.document.selection;
            const n2 = this.editor.plugins.get("TableUtils");
            const o2 = parseInt(t2.rows) || 2;
            const r2 = parseInt(t2.columns) || 2;
            const s2 = nv(i2, e2);
            e2.change((t3) => {
              const i3 = n2.createTable(t3, o2, r2);
              e2.insertContent(i3, s2);
              t3.setSelection(t3.createPositionAt(i3.getNodeByPath([0, 0, 0]), 0));
            });
          }
        }
        function ES(t2) {
          const e2 = t2.parent;
          return e2 === e2.root ? e2 : e2.parent;
        }
        class RS extends jw {
          constructor(t2, e2 = {}) {
            super(t2);
            this.order = e2.order || "below";
          }
          refresh() {
            const t2 = this.editor.model.document.selection;
            const e2 = WP("table", t2.getFirstPosition());
            this.isEnabled = !!e2;
          }
          execute() {
            const t2 = this.editor;
            const e2 = t2.model.document.selection;
            const i2 = t2.plugins.get("TableUtils");
            const n2 = this.order === "above";
            const o2 = n2 ? e2.getFirstPosition() : e2.getLastPosition();
            const r2 = n2 ? e2.getFirstRange() : e2.getLastRange();
            const s2 = r2.getContainedElement() || WP("tableCell", o2);
            const a2 = s2.parent;
            const c2 = a2.parent;
            const l2 = c2.getChildIndex(a2);
            i2.insertRows(c2, {rows: 1, at: this.order === "below" ? l2 + 1 : l2});
          }
        }
        class OS extends jw {
          constructor(t2, e2 = {}) {
            super(t2);
            this.order = e2.order || "right";
          }
          refresh() {
            const t2 = this.editor.model.document.selection;
            const e2 = WP("table", t2.getFirstPosition());
            this.isEnabled = !!e2;
          }
          execute() {
            const t2 = this.editor;
            const e2 = t2.model.document.selection;
            const i2 = t2.plugins.get("TableUtils");
            const n2 = this.order === "left";
            const o2 = n2 ? e2.getFirstPosition() : e2.getLastPosition();
            const r2 = n2 ? e2.getFirstRange() : e2.getLastRange();
            const s2 = r2.getContainedElement() || WP("tableCell", o2);
            const a2 = s2.parent.parent;
            const {column: c2} = i2.getCellLocation(s2);
            i2.insertColumns(a2, {columns: 1, at: n2 ? c2 : c2 + 1});
          }
        }
        class IS extends jw {
          constructor(t2, e2 = {}) {
            super(t2);
            this.direction = e2.direction || "horizontally";
          }
          refresh() {
            const t2 = sS(this.editor.model.document.selection);
            this.isEnabled = t2.length === 1;
          }
          execute() {
            const t2 = sS(this.editor.model.document.selection)[0];
            const e2 = this.direction === "horizontally";
            const i2 = this.editor.plugins.get("TableUtils");
            if (e2) {
              i2.splitCellHorizontally(t2, 2);
            } else {
              i2.splitCellVertically(t2, 2);
            }
          }
        }
        class VS extends jw {
          constructor(t2, e2) {
            super(t2);
            this.direction = e2.direction;
            this.isHorizontal = this.direction == "right" || this.direction == "left";
          }
          refresh() {
            const t2 = this._getMergeableCell();
            this.value = t2;
            this.isEnabled = !!t2;
          }
          execute() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            const i2 = rS(e2.selection)[0];
            const n2 = this.value;
            const o2 = this.direction;
            t2.change((t3) => {
              const e3 = o2 == "right" || o2 == "down";
              const r2 = e3 ? i2 : n2;
              const s2 = e3 ? n2 : i2;
              const a2 = s2.parent;
              zS(s2, r2, t3);
              const c2 = this.isHorizontal ? "colspan" : "rowspan";
              const l2 = parseInt(i2.getAttribute(c2) || 1);
              const d2 = parseInt(n2.getAttribute(c2) || 1);
              t3.setAttribute(c2, l2 + d2, r2);
              t3.setSelection(t3.createRangeIn(r2));
              if (!a2.childCount) {
                BS(a2, t3);
              }
            });
          }
          _getMergeableCell() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            const i2 = rS(e2.selection)[0];
            if (!i2) {
              return;
            }
            const n2 = this.editor.plugins.get("TableUtils");
            const o2 = this.isHorizontal ? NS(i2, this.direction, n2) : MS(i2, this.direction);
            if (!o2) {
              return;
            }
            const r2 = this.isHorizontal ? "rowspan" : "colspan";
            const s2 = parseInt(i2.getAttribute(r2) || 1);
            const a2 = parseInt(o2.getAttribute(r2) || 1);
            if (a2 === s2) {
              return o2;
            }
          }
        }
        function NS(t2, e2, i2) {
          const n2 = t2.parent;
          const o2 = n2.parent;
          const r2 = e2 == "right" ? t2.nextSibling : t2.previousSibling;
          const s2 = (o2.getAttribute("headingColumns") || 0) > 0;
          if (!r2) {
            return;
          }
          const a2 = e2 == "right" ? t2 : r2;
          const c2 = e2 == "right" ? r2 : t2;
          const {column: l2} = i2.getCellLocation(a2);
          const {column: d2} = i2.getCellLocation(c2);
          const u2 = parseInt(a2.getAttribute("colspan") || 1);
          const h2 = KP(i2, a2, o2);
          const f2 = KP(i2, c2, o2);
          if (s2 && h2 != f2) {
            return;
          }
          const g2 = l2 + u2 === d2;
          return g2 ? r2 : void 0;
        }
        function MS(t2, e2) {
          const i2 = t2.parent;
          const n2 = i2.parent;
          const o2 = n2.getChildIndex(i2);
          if (e2 == "down" && o2 === n2.childCount - 1 || e2 == "up" && o2 === 0) {
            return;
          }
          const r2 = parseInt(t2.getAttribute("rowspan") || 1);
          const s2 = n2.getAttribute("headingRows") || 0;
          const a2 = e2 == "down" && o2 + r2 === s2;
          const c2 = e2 == "up" && o2 === s2;
          if (s2 && (a2 || c2)) {
            return;
          }
          const l2 = parseInt(t2.getAttribute("rowspan") || 1);
          const d2 = e2 == "down" ? o2 + l2 : o2;
          const u2 = [...new ZP(n2, {endRow: d2})];
          const h2 = u2.find((e3) => e3.cell === t2);
          const f2 = h2.column;
          const g2 = u2.find(({row: t3, rowspan: i3, column: n3}) => {
            if (n3 !== f2) {
              return false;
            }
            if (e2 == "down") {
              return t3 === d2;
            } else {
              return d2 === t3 + i3;
            }
          });
          return g2 && g2.cell;
        }
        function BS(t2, e2) {
          const i2 = t2.parent;
          const n2 = i2.getChildIndex(t2);
          for (const {cell: t3, row: o2, rowspan: r2} of new ZP(i2, {endRow: n2})) {
            const i3 = o2 + r2 - 1 >= n2;
            if (i3) {
              qP("rowspan", r2 - 1, t3, e2);
            }
          }
          e2.remove(t2);
        }
        function zS(t2, e2, i2) {
          if (!LS(t2)) {
            if (LS(e2)) {
              i2.remove(i2.createRangeIn(e2));
            }
            i2.move(i2.createRangeIn(t2), i2.createPositionAt(e2, "end"));
          }
          i2.remove(t2);
        }
        function LS(t2) {
          return t2.childCount == 1 && t2.getChild(0).is("paragraph") && t2.getChild(0).isEmpty;
        }
        class FS extends jw {
          refresh() {
            const t2 = sS(this.editor.model.document.selection);
            const e2 = t2[0];
            if (e2) {
              const i2 = e2.parent.parent;
              const n2 = this.editor.plugins.get("TableUtils").getRows(i2);
              const o2 = [...new ZP(i2)];
              const r2 = o2.filter((e3) => t2.includes(e3.cell)).map((t3) => t3.row);
              const s2 = r2[0];
              const a2 = r2[r2.length - 1];
              this.isEnabled = a2 - s2 < n2 - 1;
            } else {
              this.isEnabled = false;
            }
          }
          execute() {
            const t2 = sS(this.editor.model.document.selection);
            const e2 = DS(t2);
            const i2 = t2[0];
            const n2 = i2.parent.parent;
            const o2 = [...new ZP(n2, {endRow: e2.last})];
            const r2 = this.editor.model.createBatch();
            const s2 = HS(o2, i2);
            this.editor.model.enqueueChange(r2, (t3) => {
              t3.setSelection(t3.createSelection(n2, "on"));
            });
            let a2;
            for (let t3 = e2.last; t3 >= e2.first; t3--) {
              this.editor.model.enqueueChange(r2, (e3) => {
                const i3 = t3;
                this._removeRow(i3, n2, e3, o2);
                a2 = jS(n2, i3, s2);
              });
            }
            this.editor.model.enqueueChange(r2, (t3) => {
              t3.setSelection(t3.createPositionAt(a2, 0));
            });
          }
          _removeRow(t2, e2, i2, n2) {
            const o2 = new Map();
            const r2 = e2.getChild(t2);
            const s2 = e2.getAttribute("headingRows") || 0;
            if (s2 && t2 < s2) {
              qP("headingRows", s2 - 1, e2, i2, 0);
            }
            n2.filter(({row: e3, rowspan: i3}) => e3 === t2 && i3 > 1).forEach(({column: t3, cell: e3, rowspan: i3}) => o2.set(t3, {
              cell: e3,
              rowspanToSet: i3 - 1
            }));
            n2.filter(({row: e3, rowspan: i3}) => e3 <= t2 - 1 && e3 + i3 > t2).forEach(({cell: t3, rowspan: e3}) => qP("rowspan", e3 - 1, t3, i2));
            const a2 = t2 + 1;
            const c2 = new ZP(e2, {includeSpanned: true, startRow: a2, endRow: a2});
            let l2;
            for (const {row: t3, column: n3, cell: r3} of [...c2]) {
              if (o2.has(n3)) {
                const {cell: r4, rowspanToSet: s3} = o2.get(n3);
                const a3 = l2 ? i2.createPositionAfter(l2) : i2.createPositionAt(e2.getChild(t3), 0);
                i2.move(i2.createRangeOn(r4), a3);
                qP("rowspan", s3, r4, i2);
                l2 = r4;
              } else {
                l2 = r3;
              }
            }
            i2.remove(r2);
          }
        }
        function DS(t2) {
          const e2 = t2.map((t3) => t3.parent.index).sort();
          return {first: e2[0], last: e2[e2.length - 1]};
        }
        function jS(t2, e2, i2) {
          const n2 = t2.getChild(e2) || t2.getChild(t2.childCount - 1);
          let o2 = n2.getChild(0);
          let r2 = 0;
          for (const t3 of n2.getChildren()) {
            if (r2 > i2) {
              return o2;
            }
            o2 = t3;
            r2 += parseInt(t3.getAttribute("colspan") || 1);
          }
          return o2;
        }
        function HS(t2, e2) {
          const i2 = t2.find((t3) => t3.cell === e2);
          return i2.column;
        }
        class WS extends jw {
          refresh() {
            const t2 = sS(this.editor.model.document.selection);
            const e2 = t2[0];
            if (e2) {
              const i2 = e2.parent.parent;
              const n2 = this.editor.plugins.get("TableUtils").getColumns(i2);
              const o2 = [...new ZP(i2)];
              const r2 = o2.filter((e3) => t2.includes(e3.cell)).map((t3) => t3.column).sort();
              const s2 = r2[0];
              const a2 = r2[r2.length - 1];
              this.isEnabled = a2 - s2 < n2 - 1;
            } else {
              this.isEnabled = false;
            }
          }
          execute() {
            const [t2, e2] = $S(this.editor.model.document.selection);
            const i2 = t2.parent.parent;
            const n2 = [...new ZP(i2)];
            const o2 = {first: n2.find((e3) => e3.cell === t2).column, last: n2.find((t3) => t3.cell === e2).column};
            const r2 = US(n2, t2, e2, o2);
            this.editor.model.change((t3) => {
              t3.setSelection(t3.createRangeOn(i2));
              qS(i2, o2, t3);
              for (let e3 = o2.last; e3 >= o2.first; e3--) {
                for (const {cell: i3, column: o3, colspan: r3} of n2) {
                  if (o3 <= e3 && r3 > 1 && o3 + r3 > e3) {
                    qP("colspan", r3 - 1, i3, t3);
                  } else if (o3 === e3) {
                    const e4 = i3.parent;
                    t3.remove(i3);
                    if (!e4.childCount) {
                      t3.remove(e4);
                    }
                  }
                }
              }
              t3.setSelection(t3.createPositionAt(r2, 0));
            });
          }
        }
        function qS(t2, e2, i2) {
          const n2 = t2.getAttribute("headingColumns") || 0;
          if (n2 && e2.first <= n2) {
            const o2 = Math.min(n2 - 1, e2.last) - e2.first + 1;
            i2.setAttribute("headingColumns", n2 - o2, t2);
          }
        }
        function US(t2, e2, i2, n2) {
          const o2 = parseInt(i2.getAttribute("colspan") || 1);
          if (o2 > 1) {
            return i2;
          } else if (e2.previousSibling || i2.nextSibling) {
            return i2.nextSibling || e2.previousSibling;
          } else {
            if (n2.first) {
              return t2.reverse().find(({column: t3}) => t3 < n2.first).cell;
            } else {
              return t2.reverse().find(({column: t3}) => t3 > n2.last).cell;
            }
          }
        }
        function $S(t2) {
          const e2 = sS(t2);
          const i2 = e2[0];
          const n2 = e2.pop();
          const o2 = [i2, n2];
          return i2.isBefore(n2) ? o2 : o2.reverse();
        }
        class GS extends jw {
          refresh() {
            const t2 = this.editor.model;
            const e2 = sS(t2.document.selection);
            const i2 = e2.length > 0;
            this.isEnabled = i2;
            this.value = i2 && e2.every((t3) => this._isInHeading(t3, t3.parent.parent));
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = sS(e2.document.selection);
            const n2 = i2[0];
            const o2 = i2[i2.length - 1];
            const r2 = n2.parent.parent;
            const s2 = r2.getAttribute("headingRows") || 0;
            const [a2, c2] = [n2.parent.index, o2.parent.index].sort();
            if (t2.forceValue === this.value) {
              return;
            }
            const l2 = this.value ? a2 : c2 + 1;
            e2.change((t3) => {
              if (l2) {
                const e3 = KS(r2, l2, s2);
                for (const i3 of e3) {
                  JS(i3, l2, t3);
                }
              }
              qP("headingRows", l2, r2, t3, 0);
            });
          }
          _isInHeading(t2, e2) {
            const i2 = parseInt(e2.getAttribute("headingRows") || 0);
            return !!i2 && t2.parent.index < i2;
          }
        }
        function KS(t2, e2, i2) {
          const n2 = [];
          const o2 = e2 > i2 ? i2 : 0;
          const r2 = e2 - 1;
          const s2 = new ZP(t2, {startRow: o2, endRow: r2});
          for (const {row: t3, rowspan: i3, cell: o3} of s2) {
            if (i3 > 1 && t3 + i3 > e2) {
              n2.push(o3);
            }
          }
          return n2;
        }
        function JS(t2, e2, i2) {
          const n2 = t2.parent;
          const o2 = n2.parent;
          const r2 = n2.index;
          const s2 = parseInt(t2.getAttribute("rowspan"));
          const a2 = e2 - r2;
          const c2 = {};
          const l2 = s2 - a2;
          if (l2 > 1) {
            c2.rowspan = l2;
          }
          const d2 = parseInt(t2.getAttribute("colspan") || 1);
          if (d2 > 1) {
            c2.colspan = d2;
          }
          const u2 = o2.getChildIndex(n2);
          const h2 = u2 + a2;
          const f2 = [...new ZP(o2, {startRow: u2, endRow: h2, includeSpanned: true})];
          let g2;
          for (const {row: e3, column: n3, cell: r3, cellIndex: s3} of f2) {
            if (r3 === t2 && g2 === void 0) {
              g2 = n3;
            }
            if (g2 !== void 0 && g2 === n3 && e3 === h2) {
              const t3 = o2.getChild(e3);
              const n4 = i2.createPositionAt(t3, s3);
              UP(i2, n4, c2);
            }
          }
          qP("rowspan", a2, t2, i2);
        }
        class YS extends jw {
          refresh() {
            const t2 = this.editor.model;
            const e2 = sS(t2.document.selection);
            const i2 = this.editor.plugins.get("TableUtils");
            const n2 = e2.length > 0;
            this.isEnabled = n2;
            this.value = n2 && e2.every((t3) => KP(i2, t3));
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = this.editor.plugins.get("TableUtils");
            const n2 = sS(e2.document.selection);
            const o2 = n2[0];
            const r2 = n2[n2.length - 1];
            const s2 = o2.parent;
            const a2 = s2.parent;
            const [c2, l2] = [i2.getCellLocation(o2).column, i2.getCellLocation(r2).column].sort();
            if (t2.forceValue === this.value) {
              return;
            }
            const d2 = this.value ? c2 : l2 + 1;
            e2.change((t3) => {
              qP("headingColumns", d2, a2, t3, 0);
            });
          }
        }
        class QS extends mp {
          static get pluginName() {
            return "TableUtils";
          }
          getCellLocation(t2) {
            const e2 = t2.parent;
            const i2 = e2.parent;
            const n2 = i2.getChildIndex(e2);
            const o2 = new ZP(i2, {startRow: n2, endRow: n2});
            for (const {cell: e3, row: i3, column: n3} of o2) {
              if (e3 === t2) {
                return {row: i3, column: n3};
              }
            }
          }
          createTable(t2, e2, i2) {
            const n2 = t2.createElement("table");
            XS(t2, n2, 0, e2, i2);
            return n2;
          }
          insertRows(t2, e2 = {}) {
            const i2 = this.editor.model;
            const n2 = e2.at || 0;
            const o2 = e2.rows || 1;
            i2.change((e3) => {
              const i3 = t2.getAttribute("headingRows") || 0;
              if (i3 > n2) {
                e3.setAttribute("headingRows", i3 + o2, t2);
              }
              if (n2 === 0 || n2 === t2.childCount) {
                XS(e3, t2, n2, o2, this.getColumns(t2));
                return;
              }
              const r2 = new ZP(t2, {endRow: n2});
              let s2 = 0;
              for (const {row: t3, rowspan: i4, colspan: a2, cell: c2} of r2) {
                const r3 = t3 < n2;
                const l2 = t3 + i4 > n2;
                if (r3 && l2) {
                  e3.setAttribute("rowspan", i4 + o2, c2);
                }
                if (t3 === n2) {
                  s2 += a2;
                }
              }
              XS(e3, t2, n2, o2, s2);
            });
          }
          insertColumns(t2, e2 = {}) {
            const i2 = this.editor.model;
            const n2 = e2.at || 0;
            const o2 = e2.columns || 1;
            i2.change((e3) => {
              const i3 = t2.getAttribute("headingColumns");
              if (n2 < i3) {
                e3.setAttribute("headingColumns", i3 + o2, t2);
              }
              const r2 = this.getColumns(t2);
              if (n2 === 0 || r2 === n2) {
                for (const i4 of t2.getChildren()) {
                  ZS(o2, e3, e3.createPositionAt(i4, n2 ? "end" : 0));
                }
                return;
              }
              const s2 = new ZP(t2, {column: n2, includeSpanned: true});
              for (const {row: i4, cell: r3, cellIndex: a2} of s2) {
                const c2 = parseInt(r3.getAttribute("rowspan") || 1);
                const l2 = parseInt(r3.getAttribute("colspan") || 1);
                if (r3.index !== n2 && l2 > 1) {
                  e3.setAttribute("colspan", l2 + o2, r3);
                  s2.skipRow(i4);
                  if (c2 > 1) {
                    for (let t3 = i4 + 1; t3 < i4 + c2; t3++) {
                      s2.skipRow(t3);
                    }
                  }
                } else {
                  const n3 = e3.createPositionAt(t2.getChild(i4), a2);
                  ZS(o2, e3, n3);
                }
              }
            });
          }
          splitCellVertically(t2, e2 = 2) {
            const i2 = this.editor.model;
            const n2 = t2.parent;
            const o2 = n2.parent;
            const r2 = parseInt(t2.getAttribute("rowspan") || 1);
            const s2 = parseInt(t2.getAttribute("colspan") || 1);
            i2.change((i3) => {
              if (s2 > 1) {
                const {newCellsSpan: n3, updatedSpan: o3} = tE(s2, e2);
                qP("colspan", o3, t2, i3);
                const a2 = {};
                if (n3 > 1) {
                  a2.colspan = n3;
                }
                if (r2 > 1) {
                  a2.rowspan = r2;
                }
                const c2 = s2 > e2 ? e2 - 1 : s2 - 1;
                ZS(c2, i3, i3.createPositionAfter(t2), a2);
              }
              if (s2 < e2) {
                const n3 = e2 - s2;
                const a2 = [...new ZP(o2)];
                const {column: c2} = a2.find(({cell: e3}) => e3 === t2);
                const l2 = a2.filter(({cell: e3, colspan: i4, column: n4}) => {
                  const o3 = e3 !== t2 && n4 === c2;
                  const r3 = n4 < c2 && n4 + i4 > c2;
                  return o3 || r3;
                });
                for (const {cell: t3, colspan: e3} of l2) {
                  i3.setAttribute("colspan", e3 + n3, t3);
                }
                const d2 = {};
                if (r2 > 1) {
                  d2.rowspan = r2;
                }
                ZS(n3, i3, i3.createPositionAfter(t2), d2);
                const u2 = o2.getAttribute("headingColumns") || 0;
                if (u2 > c2) {
                  qP("headingColumns", u2 + n3, o2, i3);
                }
              }
            });
          }
          splitCellHorizontally(t2, e2 = 2) {
            const i2 = this.editor.model;
            const n2 = t2.parent;
            const o2 = n2.parent;
            const r2 = o2.getChildIndex(n2);
            const s2 = parseInt(t2.getAttribute("rowspan") || 1);
            const a2 = parseInt(t2.getAttribute("colspan") || 1);
            i2.change((i3) => {
              if (s2 > 1) {
                const n3 = [...new ZP(o2, {startRow: r2, endRow: r2 + s2 - 1, includeSpanned: true})];
                const {newCellsSpan: c2, updatedSpan: l2} = tE(s2, e2);
                qP("rowspan", l2, t2, i3);
                const {column: d2} = n3.find(({cell: e3}) => e3 === t2);
                const u2 = {};
                if (c2 > 1) {
                  u2.rowspan = c2;
                }
                if (a2 > 1) {
                  u2.colspan = a2;
                }
                for (const {column: t3, row: e3, cellIndex: s3} of n3) {
                  const n4 = e3 >= r2 + l2;
                  const a3 = t3 === d2;
                  const h2 = (e3 + r2 + l2) % c2 === 0;
                  if (n4 && a3 && h2) {
                    const t4 = i3.createPositionAt(o2.getChild(e3), s3);
                    ZS(1, i3, t4, u2);
                  }
                }
              }
              if (s2 < e2) {
                const n3 = e2 - s2;
                const c2 = [...new ZP(o2, {startRow: 0, endRow: r2})];
                for (const {cell: e3, rowspan: o3, row: s3} of c2) {
                  if (e3 !== t2 && s3 + o3 > r2) {
                    const t3 = o3 + n3;
                    i3.setAttribute("rowspan", t3, e3);
                  }
                }
                const l2 = {};
                if (a2 > 1) {
                  l2.colspan = a2;
                }
                XS(i3, o2, r2 + 1, n3, 1, l2);
                const d2 = o2.getAttribute("headingRows") || 0;
                if (d2 > r2) {
                  qP("headingRows", d2 + n3, o2, i3);
                }
              }
            });
          }
          getColumns(t2) {
            const e2 = t2.getChild(0);
            return [...e2.getChildren()].reduce((t3, e3) => {
              const i2 = parseInt(e3.getAttribute("colspan") || 1);
              return t3 + i2;
            }, 0);
          }
          getRows(t2) {
            return t2.childCount;
          }
        }
        function XS(t2, e2, i2, n2, o2, r2 = {}) {
          for (let s2 = 0; s2 < n2; s2++) {
            const n3 = t2.createElement("tableRow");
            t2.insert(n3, e2, i2);
            ZS(o2, t2, t2.createPositionAt(n3, "end"), r2);
          }
        }
        function ZS(t2, e2, i2, n2 = {}) {
          for (let o2 = 0; o2 < t2; o2++) {
            UP(e2, i2, n2);
          }
        }
        function tE(t2, e2) {
          if (t2 < e2) {
            return {newCellsSpan: 1, updatedSpan: 1};
          }
          const i2 = Math.floor(t2 / e2);
          const n2 = t2 - i2 * e2 + i2;
          return {newCellsSpan: i2, updatedSpan: n2};
        }
        function eE(t2) {
          t2.document.registerPostFixer((e2) => iE(e2, t2));
        }
        function iE(t2, e2) {
          const i2 = e2.document.differ.getChanges();
          let n2 = false;
          const o2 = new Set();
          for (const e3 of i2) {
            let i3;
            if (e3.name == "table" && e3.type == "insert") {
              i3 = e3.position.nodeAfter;
            }
            if (e3.name == "tableRow" || e3.name == "tableCell") {
              i3 = WP("table", e3.position);
            }
            if (aE(e3)) {
              i3 = WP("table", e3.range.start);
            }
            if (i3 && !o2.has(i3)) {
              n2 = nE(i3, t2) || n2;
              n2 = oE(i3, t2) || n2;
              o2.add(i3);
            }
          }
          return n2;
        }
        function nE(t2, e2) {
          let i2 = false;
          const n2 = rE(t2);
          if (n2.length) {
            i2 = true;
            for (const t3 of n2) {
              qP("rowspan", t3.rowspan, t3.cell, e2, 1);
            }
          }
          return i2;
        }
        function oE(t2, e2) {
          let i2 = false;
          const n2 = sE(t2);
          const o2 = n2[0];
          const r2 = Object.values(n2).every((t3) => t3 === o2);
          if (!r2) {
            const o3 = Object.values(n2).reduce((t3, e3) => e3 > t3 ? e3 : t3, 0);
            for (const [r3, s2] of Object.entries(n2)) {
              const n3 = o3 - s2;
              if (n3) {
                for (let i3 = 0; i3 < n3; i3++) {
                  UP(e2, e2.createPositionAt(t2.getChild(r3), "end"));
                }
                i2 = true;
              }
            }
          }
          return i2;
        }
        function rE(t2) {
          const e2 = parseInt(t2.getAttribute("headingRows") || 0);
          const i2 = t2.childCount;
          const n2 = [];
          for (const {row: o2, rowspan: r2, cell: s2} of new ZP(t2)) {
            if (r2 < 2) {
              continue;
            }
            const t3 = o2 < e2;
            const a2 = t3 ? e2 : i2;
            if (o2 + r2 > a2) {
              const t4 = a2 - o2;
              n2.push({cell: s2, rowspan: t4});
            }
          }
          return n2;
        }
        function sE(t2) {
          const e2 = {};
          for (const {row: i2} of new ZP(t2, {includeSpanned: true})) {
            if (!e2[i2]) {
              e2[i2] = 0;
            }
            e2[i2] += 1;
          }
          return e2;
        }
        function aE(t2) {
          const e2 = t2.type === "attribute";
          const i2 = t2.attributeKey;
          return e2 && (i2 === "headingRows" || i2 === "colspan" || i2 === "rowspan");
        }
        function cE(t2) {
          t2.document.registerPostFixer((e2) => lE(e2, t2));
        }
        function lE(t2, e2) {
          const i2 = e2.document.differ.getChanges();
          let n2 = false;
          for (const e3 of i2) {
            if (e3.type == "insert" && e3.name == "table") {
              n2 = dE(e3.position.nodeAfter, t2) || n2;
            }
            if (e3.type == "insert" && e3.name == "tableRow") {
              n2 = uE(e3.position.nodeAfter, t2) || n2;
            }
            if (e3.type == "insert" && e3.name == "tableCell") {
              n2 = hE(e3.position.nodeAfter, t2) || n2;
            }
            if (fE(e3)) {
              n2 = hE(e3.position.parent, t2) || n2;
            }
          }
          return n2;
        }
        function dE(t2, e2) {
          let i2 = false;
          for (const n2 of t2.getChildren()) {
            i2 = uE(n2, e2) || i2;
          }
          return i2;
        }
        function uE(t2, e2) {
          let i2 = false;
          for (const n2 of t2.getChildren()) {
            i2 = hE(n2, e2) || i2;
          }
          return i2;
        }
        function hE(t2, e2) {
          if (t2.childCount == 0) {
            e2.insertElement("paragraph", t2);
            return true;
          }
          const i2 = Array.from(t2.getChildren()).filter((t3) => t3.is("text"));
          for (const t3 of i2) {
            e2.wrap(e2.createRangeOn(t3), "paragraph");
          }
          return !!i2.length;
        }
        function fE(t2) {
          if (!t2.position || !t2.position.parent.is("tableCell")) {
            return false;
          }
          return t2.type == "insert" && t2.name == "$text" || t2.type == "remove";
        }
        function gE(t2) {
          t2.document.registerPostFixer(() => mE(t2));
        }
        function mE(t2) {
          const e2 = t2.document.differ;
          const i2 = new Set();
          for (const t3 of e2.getChanges()) {
            const e3 = t3.type == "insert" || t3.type == "remove" ? t3.position.parent : t3.range.start.parent;
            if (e3.is("tableCell") && pE(e3, t3.type)) {
              i2.add(e3);
            }
          }
          if (i2.size) {
            for (const t3 of i2.values()) {
              e2.refreshItem(t3);
            }
            return true;
          }
          return false;
        }
        function pE(t2, e2) {
          const i2 = Array.from(t2.getChildren()).some((t3) => t3.is("paragraph"));
          if (!i2) {
            return false;
          }
          if (e2 == "attribute") {
            const e3 = Array.from(t2.getChild(0).getAttributeKeys()).length;
            return t2.childCount === 1 && e3 < 2;
          }
          return t2.childCount <= (e2 == "insert" ? 2 : 1);
        }
        var bE = i(92);
        class wE extends mp {
          static get pluginName() {
            return "TableEditing";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model;
            const i2 = e2.schema;
            const n2 = t2.conversion;
            i2.register("table", {
              allowWhere: "$block",
              allowAttributes: ["headingRows", "headingColumns"],
              isLimit: true,
              isObject: true,
              isBlock: true
            });
            i2.register("tableRow", {allowIn: "table", isLimit: true});
            i2.register("tableCell", {allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isObject: true});
            i2.extend("$block", {allowIn: "tableCell"});
            i2.addChildCheck((t3, e3) => {
              if (e3.name == "table" && Array.from(t3.getNames()).includes("table")) {
                return false;
              }
            });
            n2.for("upcast").add(JP());
            n2.for("editingDowncast").add(lS({asWidget: true}));
            n2.for("dataDowncast").add(lS());
            n2.for("upcast").elementToElement({model: "tableRow", view: "tr"});
            n2.for("editingDowncast").add(dS({asWidget: true}));
            n2.for("dataDowncast").add(dS());
            n2.for("downcast").add(gS());
            n2.for("upcast").add(YP("td"));
            n2.for("upcast").add(YP("th"));
            n2.for("editingDowncast").add(uS({asWidget: true}));
            n2.for("dataDowncast").add(uS());
            n2.attributeToAttribute({model: "colspan", view: "colspan"});
            n2.attributeToAttribute({model: "rowspan", view: "rowspan"});
            n2.for("editingDowncast").add(fS({asWidget: true}));
            n2.for("dataDowncast").add(fS());
            n2.for("editingDowncast").add(hS({asWidget: true}));
            n2.for("dataDowncast").add(hS());
            t2.commands.add("insertTable", new SS(t2));
            t2.commands.add("insertTableRowAbove", new RS(t2, {order: "above"}));
            t2.commands.add("insertTableRowBelow", new RS(t2, {order: "below"}));
            t2.commands.add("insertTableColumnLeft", new OS(t2, {order: "left"}));
            t2.commands.add("insertTableColumnRight", new OS(t2, {order: "right"}));
            t2.commands.add("removeTableRow", new FS(t2));
            t2.commands.add("removeTableColumn", new WS(t2));
            t2.commands.add("splitTableCellVertically", new IS(t2, {direction: "vertically"}));
            t2.commands.add("splitTableCellHorizontally", new IS(t2, {direction: "horizontally"}));
            t2.commands.add("mergeTableCellRight", new VS(t2, {direction: "right"}));
            t2.commands.add("mergeTableCellLeft", new VS(t2, {direction: "left"}));
            t2.commands.add("mergeTableCellDown", new VS(t2, {direction: "down"}));
            t2.commands.add("mergeTableCellUp", new VS(t2, {direction: "up"}));
            t2.commands.add("setTableColumnHeader", new YS(t2));
            t2.commands.add("setTableRowHeader", new GS(t2));
            eE(e2);
            gE(e2);
            cE(e2);
            this.editor.keystrokes.set("Tab", (...t3) => this._handleTabOnSelectedTable(...t3), {priority: "low"});
            this.editor.keystrokes.set("Tab", this._getTabHandler(true), {priority: "low"});
            this.editor.keystrokes.set("Shift+Tab", this._getTabHandler(false), {priority: "low"});
          }
          static get requires() {
            return [QS];
          }
          _handleTabOnSelectedTable(t2, e2) {
            const i2 = this.editor;
            const n2 = i2.model.document.selection;
            if (!n2.isCollapsed && n2.rangeCount === 1 && n2.getFirstRange().isFlat) {
              const t3 = n2.getSelectedElement();
              if (!t3 || !t3.is("table")) {
                return;
              }
              e2();
              i2.model.change((e3) => {
                e3.setSelection(e3.createRangeIn(t3.getChild(0).getChild(0)));
              });
            }
          }
          _getTabHandler(t2) {
            const e2 = this.editor;
            return (i2, n2) => {
              const o2 = e2.model.document.selection;
              const r2 = rS(o2)[0];
              if (!r2) {
                return;
              }
              n2();
              const s2 = r2.parent;
              const a2 = s2.parent;
              const c2 = a2.getChildIndex(s2);
              const l2 = s2.getChildIndex(r2);
              const d2 = l2 === 0;
              if (!t2 && d2 && c2 === 0) {
                return;
              }
              const u2 = l2 === s2.childCount - 1;
              const h2 = c2 === a2.childCount - 1;
              if (t2 && h2 && u2) {
                e2.execute("insertTableRowBelow");
                if (c2 === a2.childCount - 1) {
                  return;
                }
              }
              let f2;
              if (t2 && u2) {
                const t3 = a2.getChild(c2 + 1);
                f2 = t3.getChild(0);
              } else if (!t2 && d2) {
                const t3 = a2.getChild(c2 - 1);
                f2 = t3.getChild(t3.childCount - 1);
              } else {
                f2 = s2.getChild(l2 + (t2 ? 1 : -1));
              }
              e2.model.change((t3) => {
                t3.setSelection(t3.createRangeIn(f2));
              });
            };
          }
        }
        var kE = i(94);
        class _E extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.items = this.createCollection();
            this.set("rows", 0);
            this.set("columns", 0);
            this.bind("label").to(this, "columns", this, "rows", (t3, e3) => `${e3} \xD7 ${t3}`);
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck"]},
              children: [{
                tag: "div",
                attributes: {class: ["ck-insert-table-dropdown__grid"]},
                children: this.items
              }, {
                tag: "div",
                attributes: {class: ["ck-insert-table-dropdown__label"]},
                children: [{text: e2.to("label")}]
              }],
              on: {
                mousedown: e2.to((t3) => {
                  t3.preventDefault();
                }),
                click: e2.to(() => {
                  this.fire("execute");
                })
              }
            });
            for (let t3 = 0; t3 < 100; t3++) {
              const e3 = new vE();
              e3.on("over", () => {
                const e4 = Math.floor(t3 / 10);
                const i2 = t3 % 10;
                this.set("rows", e4 + 1);
                this.set("columns", i2 + 1);
              });
              this.items.add(e3);
            }
            this.on("change:columns", () => {
              this._highlightGridBoxes();
            });
            this.on("change:rows", () => {
              this._highlightGridBoxes();
            });
          }
          focus() {
          }
          focusLast() {
          }
          _highlightGridBoxes() {
            const t2 = this.rows;
            const e2 = this.columns;
            this.items.map((i2, n2) => {
              const o2 = Math.floor(n2 / 10);
              const r2 = n2 % 10;
              const s2 = o2 < t2 && r2 < e2;
              i2.set("isOn", s2);
            });
          }
        }
        class vE extends Gp {
          constructor(t2) {
            super(t2);
            const e2 = this.bindTemplate;
            this.set("isOn", false);
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck-insert-table-dropdown-grid-box", e2.if("isOn", "ck-on")]},
              on: {mouseover: e2.to("over")}
            });
          }
        }
        var yE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>';
        var xE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>';
        var CE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>';
        var AE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>';
        class TE extends mp {
          init() {
            const t2 = this.editor;
            const e2 = this.editor.t;
            const i2 = t2.locale.contentLanguageDirection;
            const n2 = i2 === "ltr";
            t2.ui.componentFactory.add("insertTable", (i3) => {
              const n3 = t2.commands.get("insertTable");
              const o2 = Wb(i3);
              o2.bind("isEnabled").to(n3);
              o2.buttonView.set({icon: yE, label: e2("ki"), tooltip: true});
              let r2;
              o2.on("change:isOpen", () => {
                if (r2) {
                  return;
                }
                r2 = new _E(i3);
                o2.panelView.children.add(r2);
                r2.delegate("execute").to(o2);
                o2.buttonView.on("open", () => {
                  r2.rows = 0;
                  r2.columns = 0;
                });
                o2.on("execute", () => {
                  t2.execute("insertTable", {rows: r2.rows, columns: r2.columns});
                  t2.editing.view.focus();
                });
              });
              return o2;
            });
            t2.ui.componentFactory.add("tableColumn", (t3) => {
              const i3 = [{
                type: "switchbutton",
                model: {commandName: "setTableColumnHeader", label: e2("kj"), bindIsOn: true}
              }, {type: "separator"}, {
                type: "button",
                model: {commandName: n2 ? "insertTableColumnLeft" : "insertTableColumnRight", label: e2("kk")}
              }, {
                type: "button",
                model: {commandName: n2 ? "insertTableColumnRight" : "insertTableColumnLeft", label: e2("kl")}
              }, {type: "button", model: {commandName: "removeTableColumn", label: e2("km")}}];
              return this._prepareDropdown(e2("kn"), xE, i3, t3);
            });
            t2.ui.componentFactory.add("tableRow", (t3) => {
              const i3 = [{
                type: "switchbutton",
                model: {commandName: "setTableRowHeader", label: e2("ko"), bindIsOn: true}
              }, {type: "separator"}, {
                type: "button",
                model: {commandName: "insertTableRowBelow", label: e2("kp")}
              }, {type: "button", model: {commandName: "insertTableRowAbove", label: e2("kq")}}, {
                type: "button",
                model: {commandName: "removeTableRow", label: e2("kr")}
              }];
              return this._prepareDropdown(e2("ks"), CE, i3, t3);
            });
            t2.ui.componentFactory.add("mergeTableCells", (t3) => {
              const i3 = [{
                type: "button",
                model: {commandName: "mergeTableCellUp", label: e2("kt")}
              }, {
                type: "button",
                model: {commandName: n2 ? "mergeTableCellRight" : "mergeTableCellLeft", label: e2("ku")}
              }, {type: "button", model: {commandName: "mergeTableCellDown", label: e2("kv")}}, {
                type: "button",
                model: {commandName: n2 ? "mergeTableCellLeft" : "mergeTableCellRight", label: e2("kw")}
              }, {type: "separator"}, {
                type: "button",
                model: {commandName: "splitTableCellVertically", label: e2("kx")}
              }, {type: "button", model: {commandName: "splitTableCellHorizontally", label: e2("ky")}}];
              return this._prepareDropdown(e2("kz"), AE, i3, t3);
            });
          }
          _prepareDropdown(t2, e2, i2, n2) {
            const o2 = this.editor;
            const r2 = Wb(n2);
            const s2 = [];
            const a2 = new ys();
            for (const t3 of i2) {
              PE(t3, o2, s2, a2);
            }
            Ub(r2, a2, o2.ui.componentFactory);
            r2.buttonView.set({label: t2, icon: e2, tooltip: true});
            r2.bind("isEnabled").toMany(s2, "isEnabled", (...t3) => t3.some((t4) => t4));
            this.listenTo(r2, "execute", (t3) => {
              o2.execute(t3.source.commandName);
              o2.editing.view.focus();
            });
            return r2;
          }
        }
        function PE(t2, e2, i2, n2) {
          const o2 = t2.model = new e_(t2.model);
          const {commandName: r2, bindIsOn: s2} = t2.model;
          if (t2.type === "button" || t2.type === "switchbutton") {
            const t3 = e2.commands.get(r2);
            i2.push(t3);
            o2.set({commandName: r2});
            o2.bind("isEnabled").to(t3);
            if (s2) {
              o2.bind("isOn").to(t3, "value");
            }
          }
          o2.set({withText: true});
          n2.add(t2);
        }
        class SE extends Ju {
          constructor(t2) {
            super(t2);
            this.domEventType = ["mousemove", "mouseup", "mouseleave"];
          }
          onDomEvent(t2) {
            this.fire(t2.type, t2);
          }
        }
        function EE(t2, e2, i2) {
          const n2 = Array.from(t2);
          const o2 = n2[0];
          const r2 = n2[n2.length - 1];
          const {row: s2, column: a2} = e2.getCellLocation(o2);
          const c2 = RE(n2, a2, i2, e2);
          const {row: l2, column: d2} = e2.getCellLocation(r2);
          const u2 = d2 - a2 + 1;
          const h2 = l2 - s2 + 1;
          IE(c2, u2, h2, i2, e2);
          const f2 = WP("table", o2);
          VE(c2, f2, s2, a2, i2);
          return c2;
        }
        function RE(t2, e2, i2, n2) {
          const o2 = i2.createElement("table");
          const r2 = new Map();
          const s2 = new Map();
          for (const e3 of t2) {
            const t3 = WP("tableRow", e3);
            if (!r2.has(t3)) {
              const e4 = t3._clone();
              i2.append(e4, o2);
              r2.set(t3, e4);
            }
            const a2 = e3._clone(true);
            const {column: c2} = n2.getCellLocation(e3);
            s2.set(a2, c2);
            i2.append(a2, r2.get(t3));
          }
          OE(o2, e2, s2, i2, n2);
          return o2;
        }
        function OE(t2, e2, i2, n2, o2) {
          for (const r2 of t2.getChildren()) {
            for (const t3 of Array.from(r2.getChildren())) {
              const {column: r3} = o2.getCellLocation(t3);
              const s2 = i2.get(t3);
              const a2 = s2 - e2;
              if (r3 !== a2) {
                for (let e3 = 0; e3 < a2 - r3; e3++) {
                  const e4 = n2.createElement("tableCell");
                  n2.insert(e4, n2.createPositionBefore(t3));
                  const i3 = n2.createElement("paragraph");
                  n2.insert(i3, e4, 0);
                  n2.insertText("", i3, 0);
                }
              }
            }
          }
        }
        function IE(t2, e2, i2, n2, o2) {
          for (const r2 of t2.getChildren()) {
            for (const t3 of r2.getChildren()) {
              const r3 = parseInt(t3.getAttribute("colspan") || 1);
              const s2 = parseInt(t3.getAttribute("rowspan") || 1);
              const {row: a2, column: c2} = o2.getCellLocation(t3);
              if (c2 + r3 > e2) {
                const i3 = e2 - c2;
                if (i3 > 1) {
                  n2.setAttribute("colspan", i3, t3);
                } else {
                  n2.removeAttribute("colspan", t3);
                }
              }
              if (a2 + s2 > i2) {
                const e3 = i2 - a2;
                if (e3 > 1) {
                  n2.setAttribute("rowspan", e3, t3);
                } else {
                  n2.removeAttribute("rowspan", t3);
                }
              }
            }
          }
        }
        function VE(t2, e2, i2, n2, o2) {
          const r2 = parseInt(e2.getAttribute("headingRows") || 0);
          if (r2 > 0) {
            const e3 = r2 - i2;
            o2.setAttribute("headingRows", e3, t2);
          }
          const s2 = parseInt(e2.getAttribute("headingColumns") || 0);
          if (s2 > 0) {
            const e3 = s2 - n2;
            o2.setAttribute("headingColumns", e3, t2);
          }
        }
        var NE = i(96);
        class ME extends mp {
          static get pluginName() {
            return "TableSelection";
          }
          static get requires() {
            return [QS];
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model;
            this.listenTo(e2, "deleteContent", (t3, e3) => this._handleDeleteContent(t3, e3), {priority: "high"});
            t2.editing.view.addObserver(SE);
            this._defineSelectionConverter();
            this._enableShiftClickSelection();
            this._enableMouseDragSelection();
          }
          getSelectedTableCells() {
            const t2 = this.editor.model.document.selection;
            const e2 = oS(t2);
            if (e2.length == 0) {
              return null;
            }
            return e2;
          }
          getSelectionAsFragment() {
            const t2 = this.getSelectedTableCells();
            if (!t2) {
              return null;
            }
            return this.editor.model.change((e2) => {
              const i2 = e2.createDocumentFragment();
              const n2 = EE(t2, this.editor.plugins.get("TableUtils"), e2);
              e2.insert(n2, i2, 0);
              return i2;
            });
          }
          _defineSelectionConverter() {
            const t2 = this.editor;
            const e2 = new Set();
            t2.conversion.for("editingDowncast").add((t3) => t3.on("selection", (t4, n2, o2) => {
              const r2 = o2.writer;
              i2(r2);
              const s2 = this.getSelectedTableCells();
              if (!s2) {
                return;
              }
              for (const t5 of s2) {
                const i3 = o2.mapper.toViewElement(t5);
                r2.addClass("ck-editor__editable_selected", i3);
                e2.add(i3);
              }
              const a2 = o2.mapper.toViewElement(s2[s2.length - 1]);
              r2.setSelection(a2, 0);
            }, {priority: "lowest"}));
            function i2(t3) {
              for (const i3 of e2) {
                t3.removeClass("ck-editor__editable_selected", i3);
              }
              e2.clear();
            }
          }
          _enableShiftClickSelection() {
            const t2 = this.editor;
            let e2 = false;
            this.listenTo(t2.editing.view.document, "mousedown", (i2, n2) => {
              if (!this.isEnabled) {
                return;
              }
              if (!n2.domEvent.shiftKey) {
                return;
              }
              const o2 = rS(t2.model.document.selection)[0];
              if (!o2) {
                return;
              }
              const r2 = this._getModelTableCellFromDomEvent(n2);
              if (r2 && zE(o2, r2)) {
                e2 = true;
                this._setCellSelection(o2, r2);
                n2.preventDefault();
              }
            });
            this.listenTo(t2.editing.view.document, "mouseup", () => {
              e2 = false;
            });
            this.listenTo(t2.editing.view.document, "selectionChange", (t3) => {
              if (e2) {
                t3.stop();
              }
            }, {priority: "highest"});
          }
          _enableMouseDragSelection() {
            const t2 = this.editor;
            let e2, i2;
            let n2 = false;
            let o2 = false;
            this.listenTo(t2.editing.view.document, "mousedown", (t3, i3) => {
              if (!this.isEnabled) {
                return;
              }
              if (i3.domEvent.shiftKey || i3.domEvent.ctrlKey || i3.domEvent.altKey) {
                return;
              }
              e2 = this._getModelTableCellFromDomEvent(i3);
            });
            this.listenTo(t2.editing.view.document, "mousemove", (t3, r2) => {
              if (!r2.domEvent.buttons) {
                return;
              }
              if (!e2) {
                return;
              }
              const s2 = this._getModelTableCellFromDomEvent(r2);
              if (s2 && zE(e2, s2)) {
                i2 = s2;
                if (!n2 && i2 != e2) {
                  n2 = true;
                }
              }
              if (!n2) {
                return;
              }
              o2 = true;
              this._setCellSelection(e2, i2);
              r2.preventDefault();
            });
            this.listenTo(t2.editing.view.document, "mouseup", () => {
              n2 = false;
              o2 = false;
              e2 = null;
              i2 = null;
            });
            this.listenTo(t2.editing.view.document, "selectionChange", (t3) => {
              if (o2) {
                t3.stop();
              }
            }, {priority: "highest"});
          }
          _handleDeleteContent(t2, e2) {
            const [i2, n2] = e2;
            const o2 = this.editor.model;
            const r2 = !n2 || n2.direction == "backward";
            const s2 = oS(i2);
            if (!s2.length) {
              return;
            }
            t2.stop();
            o2.change((t3) => {
              const e3 = s2[r2 ? s2.length - 1 : 0];
              o2.change((t4) => {
                for (const e4 of s2) {
                  o2.deleteContent(t4.createSelection(e4, "in"));
                }
              });
              const n3 = o2.schema.getNearestSelectionRange(t3.createPositionAt(e3, 0));
              if (n3) {
                if (i2.is("documentSelection")) {
                  t3.setSelection(n3);
                } else {
                  i2.setTo(n3);
                }
              }
            });
          }
          _setCellSelection(t2, e2) {
            const i2 = this._getCellsToSelect(t2, e2);
            this.editor.model.change((t3) => {
              t3.setSelection(i2.cells.map((e3) => t3.createRangeOn(e3)), {backward: i2.backward});
            });
          }
          _getModelTableCellFromDomEvent(t2) {
            const e2 = t2.target;
            const i2 = this.editor.editing.view.createPositionAt(e2, 0);
            const n2 = this.editor.editing.mapper.toModelPosition(i2);
            const o2 = n2.parent;
            if (!o2) {
              return;
            }
            if (o2.is("tableCell")) {
              return o2;
            }
            return WP("tableCell", o2);
          }
          _getCellsToSelect(t2, e2) {
            const i2 = this.editor.plugins.get("TableUtils");
            const n2 = i2.getCellLocation(t2);
            const o2 = i2.getCellLocation(e2);
            const r2 = Math.min(n2.row, o2.row);
            const s2 = Math.max(n2.row, o2.row);
            const a2 = Math.min(n2.column, o2.column);
            const c2 = Math.max(n2.column, o2.column);
            const l2 = [];
            for (const e3 of new ZP(WP("table", t2), {startRow: r2, endRow: s2})) {
              if (e3.column >= a2 && e3.column <= c2) {
                l2.push(e3.cell);
              }
            }
            if (BE(n2, o2)) {
              return {cells: l2.reverse(), backward: true};
            }
            return {cells: l2, backward: false};
          }
        }
        function BE(t2, e2) {
          if (t2.row > e2.row) {
            return true;
          }
          if (t2.row == e2.row && t2.column > e2.column) {
            return true;
          }
          return false;
        }
        function zE(t2, e2) {
          return t2.parent.parent == e2.parent.parent;
        }
        class LE extends mp {
          static get pluginName() {
            return "TableClipboard";
          }
          static get requires() {
            return [ME];
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.editing.view.document;
            this.listenTo(e2, "copy", (t3, e3) => this._onCopyCut(t3, e3));
            this.listenTo(e2, "cut", (t3, e3) => this._onCopyCut(t3, e3));
          }
          _onCopyCut(t2, e2) {
            const i2 = this.editor.plugins.get("TableSelection");
            if (!i2.getSelectedTableCells()) {
              return;
            }
            if (t2.name == "cut" && this.editor.isReadOnly) {
              return;
            }
            e2.preventDefault();
            t2.stop();
            const n2 = this.editor.data;
            const o2 = this.editor.editing.view.document;
            const r2 = n2.toView(i2.getSelectionAsFragment());
            o2.fire("clipboardOutput", {dataTransfer: e2.dataTransfer, content: r2, method: t2.name});
          }
        }
        var FE = i(98);
        class DE extends mp {
          static get requires() {
            return [wE, TE, ME, LE, Fv];
          }
          static get pluginName() {
            return "Table";
          }
        }
        var jE = i(100);
        class HE extends Gp {
          constructor(t2, e2) {
            super(t2);
            const i2 = `ck-labeled-view-${is()}`;
            const n2 = `ck-labeled-view-status-${is()}`;
            this.view = e2(this, i2, n2);
            this.set("label");
            this.set("isEnabled", true);
            this.set("errorText", null);
            this.set("infoText", null);
            this.set("class");
            this.labelView = this._createLabelView(i2);
            this.statusView = this._createStatusView(n2);
            this.bind("_statusText").to(this, "errorText", this, "infoText", (t3, e3) => t3 || e3);
            const o2 = this.bindTemplate;
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck", "ck-labeled-view", o2.to("class"), o2.if("isEnabled", "ck-disabled", (t3) => !t3)]},
              children: [this.labelView, this.view, this.statusView]
            });
          }
          _createLabelView(t2) {
            const e2 = new Mk(this.locale);
            e2.for = t2;
            e2.bind("text").to(this, "label");
            return e2;
          }
          _createStatusView(t2) {
            const e2 = new Gp(this.locale);
            const i2 = this.bindTemplate;
            e2.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-labeled-view__status", i2.if("errorText", "ck-labeled-view__status_error"), i2.if("_statusText", "ck-hidden", (t3) => !t3)],
                id: t2,
                role: i2.if("errorText", "alert")
              },
              children: [{text: i2.to("_statusText")}]
            });
            return e2;
          }
          focus() {
            this.view.focus();
          }
        }
        function WE(t2, e2, i2) {
          const n2 = new Yv(t2.locale);
          n2.set({id: e2, ariaDescribedById: i2});
          n2.bind("isReadOnly").to(t2, "isEnabled", (t3) => !t3);
          n2.bind("hasError").to(t2, "errorText", (t3) => !!t3);
          n2.on("input", () => {
            t2.errorText = null;
          });
          return n2;
        }
        function qE(t2, e2, i2) {
          const n2 = Wb(t2.locale);
          n2.set({id: e2, ariaDescribedById: i2});
          n2.bind("isEnabled").to(t2);
          return n2;
        }
        var UE = i(102);
        class $E extends Gp {
          constructor(t2, e2) {
            super(t2);
            const i2 = this.bindTemplate;
            this.set("value", "");
            this.set("id");
            this.set("isReadOnly", false);
            this.set("hasError", false);
            this.set("ariaDescribedById");
            this.options = e2;
            this._dropdownView = this._createDropdownView(t2);
            this._inputView = this._createInputTextView(t2);
            this.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-input-color", i2.if("hasError", "ck-error")],
                id: i2.to("id"),
                "aria-invalid": i2.if("hasError", true),
                "aria-describedby": i2.to("ariaDescribedById")
              },
              children: [this._inputView, this._dropdownView]
            });
          }
          focus() {
            this._inputView.focus();
          }
          _createDropdownView() {
            const t2 = this.locale;
            const e2 = this.bindTemplate;
            const i2 = this._createColorGrid(t2);
            const n2 = Wb(t2);
            const o2 = new Gp();
            const r2 = this._createRemoveColorButton(t2);
            o2.setTemplate({
              tag: "span",
              attributes: {
                class: ["ck", "ck-input-color__button__preview"],
                style: {backgroundColor: e2.to("value")}
              },
              children: [{
                tag: "span",
                attributes: {class: ["ck", "ck-input-color__button__preview__no-color-indicator", e2.if("value", "ck-hidden", (t3) => t3 != "")]}
              }]
            });
            n2.buttonView.extendTemplate({attributes: {class: "ck-input-color__button"}});
            n2.buttonView.children.add(o2);
            n2.panelPosition = t2.uiLanguageDirection === "rtl" ? "se" : "sw";
            n2.panelView.children.add(r2);
            n2.panelView.children.add(i2);
            n2.bind("isEnabled").to(this, "isReadOnly", (t3) => !t3);
            return n2;
          }
          _createInputTextView() {
            const t2 = this.locale;
            const e2 = new Yv(t2);
            e2.bind("value").to(this);
            e2.bind("isReadOnly").to(this);
            e2.bind("hasError").to(this);
            e2.on("input", () => {
              this.value = e2.element.value;
            });
            e2.delegate("input").to(this);
            return e2;
          }
          _createRemoveColorButton() {
            const t2 = this.locale;
            const e2 = t2.t;
            const i2 = new hb(t2);
            i2.class = "ck-input-color__remove-color";
            i2.withText = true;
            i2.icon = zk;
            i2.label = e2("li");
            i2.on("execute", () => {
              this.value = "";
              this._dropdownView.isOpen = false;
              this.fire("input");
            });
            return i2;
          }
          _createColorGrid(t2) {
            const e2 = new Vk(t2, {colorDefinitions: this.options.colorDefinitions, columns: this.options.columns});
            e2.on("execute", (t3, e3) => {
              this.value = e3.value;
              this._dropdownView.isOpen = false;
              this.fire("input");
            });
            e2.bind("selectedColor").to(this, "value");
            return e2;
          }
        }
        const GE = nb.defaultPositions;
        const KE = [GE.northArrowSouth, GE.northArrowSouthWest, GE.northArrowSouthEast, GE.southArrowNorth, GE.southArrowNorthWest, GE.southArrowNorthEast];
        const JE = (t2) => t2 === "";
        function YE(t2, e2) {
          const i2 = t2.plugins.get("ContextualBalloon");
          if (nS(t2.editing.view.document.selection)) {
            let n2;
            if (e2 === "cell") {
              n2 = XE(t2);
            } else {
              n2 = QE(t2);
            }
            i2.updatePosition(n2);
          }
        }
        function QE(t2) {
          const e2 = t2.model.document.selection.getFirstPosition();
          const i2 = WP("table", e2);
          const n2 = t2.editing.mapper.toViewElement(i2);
          return {target: t2.editing.view.domConverter.viewToDom(n2), positions: KE};
        }
        function XE(t2) {
          const e2 = uR(t2.model.document.selection.getFirstPosition());
          const i2 = t2.editing.mapper.toViewElement(e2);
          return {target: t2.editing.view.domConverter.viewToDom(i2), positions: KE};
        }
        function ZE(t2) {
          return {
            none: t2("mq"),
            solid: t2("mr"),
            dotted: t2("ms"),
            dashed: t2("mt"),
            double: t2("mu"),
            groove: t2("mv"),
            ridge: t2("mw"),
            inset: t2("mx"),
            outset: t2("my")
          };
        }
        function tR(t2) {
          return t2("mz");
        }
        function eR(t2) {
          return t2("na");
        }
        function iR(t2) {
          t2 = t2.trim();
          return JE(t2) || tC(t2);
        }
        function nR(t2) {
          t2 = t2.trim();
          return JE(t2) || lR(t2) || oC(t2) || sC(t2);
        }
        function oR(t2) {
          t2 = t2.trim();
          return JE(t2) || lR(t2) || oC(t2);
        }
        function rR(t2) {
          const e2 = new ys();
          const i2 = ZE(t2.t);
          for (const n2 in i2) {
            const o2 = {
              type: "button",
              model: new e_({_borderStyleValue: n2 === "none" ? "" : n2, label: i2[n2], withText: true})
            };
            if (n2 === "none") {
              o2.model.bind("isOn").to(t2, "borderStyle", (t3) => !t3);
            } else {
              o2.model.bind("isOn").to(t2, "borderStyle", (t3) => t3 === n2);
            }
            e2.add(o2);
          }
          return e2;
        }
        function sR({view: t2, icons: e2, toolbar: i2, labels: n2, propertyName: o2, nameToValue: r2}) {
          for (const s2 in n2) {
            const a2 = new hb(t2.locale);
            a2.set({label: n2[s2], icon: e2[s2]});
            a2.bind("isOn").to(t2, o2, (t3) => t3 === r2(s2));
            a2.on("execute", () => {
              t2[o2] = r2(s2);
            });
            i2.items.add(a2);
          }
        }
        const aR = [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
          color: "hsl(0, 0%, 30%)",
          label: "Dim grey"
        }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
          color: "hsl(0, 0%, 90%)",
          label: "Light grey"
        }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true}, {
          color: "hsl(0, 75%, 60%)",
          label: "Red"
        }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
          color: "hsl(60, 75%, 60%)",
          label: "Yellow"
        }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
          color: "hsl(120, 75%, 60%)",
          label: "Green"
        }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
          color: "hsl(180, 75%, 60%)",
          label: "Turquoise"
        }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
          color: "hsl(240, 75%, 60%)",
          label: "Blue"
        }, {color: "hsl(270, 75%, 60%)", label: "Purple"}];
        function cR(t2) {
          return (e2, i2, n2) => {
            const o2 = new $E(e2.locale, {colorDefinitions: dR(t2.colorConfig), columns: t2.columns});
            o2.set({id: i2, ariaDescribedById: n2});
            o2.bind("isReadOnly").to(e2, "isEnabled", (t3) => !t3);
            o2.bind("errorText").to(e2);
            o2.on("input", () => {
              e2.errorText = null;
            });
            return o2;
          };
        }
        function lR(t2) {
          const e2 = parseFloat(t2);
          return !Number.isNaN(e2) && t2 === String(e2);
        }
        function dR(t2) {
          return t2.map((t3) => ({color: t3.model, label: t3.label, options: {hasBorder: t3.hasBorder}}));
        }
        function uR(t2) {
          const e2 = t2.nodeAfter && t2.nodeAfter.is("tableCell");
          return e2 ? t2.nodeAfter : WP("tableCell", t2);
        }
        var hR = i(104);
        class fR extends Gp {
          constructor(t2, e2 = {}) {
            super(t2);
            const i2 = this.bindTemplate;
            this.set("class", e2.class || null);
            this.children = this.createCollection();
            if (e2.children) {
              e2.children.forEach((t3) => this.children.add(t3));
            }
            this.set("_role", null);
            this.set("_ariaLabelledBy", null);
            if (e2.labelView) {
              this.set({_role: "group", _ariaLabelledBy: e2.labelView.id});
            }
            this.setTemplate({
              tag: "div",
              attributes: {
                class: ["ck", "ck-form__row", i2.to("class")],
                role: i2.to("_role"),
                "aria-labelledby": i2.to("_ariaLabelledBy")
              },
              children: this.children
            });
          }
        }
        var gR = i(106);
        class mR extends Gp {
          constructor(t2, e2 = {}) {
            super(t2);
            const i2 = this.bindTemplate;
            this.children = this.createCollection();
            this.set("class", e2.class || null);
            this.set("label", e2.label || "");
            const n2 = new Gp(t2);
            n2.setTemplate({
              tag: "span",
              attributes: {class: ["ck", "ck-form__header__label"]},
              children: [{text: i2.to("label")}]
            });
            this.children.add(n2);
            this.setTemplate({
              tag: "div",
              attributes: {class: ["ck", "ck-form__header", i2.to("class")]},
              children: this.children
            });
          }
        }
        var pR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.261 7.062l2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
        var bR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
        var wR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.239 13.938l-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
        var kR = i(12);
        var _R = i(13);
        var vR = i(110);
        const yR = {left: Zw, center: ek, right: tk, justify: ik, top: pR, middle: bR, bottom: wR};
        class xR extends Gp {
          constructor(t2, e2) {
            super(t2);
            this.set({
              borderStyle: "",
              borderWidth: "",
              borderColor: "",
              padding: "",
              backgroundColor: "",
              width: "",
              height: "",
              horizontalAlignment: "",
              verticalAlignment: ""
            });
            this.options = e2;
            const {borderStyleDropdown: i2, borderWidthInput: n2, borderColorInput: o2, borderRowLabel: r2} = this._createBorderFields();
            const {widthInput: s2, operatorLabel: a2, heightInput: c2, dimensionsLabel: l2} = this._createDimensionFields();
            const {horizontalAlignmentToolbar: d2, verticalAlignmentToolbar: u2, alignmentLabel: h2} = this._createAlignmentFields();
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this.children = this.createCollection();
            this.borderStyleDropdown = i2;
            this.borderWidthInput = n2;
            this.borderColorInput = o2;
            this.backgroundInput = this._createBackgroundField();
            this.paddingInput = this._createPaddingField();
            this.widthInput = s2;
            this.heightInput = c2;
            this.horizontalAlignmentToolbar = d2;
            this.verticalAlignmentToolbar = u2;
            const {saveButtonView: f2, cancelButtonView: g2} = this._createActionButtons();
            this.saveButtonView = f2;
            this.cancelButtonView = g2;
            this._focusables = new bp();
            this._focusCycler = new yb({
              focusables: this._focusables,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: "shift + tab", focusNext: "tab"}
            });
            this.children.add(new mR(t2, {label: this.t("\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u044F\u0447\u0435\u0439\u043A\u0438")}));
            this.children.add(new fR(t2, {
              labelView: r2,
              children: [r2, i2, o2, n2],
              class: "ck-table-form__border-row"
            }));
            this.children.add(new fR(t2, {children: [this.backgroundInput]}));
            this.children.add(new fR(t2, {
              children: [new fR(t2, {
                labelView: l2,
                children: [l2, s2, a2, c2],
                class: "ck-table-form__dimensions-row"
              }), new fR(t2, {children: [this.paddingInput], class: "ck-table-cell-properties-form__padding-row"})]
            }));
            this.children.add(new fR(t2, {
              labelView: h2,
              children: [h2, d2, u2],
              class: "ck-table-cell-properties-form__alignment-row"
            }));
            this.children.add(new fR(t2, {
              children: [this.saveButtonView, this.cancelButtonView],
              class: "ck-table-form__action-row"
            }));
            this.setTemplate({
              tag: "form",
              attributes: {
                class: ["ck", "ck-form", "ck-table-form", "ck-table-cell-properties-form"],
                tabindex: "-1"
              },
              children: this.children
            });
          }
          render() {
            super.render();
            Qv({view: this});
            [this.borderStyleDropdown, this.borderColorInput, this.borderWidthInput, this.backgroundInput, this.widthInput, this.heightInput, this.paddingInput, this.horizontalAlignmentToolbar, this.verticalAlignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t2) => {
              this._focusables.add(t2);
              this.focusTracker.add(t2.element);
            });
            this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createBorderFields() {
            const t2 = cR({colorConfig: this.options.borderColors, columns: 5});
            const e2 = this.locale;
            const i2 = this.t;
            const n2 = new Mk(e2);
            n2.text = i2("nb");
            const o2 = ZE(i2);
            const r2 = new HE(e2, qE);
            r2.set({label: i2("nc"), class: "ck-table-form__border-style"});
            r2.view.buttonView.set({isOn: false, withText: true, tooltip: i2("nc")});
            r2.view.buttonView.bind("label").to(this, "borderStyle", (t3) => o2[t3 ? t3 : "none"]);
            r2.view.on("execute", (t3) => {
              this.borderStyle = t3.source._borderStyleValue;
            });
            Ub(r2.view, rR(this));
            const s2 = new HE(e2, WE);
            s2.set({label: i2("nd"), class: "ck-table-form__border-width"});
            s2.view.bind("value").to(this, "borderWidth");
            s2.bind("isEnabled").to(this, "borderStyle", CR);
            s2.view.on("input", () => {
              this.borderWidth = s2.view.element.value;
            });
            const a2 = new HE(e2, t2);
            a2.set({label: i2("ne"), class: "ck-table-form__border-color"});
            a2.view.bind("value").to(this, "borderColor");
            a2.bind("isEnabled").to(this, "borderStyle", CR);
            a2.view.on("input", () => {
              this.borderColor = a2.view.value;
            });
            this.on("change:borderStyle", (t3, e3, i3) => {
              if (!CR(i3)) {
                this.borderColor = "";
                this.borderWidth = "";
              }
            });
            return {borderRowLabel: n2, borderStyleDropdown: r2, borderColorInput: a2, borderWidthInput: s2};
          }
          _createBackgroundField() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = cR({colorConfig: this.options.backgroundColors, columns: 5});
            const n2 = new HE(t2, i2);
            n2.set({label: e2("nf"), class: "ck-table-cell-properties-form__background"});
            n2.view.bind("value").to(this, "backgroundColor");
            n2.view.on("input", () => {
              this.backgroundColor = n2.view.value;
            });
            return n2;
          }
          _createDimensionFields() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = new Mk(t2);
            i2.text = e2("ng");
            const n2 = new HE(t2, WE);
            n2.set({label: e2("nd"), class: "ck-table-form__dimensions-row__width"});
            n2.view.bind("value").to(this, "width");
            n2.view.on("input", () => {
              this.width = n2.view.element.value;
            });
            const o2 = new Gp(t2);
            o2.setTemplate({
              tag: "span",
              attributes: {class: ["ck-table-form__dimension-operator"]},
              children: [{text: "\xD7"}]
            });
            const r2 = new HE(t2, WE);
            r2.set({label: e2("nh"), class: "ck-table-form__dimensions-row__height"});
            r2.view.bind("value").to(this, "height");
            r2.view.on("input", () => {
              this.height = r2.view.element.value;
            });
            return {dimensionsLabel: i2, widthInput: n2, operatorLabel: o2, heightInput: r2};
          }
          _createPaddingField() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = new HE(t2, WE);
            i2.set({label: e2("ni"), class: "ck-table-cell-properties-form__padding"});
            i2.view.bind("value").to(this, "padding");
            i2.view.on("input", () => {
              this.padding = i2.view.element.value;
            });
            return i2;
          }
          _createAlignmentFields() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = new Mk(t2);
            i2.text = e2("nj");
            const n2 = new Xb(t2);
            const o2 = this.locale.contentLanguageDirection === "rtl";
            n2.set({isCompact: true, ariaLabel: e2("nk")});
            sR({
              view: this,
              icons: yR,
              toolbar: n2,
              labels: this._horizontalAlignmentLabels,
              propertyName: "horizontalAlignment",
              nameToValue: (t3) => t3 === (o2 ? "right" : "left") ? "" : t3
            });
            const r2 = new Xb(t2);
            r2.set({isCompact: true, ariaLabel: e2("nl")});
            sR({
              view: this,
              icons: yR,
              toolbar: r2,
              labels: this._verticalAlignmentLabels,
              propertyName: "verticalAlignment",
              nameToValue: (t3) => t3 === "middle" ? "" : t3
            });
            return {horizontalAlignmentToolbar: n2, verticalAlignmentToolbar: r2, alignmentLabel: i2};
          }
          _createActionButtons() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = new hb(t2);
            const n2 = new hb(t2);
            const o2 = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.paddingInput];
            i2.set({label: e2("lo"), icon: Xv, class: "ck-button-save", type: "submit", withText: true});
            i2.bind("isEnabled").toMany(o2, "errorText", (...t3) => t3.every((t4) => !t4));
            n2.set({label: e2("lp"), icon: Zv, class: "ck-button-cancel", type: "cancel", withText: true});
            n2.delegate("execute").to(this, "cancel");
            return {saveButtonView: i2, cancelButtonView: n2};
          }
          get _horizontalAlignmentLabels() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = e2("nm");
            const n2 = e2("nn");
            const o2 = e2("no");
            const r2 = e2("np");
            if (t2.uiLanguageDirection === "rtl") {
              return {right: o2, center: n2, left: i2, justify: r2};
            } else {
              return {left: i2, center: n2, right: o2, justify: r2};
            }
          }
          get _verticalAlignmentLabels() {
            const t2 = this.t;
            return {top: t2("nq"), middle: t2("nr"), bottom: t2("ns")};
          }
        }
        function CR(t2) {
          return !!t2;
        }
        var AR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.105 18l-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="M15.5 11.5l1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>';
        const TR = 500;
        class PR extends mp {
          static get requires() {
            return [kb];
          }
          static get pluginName() {
            return "TableCellPropertiesUI";
          }
          constructor(t2) {
            super(t2);
            t2.config.define("table.tableCellProperties", {borderColors: aR, backgroundColors: aR});
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            this._balloon = t2.plugins.get(kb);
            this.view = this._createPropertiesView();
            this._undoStepBatch = null;
            t2.ui.componentFactory.add("tableCellProperties", (t3) => {
              const i2 = new hb(t3);
              i2.set({label: e2("kh"), icon: AR, tooltip: true});
              this.listenTo(i2, "execute", () => this._showView());
              return i2;
            });
          }
          destroy() {
            super.destroy();
            this.view.destroy();
          }
          _createPropertiesView() {
            const t2 = this.editor;
            const e2 = t2.editing.view.document;
            const i2 = t2.config.get("table.tableCellProperties");
            const n2 = __(i2.borderColors);
            const o2 = k_(t2.locale, n2);
            const r2 = __(i2.backgroundColors);
            const s2 = k_(t2.locale, r2);
            const a2 = new xR(t2.locale, {borderColors: o2, backgroundColors: s2});
            const c2 = t2.t;
            a2.render();
            this.listenTo(a2, "submit", () => {
              this._hideView();
            });
            this.listenTo(a2, "cancel", () => {
              if (this._undoStepBatch.operations.length) {
                t2.execute("undo", this._undoStepBatch);
              }
              this._hideView();
            });
            a2.keystrokes.set("Esc", (t3, e3) => {
              this._hideView();
              e3();
            });
            this.listenTo(t2.ui, "update", () => {
              if (!nS(e2.selection)) {
                this._hideView();
              } else if (this._isViewVisible) {
                YE(t2, "cell");
              }
            });
            Db({
              emitter: a2,
              activator: () => this._isViewInBalloon,
              contextElements: [this._balloon.view.element],
              callback: () => this._hideView()
            });
            const l2 = tR(c2);
            const d2 = eR(c2);
            a2.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle"));
            a2.on("change:borderColor", this._getValidatedPropertyChangeCallback({
              viewField: a2.borderColorInput,
              commandName: "tableCellBorderColor",
              errorText: l2,
              validator: iR
            }));
            a2.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
              viewField: a2.borderWidthInput,
              commandName: "tableCellBorderWidth",
              errorText: d2,
              validator: oR
            }));
            a2.on("change:padding", this._getValidatedPropertyChangeCallback({
              viewField: a2.paddingInput,
              commandName: "tableCellPadding",
              errorText: d2,
              validator: nR
            }));
            a2.on("change:width", this._getValidatedPropertyChangeCallback({
              viewField: a2.widthInput,
              commandName: "tableCellWidth",
              errorText: d2,
              validator: nR
            }));
            a2.on("change:height", this._getValidatedPropertyChangeCallback({
              viewField: a2.heightInput,
              commandName: "tableCellHeight",
              errorText: d2,
              validator: nR
            }));
            a2.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
              viewField: a2.backgroundInput,
              commandName: "tableCellBackgroundColor",
              errorText: l2,
              validator: iR
            }));
            a2.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment"));
            a2.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment"));
            return a2;
          }
          _fillViewFormFromCommandValues() {
            const t2 = this.editor.commands;
            this.view.set({
              borderStyle: t2.get("tableCellBorderStyle").value || "",
              borderColor: t2.get("tableCellBorderColor").value || "",
              borderWidth: t2.get("tableCellBorderWidth").value || "",
              width: t2.get("tableCellWidth").value || "",
              height: t2.get("tableCellHeight").value || "",
              padding: t2.get("tableCellPadding").value || "",
              backgroundColor: t2.get("tableCellBackgroundColor").value || "",
              horizontalAlignment: t2.get("tableCellHorizontalAlignment").value || "",
              verticalAlignment: t2.get("tableCellVerticalAlignment").value || ""
            });
          }
          _showView() {
            const t2 = this.editor;
            this._balloon.add({view: this.view, position: XE(t2)});
            this._undoStepBatch = t2.model.createBatch();
            this._fillViewFormFromCommandValues();
            this.view.focus();
          }
          _hideView() {
            if (!this._isViewInBalloon) {
              return;
            }
            const t2 = this.editor;
            this.stopListening(t2.ui, "update");
            this.view.saveButtonView.focus();
            this._balloon.remove(this.view);
            this.editor.editing.view.focus();
          }
          get _isViewVisible() {
            return this._balloon.visibleView === this.view;
          }
          get _isViewInBalloon() {
            return this._balloon.hasView(this.view);
          }
          _getPropertyChangeCallback(t2) {
            return (e2, i2, n2) => {
              this.editor.execute(t2, {value: n2, batch: this._undoStepBatch});
            };
          }
          _getValidatedPropertyChangeCallback({commandName: t2, viewField: e2, validator: i2, errorText: n2}) {
            const o2 = uh(() => {
              e2.errorText = n2;
            }, TR);
            return (n3, r2, s2) => {
              o2.cancel();
              if (i2(s2)) {
                this.editor.execute(t2, {value: s2, batch: this._undoStepBatch});
                e2.errorText = null;
              } else {
                o2();
              }
            };
          }
        }
        function SR(t2) {
          t2.setNormalizer("border", ER);
          t2.setNormalizer("border-top", RR("top"));
          t2.setNormalizer("border-right", RR("right"));
          t2.setNormalizer("border-bottom", RR("bottom"));
          t2.setNormalizer("border-left", RR("left"));
          t2.setNormalizer("border-color", OR("color"));
          t2.setNormalizer("border-width", OR("width"));
          t2.setNormalizer("border-style", OR("style"));
          t2.setNormalizer("border-top-color", VR("color", "top"));
          t2.setNormalizer("border-top-style", VR("style", "top"));
          t2.setNormalizer("border-top-width", VR("width", "top"));
          t2.setNormalizer("border-right-color", VR("color", "right"));
          t2.setNormalizer("border-right-style", VR("style", "right"));
          t2.setNormalizer("border-right-width", VR("width", "right"));
          t2.setNormalizer("border-bottom-color", VR("color", "bottom"));
          t2.setNormalizer("border-bottom-style", VR("style", "bottom"));
          t2.setNormalizer("border-bottom-width", VR("width", "bottom"));
          t2.setNormalizer("border-left-color", VR("color", "left"));
          t2.setNormalizer("border-left-style", VR("style", "left"));
          t2.setNormalizer("border-left-width", VR("width", "left"));
          t2.setExtractor("border-top", NR("top"));
          t2.setExtractor("border-right", NR("right"));
          t2.setExtractor("border-bottom", NR("bottom"));
          t2.setExtractor("border-left", NR("left"));
          t2.setExtractor("border-top-color", "border.color.top");
          t2.setExtractor("border-right-color", "border.color.right");
          t2.setExtractor("border-bottom-color", "border.color.bottom");
          t2.setExtractor("border-left-color", "border.color.left");
          t2.setExtractor("border-top-width", "border.width.top");
          t2.setExtractor("border-right-width", "border.width.right");
          t2.setExtractor("border-bottom-width", "border.width.bottom");
          t2.setExtractor("border-left-width", "border.width.left");
          t2.setExtractor("border-top-style", "border.style.top");
          t2.setExtractor("border-right-style", "border.style.right");
          t2.setExtractor("border-bottom-style", "border.style.bottom");
          t2.setExtractor("border-left-style", "border.style.left");
          t2.setReducer("border-color", pC("border-color"));
          t2.setReducer("border-style", pC("border-style"));
          t2.setReducer("border-width", pC("border-width"));
          t2.setReducer("border-top", LR("top"));
          t2.setReducer("border-right", LR("right"));
          t2.setReducer("border-bottom", LR("bottom"));
          t2.setReducer("border-left", LR("left"));
          t2.setReducer("border", zR);
          t2.setStyleRelation("border", ["border-color", "border-style", "border-width", "border-top", "border-right", "border-bottom", "border-left", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]);
          t2.setStyleRelation("border-color", ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"]);
          t2.setStyleRelation("border-style", ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"]);
          t2.setStyleRelation("border-width", ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]);
          t2.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]);
          t2.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]);
          t2.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]);
          t2.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"]);
        }
        function ER(t2) {
          const {color: e2, style: i2, width: n2} = BR(t2);
          return {path: "border", value: {color: mC(e2), style: mC(i2), width: mC(n2)}};
        }
        function RR(t2) {
          return (e2) => {
            const {color: i2, style: n2, width: o2} = BR(e2);
            const r2 = {};
            if (i2 !== void 0) {
              r2.color = {[t2]: i2};
            }
            if (n2 !== void 0) {
              r2.style = {[t2]: n2};
            }
            if (o2 !== void 0) {
              r2.width = {[t2]: o2};
            }
            return {path: "border", value: r2};
          };
        }
        function OR(t2) {
          return (e2) => ({path: "border", value: IR(e2, t2)});
        }
        function IR(t2, e2) {
          return {[e2]: mC(t2)};
        }
        function VR(t2, e2) {
          return (i2) => ({path: "border", value: {[t2]: {[e2]: i2}}});
        }
        function NR(t2) {
          return (e2, i2) => {
            if (i2.border) {
              return MR(i2.border, t2);
            }
          };
        }
        function MR(t2, e2) {
          const i2 = {};
          if (t2.width && t2.width[e2]) {
            i2.width = t2.width[e2];
          }
          if (t2.style && t2.style[e2]) {
            i2.style = t2.style[e2];
          }
          if (t2.color && t2.color[e2]) {
            i2.color = t2.color[e2];
          }
          return i2;
        }
        function BR(t2) {
          const e2 = {};
          const i2 = kC(t2);
          for (const t3 of i2) {
            if (oC(t3) || /thin|medium|thick/.test(t3)) {
              e2.width = t3;
            } else if (iC(t3)) {
              e2.style = t3;
            } else {
              e2.color = t3;
            }
          }
          return e2;
        }
        function zR(t2) {
          const e2 = [];
          e2.push(...FR(MR(t2, "top"), "top"));
          e2.push(...FR(MR(t2, "right"), "right"));
          e2.push(...FR(MR(t2, "bottom"), "bottom"));
          e2.push(...FR(MR(t2, "left"), "left"));
          return e2;
        }
        function LR(t2) {
          return (e2) => FR(e2, t2);
        }
        function FR(t2, e2) {
          const i2 = [];
          if (t2 && t2.width !== void 0) {
            i2.push(t2.width);
          }
          if (t2 && t2.style !== void 0) {
            i2.push(t2.style);
          }
          if (t2 && t2.color !== void 0) {
            i2.push(t2.color);
          }
          if (i2.length) {
            return [[`border-${e2}`, i2.join(" ")]];
          }
          return [];
        }
        function DR(t2) {
          t2.setNormalizer("padding", wC("padding"));
          t2.setNormalizer("padding-top", (t3) => ({path: "padding.top", value: t3}));
          t2.setNormalizer("padding-right", (t3) => ({path: "padding.right", value: t3}));
          t2.setNormalizer("padding-bottom", (t3) => ({path: "padding.bottom", value: t3}));
          t2.setNormalizer("padding-left", (t3) => ({path: "padding.left", value: t3}));
          t2.setReducer("padding", pC("padding"));
          t2.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"]);
        }
        function jR(t2) {
          t2.setNormalizer("background", HR);
          t2.setNormalizer("background-color", (t3) => ({path: "background.color", value: t3}));
          t2.setReducer("background", (t3) => {
            const e2 = [];
            e2.push(["background-color", t3.color]);
            return e2;
          });
        }
        function HR(t2) {
          const e2 = {};
          const i2 = kC(t2);
          for (const t3 of i2) {
            if (cC(t3)) {
              e2.repeat = e2.repeat || [];
              e2.repeat.push(t3);
            } else if (dC(t3)) {
              e2.position = e2.position || [];
              e2.position.push(t3);
            } else if (hC(t3)) {
              e2.attachment = t3;
            } else if (tC(t3)) {
              e2.color = t3;
            } else if (gC(t3)) {
              e2.image = t3;
            }
          }
          return {path: "background", value: e2};
        }
        function WR(t2, e2, i2, n2) {
          t2.for("upcast").attributeToAttribute({
            view: {styles: {[n2]: /[\s\S]+/}},
            model: {name: e2, key: i2, value: (t3) => t3.getNormalizedStyle(n2)}
          });
        }
        function qR(t2, e2) {
          t2.for("upcast").add((t3) => t3.on("element:" + e2, (t4, e3, i2) => {
            const n2 = ["border-top", "border-right", "border-bottom", "border-left"].filter((t5) => e3.viewItem.hasStyle(t5));
            if (!n2.length) {
              return;
            }
            const o2 = {styles: n2};
            if (!i2.consumable.test(e3.viewItem, o2)) {
              return;
            }
            if (!e3.modelRange) {
              e3 = Object.assign(e3, i2.convertChildren(e3.viewItem, e3.modelCursor));
            }
            const r2 = [...e3.modelRange.getItems({shallow: true})].pop();
            i2.consumable.consume(e3.viewItem, o2);
            i2.writer.setAttribute("borderStyle", e3.viewItem.getNormalizedStyle("border-style"), r2);
            i2.writer.setAttribute("borderColor", e3.viewItem.getNormalizedStyle("border-color"), r2);
            i2.writer.setAttribute("borderWidth", e3.viewItem.getNormalizedStyle("border-width"), r2);
          }));
        }
        function UR(t2, e2, i2, n2) {
          t2.for("downcast").attributeToAttribute({
            model: {name: e2, key: i2},
            view: (t3) => ({key: "style", value: {[n2]: t3}})
          });
        }
        function $R(t2, e2, i2) {
          t2.for("downcast").add((t3) => t3.on(`attribute:${e2}:table`, (t4, e3, n2) => {
            const {item: o2, attributeNewValue: r2} = e3;
            const {mapper: s2, writer: a2} = n2;
            if (!n2.consumable.consume(e3.item, t4.name)) {
              return;
            }
            const c2 = [...s2.toViewElement(o2).getChildren()].find((t5) => t5.is("table"));
            if (r2) {
              a2.setStyle(i2, r2, c2);
            } else {
              a2.removeStyle(i2, c2);
            }
          }));
        }
        class GR extends jw {
          constructor(t2, e2) {
            super(t2);
            this.attributeName = e2;
          }
          refresh() {
            const t2 = this.editor;
            const e2 = sS(t2.model.document.selection);
            this.isEnabled = !!e2.length;
            this.value = this._getSingleValue(e2);
          }
          execute(t2 = {}) {
            const {value: e2, batch: i2} = t2;
            const n2 = this.editor.model;
            const o2 = sS(n2.document.selection);
            const r2 = this._getValueToSet(e2);
            n2.enqueueChange(i2 || "default", (t3) => {
              if (r2) {
                o2.forEach((e3) => t3.setAttribute(this.attributeName, r2, e3));
              } else {
                o2.forEach((e3) => t3.removeAttribute(this.attributeName, e3));
              }
            });
          }
          _getAttribute(t2) {
            if (!t2) {
              return;
            }
            return t2.getAttribute(this.attributeName);
          }
          _getValueToSet(t2) {
            return t2;
          }
          _getSingleValue(t2) {
            const e2 = this._getAttribute(t2[0]);
            const i2 = t2.every((t3) => this._getAttribute(t3) === e2);
            return i2 ? e2 : void 0;
          }
        }
        class KR extends GR {
          constructor(t2) {
            super(t2, "padding");
          }
          _getAttribute(t2) {
            if (!t2) {
              return;
            }
            return $P(t2.getAttribute(this.attributeName));
          }
          _getValueToSet(t2) {
            return GP(t2, "px");
          }
        }
        class JR extends GR {
          constructor(t2) {
            super(t2, "width");
          }
          _getValueToSet(t2) {
            return GP(t2, "px");
          }
        }
        class YR extends GR {
          constructor(t2) {
            super(t2, "height");
          }
          _getValueToSet(t2) {
            return GP(t2, "px");
          }
        }
        class QR extends GR {
          constructor(t2) {
            super(t2, "backgroundColor");
          }
        }
        class XR extends GR {
          constructor(t2) {
            super(t2, "verticalAlignment");
          }
        }
        class ZR extends GR {
          constructor(t2) {
            super(t2, "horizontalAlignment");
          }
        }
        class tO extends GR {
          constructor(t2) {
            super(t2, "borderStyle");
          }
          _getAttribute(t2) {
            if (!t2) {
              return;
            }
            return $P(t2.getAttribute(this.attributeName));
          }
        }
        class eO extends GR {
          constructor(t2) {
            super(t2, "borderColor");
          }
          _getAttribute(t2) {
            if (!t2) {
              return;
            }
            return $P(t2.getAttribute(this.attributeName));
          }
        }
        class iO extends GR {
          constructor(t2) {
            super(t2, "borderWidth");
          }
          _getAttribute(t2) {
            if (!t2) {
              return;
            }
            return $P(t2.getAttribute(this.attributeName));
          }
          _getValueToSet(t2) {
            return GP(t2, "px");
          }
        }
        const nO = /^(top|bottom)$/;
        class oO extends mp {
          static get pluginName() {
            return "TableCellPropertiesEditing";
          }
          static get requires() {
            return [wE];
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.schema;
            const i2 = t2.conversion;
            t2.data.addStyleProcessorRules(SR);
            rO(e2, i2);
            t2.commands.add("tableCellBorderStyle", new tO(t2));
            t2.commands.add("tableCellBorderColor", new eO(t2));
            t2.commands.add("tableCellBorderWidth", new iO(t2));
            sO(e2, i2);
            t2.commands.add("tableCellHorizontalAlignment", new ZR(t2));
            cO(e2, i2, "width", "width");
            t2.commands.add("tableCellWidth", new JR(t2));
            cO(e2, i2, "height", "height");
            t2.commands.add("tableCellHeight", new YR(t2));
            t2.data.addStyleProcessorRules(DR);
            cO(e2, i2, "padding", "padding");
            t2.commands.add("tableCellPadding", new KR(t2));
            t2.data.addStyleProcessorRules(jR);
            cO(e2, i2, "backgroundColor", "background-color");
            t2.commands.add("tableCellBackgroundColor", new QR(t2));
            aO(e2, i2);
            t2.commands.add("tableCellVerticalAlignment", new XR(t2));
          }
        }
        function rO(t2, e2) {
          t2.extend("tableCell", {allowAttributes: ["borderWidth", "borderColor", "borderStyle"]});
          qR(e2, "td");
          qR(e2, "th");
          UR(e2, "tableCell", "borderStyle", "border-style");
          UR(e2, "tableCell", "borderColor", "border-color");
          UR(e2, "tableCell", "borderWidth", "border-width");
        }
        function sO(t2, e2) {
          t2.extend("tableCell", {allowAttributes: ["horizontalAlignment"]});
          e2.attributeToAttribute({
            model: {
              name: "tableCell",
              key: "horizontalAlignment",
              values: ["right", "center", "justify"]
            },
            view: {
              right: {key: "style", value: {"text-align": "right"}},
              center: {key: "style", value: {"text-align": "center"}},
              justify: {key: "style", value: {"text-align": "justify"}}
            }
          });
        }
        function aO(t2, e2) {
          t2.extend("tableCell", {allowAttributes: ["verticalAlignment"]});
          e2.attributeToAttribute({
            model: {name: "tableCell", key: "verticalAlignment", values: ["top", "bottom"]},
            view: {
              top: {key: "style", value: {"vertical-align": "top"}},
              bottom: {key: "style", value: {"vertical-align": "bottom"}}
            }
          });
          e2.for("upcast").attributeToAttribute({
            view: {attributes: {valign: nO}},
            model: {name: "tableCell", key: "verticalAlignment", value: (t3) => t3.getAttribute("valign")}
          });
        }
        function cO(t2, e2, i2, n2) {
          t2.extend("tableCell", {allowAttributes: [i2]});
          WR(e2, "tableCell", i2, n2);
          UR(e2, "tableCell", i2, n2);
        }
        class lO extends mp {
          static get pluginName() {
            return "TableCellProperties";
          }
          static get requires() {
            return [oO, PR];
          }
        }
        class dO extends mp {
          static get requires() {
            return [ly];
          }
          static get pluginName() {
            return "TableToolbar";
          }
          afterInit() {
            const t2 = this.editor;
            const e2 = t2.t;
            const i2 = t2.plugins.get(ly);
            const n2 = t2.config.get("table.contentToolbar");
            const o2 = t2.config.get("table.tableToolbar");
            if (n2) {
              i2.register("tableContent", {ariaLabel: e2("iv"), items: n2, getRelatedElement: nS});
            }
            if (o2) {
              i2.register("table", {ariaLabel: e2("iv"), items: o2, getRelatedElement: iS});
            }
          }
        }
        class uO extends jw {
          constructor(t2, e2) {
            super(t2);
            this.attributeName = e2;
          }
          refresh() {
            const t2 = this.editor;
            const e2 = t2.model.document.selection;
            const i2 = WP("table", e2.getFirstPosition());
            this.isEnabled = !!i2;
            this.value = this._getValue(i2);
          }
          execute(t2 = {}) {
            const e2 = this.editor.model;
            const i2 = e2.document.selection;
            const {value: n2, batch: o2} = t2;
            const r2 = WP("table", i2.getFirstPosition());
            const s2 = this._getValueToSet(n2);
            e2.enqueueChange(o2 || "default", (t3) => {
              if (s2) {
                t3.setAttribute(this.attributeName, s2, r2);
              } else {
                t3.removeAttribute(this.attributeName, r2);
              }
            });
          }
          _getValue(t2) {
            if (!t2) {
              return;
            }
            return t2.getAttribute(this.attributeName);
          }
          _getValueToSet(t2) {
            return t2;
          }
        }
        class hO extends uO {
          constructor(t2) {
            super(t2, "backgroundColor");
          }
        }
        class fO extends uO {
          constructor(t2) {
            super(t2, "borderColor");
          }
          _getValue(t2) {
            if (!t2) {
              return;
            }
            return $P(t2.getAttribute(this.attributeName));
          }
        }
        class gO extends uO {
          constructor(t2) {
            super(t2, "borderStyle");
          }
          _getValue(t2) {
            if (!t2) {
              return;
            }
            return $P(t2.getAttribute(this.attributeName));
          }
        }
        class mO extends uO {
          constructor(t2) {
            super(t2, "borderWidth");
          }
          _getValue(t2) {
            if (!t2) {
              return;
            }
            return $P(t2.getAttribute(this.attributeName));
          }
          _getValueToSet(t2) {
            return GP(t2, "px");
          }
        }
        class pO extends uO {
          constructor(t2) {
            super(t2, "width");
          }
          _getValueToSet(t2) {
            return GP(t2, "px");
          }
        }
        class bO extends uO {
          constructor(t2) {
            super(t2, "height");
          }
          _getValueToSet(t2) {
            return GP(t2, "px");
          }
        }
        class wO extends uO {
          constructor(t2) {
            super(t2, "alignment");
          }
        }
        const kO = /^(left|right)$/;
        class _O extends mp {
          static get pluginName() {
            return "TablePropertiesEditing";
          }
          static get requires() {
            return [wE];
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.schema;
            const i2 = t2.conversion;
            t2.data.addStyleProcessorRules(SR);
            vO(e2, i2);
            t2.commands.add("tableBorderColor", new fO(t2));
            t2.commands.add("tableBorderStyle", new gO(t2));
            t2.commands.add("tableBorderWidth", new mO(t2));
            yO(e2, i2);
            t2.commands.add("tableAlignment", new wO(t2));
            CO(e2, i2, "width", "width");
            t2.commands.add("tableWidth", new pO(t2));
            CO(e2, i2, "height", "height");
            t2.commands.add("tableHeight", new bO(t2));
            t2.data.addStyleProcessorRules(jR);
            xO(e2, i2, "backgroundColor", "background-color");
            t2.commands.add("tableBackgroundColor", new hO(t2));
          }
        }
        function vO(t2, e2) {
          t2.extend("table", {allowAttributes: ["borderWidth", "borderColor", "borderStyle"]});
          qR(e2, "table");
          $R(e2, "borderColor", "border-color");
          $R(e2, "borderStyle", "border-style");
          $R(e2, "borderWidth", "border-width");
        }
        function yO(t2, e2) {
          t2.extend("table", {allowAttributes: ["alignment"]});
          e2.attributeToAttribute({
            model: {name: "table", key: "alignment", values: ["left", "right"]},
            view: {left: {key: "style", value: {float: "left"}}, right: {key: "style", value: {float: "right"}}},
            converterPriority: "high"
          });
          e2.for("upcast").attributeToAttribute({
            view: {attributes: {align: kO}},
            model: {name: "table", key: "alignment", value: (t3) => t3.getAttribute("align")}
          });
        }
        function xO(t2, e2, i2, n2) {
          t2.extend("table", {allowAttributes: [i2]});
          WR(e2, "table", i2, n2);
          $R(e2, i2, n2);
        }
        function CO(t2, e2, i2, n2) {
          t2.extend("table", {allowAttributes: [i2]});
          WR(e2, "table", i2, n2);
          UR(e2, "table", i2, n2);
        }
        var AO = i(112);
        const TO = {left: ky, center: _y, right: vy};
        class PO extends Gp {
          constructor(t2, e2) {
            super(t2);
            this.set({
              borderStyle: "",
              borderWidth: "",
              borderColor: "",
              backgroundColor: "",
              width: "",
              height: "",
              alignment: ""
            });
            this.options = e2;
            const {borderStyleDropdown: i2, borderWidthInput: n2, borderColorInput: o2, borderRowLabel: r2} = this._createBorderFields();
            const {widthInput: s2, operatorLabel: a2, heightInput: c2, dimensionsLabel: l2} = this._createDimensionFields();
            const {alignmentToolbar: d2, alignmentLabel: u2} = this._createAlignmentFields();
            this.focusTracker = new fb();
            this.keystrokes = new dp();
            this.children = this.createCollection();
            this.borderStyleDropdown = i2;
            this.borderWidthInput = n2;
            this.borderColorInput = o2;
            this.backgroundInput = this._createBackgroundField();
            this.widthInput = s2;
            this.heightInput = c2;
            this.alignmentToolbar = d2;
            const {saveButtonView: h2, cancelButtonView: f2} = this._createActionButtons();
            this.saveButtonView = h2;
            this.cancelButtonView = f2;
            this._focusables = new bp();
            this._focusCycler = new yb({
              focusables: this._focusables,
              focusTracker: this.focusTracker,
              keystrokeHandler: this.keystrokes,
              actions: {focusPrevious: "shift + tab", focusNext: "tab"}
            });
            this.children.add(new mR(t2, {label: this.t("\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430 \u0442\u0430\u0431\u043B\u0438\u0446\u044B")}));
            this.children.add(new fR(t2, {
              labelView: r2,
              children: [r2, i2, o2, n2],
              class: "ck-table-form__border-row"
            }));
            this.children.add(new fR(t2, {children: [this.backgroundInput]}));
            this.children.add(new fR(t2, {
              children: [new fR(t2, {
                labelView: l2,
                children: [l2, s2, a2, c2],
                class: "ck-table-form__dimensions-row"
              }), new fR(t2, {labelView: u2, children: [u2, d2], class: "ck-table-properties-form__alignment-row"})]
            }));
            this.children.add(new fR(t2, {
              children: [this.saveButtonView, this.cancelButtonView],
              class: "ck-table-form__action-row"
            }));
            this.setTemplate({
              tag: "form",
              attributes: {class: ["ck", "ck-form", "ck-table-form", "ck-table-properties-form"], tabindex: "-1"},
              children: this.children
            });
          }
          render() {
            super.render();
            Qv({view: this});
            [this.borderStyleDropdown, this.borderColorInput, this.borderWidthInput, this.backgroundInput, this.widthInput, this.heightInput, this.alignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t2) => {
              this._focusables.add(t2);
              this.focusTracker.add(t2.element);
            });
            this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createBorderFields() {
            const t2 = cR({colorConfig: this.options.borderColors, columns: 5});
            const e2 = this.locale;
            const i2 = this.t;
            const n2 = new Mk(e2);
            n2.text = i2("nb");
            const o2 = ZE(this.t);
            const r2 = new HE(e2, qE);
            r2.set({label: i2("nc"), class: "ck-table-form__border-style"});
            r2.view.buttonView.set({isOn: false, withText: true, tooltip: i2("nc")});
            r2.view.buttonView.bind("label").to(this, "borderStyle", (t3) => o2[t3 ? t3 : "none"]);
            r2.view.on("execute", (t3) => {
              this.borderStyle = t3.source._borderStyleValue;
            });
            Ub(r2.view, rR(this));
            const s2 = new HE(e2, WE);
            s2.set({label: i2("nd"), class: "ck-table-form__border-width"});
            s2.view.bind("value").to(this, "borderWidth");
            s2.bind("isEnabled").to(this, "borderStyle", SO);
            s2.view.on("input", () => {
              this.borderWidth = s2.view.element.value;
            });
            const a2 = new HE(e2, t2);
            a2.set({label: i2("ne"), class: "ck-table-form__border-color"});
            a2.view.bind("value").to(this, "borderColor");
            a2.bind("isEnabled").to(this, "borderStyle", SO);
            a2.view.on("input", () => {
              this.borderColor = a2.view.value;
            });
            this.on("change:borderStyle", (t3, e3, i3) => {
              if (!SO(i3)) {
                this.borderColor = "";
                this.borderWidth = "";
              }
            });
            return {borderRowLabel: n2, borderStyleDropdown: r2, borderColorInput: a2, borderWidthInput: s2};
          }
          _createBackgroundField() {
            const t2 = cR({colorConfig: this.options.backgroundColors, columns: 5});
            const e2 = this.locale;
            const i2 = this.t;
            const n2 = new HE(e2, t2);
            n2.set({label: i2("nf"), class: "ck-table-properties-form__background"});
            n2.view.bind("value").to(this, "backgroundColor");
            n2.view.on("input", () => {
              this.backgroundColor = n2.view.value;
            });
            return n2;
          }
          _createDimensionFields() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = new Mk(t2);
            i2.text = e2("ng");
            const n2 = new HE(t2, WE);
            n2.set({label: e2("nd"), class: "ck-table-form__dimensions-row__width"});
            n2.view.bind("value").to(this, "width");
            n2.view.on("input", () => {
              this.width = n2.view.element.value;
            });
            const o2 = new Gp(t2);
            o2.setTemplate({
              tag: "span",
              attributes: {class: ["ck-table-form__dimension-operator"]},
              children: [{text: "\xD7"}]
            });
            const r2 = new HE(t2, WE);
            r2.set({label: e2("nh"), class: "ck-table-form__dimensions-row__height"});
            r2.view.bind("value").to(this, "height");
            r2.view.on("input", () => {
              this.height = r2.view.element.value;
            });
            return {dimensionsLabel: i2, widthInput: n2, operatorLabel: o2, heightInput: r2};
          }
          _createAlignmentFields() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = new Mk(t2);
            i2.text = e2("nt");
            const n2 = new Xb(t2);
            n2.set({isCompact: true, ariaLabel: e2("nu")});
            sR({
              view: this,
              icons: TO,
              toolbar: n2,
              labels: this._alignmentLabels,
              propertyName: "alignment",
              nameToValue: (t3) => t3 === "center" ? "" : t3
            });
            return {alignmentLabel: i2, alignmentToolbar: n2};
          }
          _createActionButtons() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = new hb(t2);
            const n2 = new hb(t2);
            const o2 = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.widthInput, this.heightInput];
            i2.set({label: e2("lo"), icon: Xv, class: "ck-button-save", type: "submit", withText: true});
            i2.bind("isEnabled").toMany(o2, "errorText", (...t3) => t3.every((t4) => !t4));
            n2.set({label: e2("lp"), icon: Zv, class: "ck-button-cancel", type: "cancel", withText: true});
            n2.delegate("execute").to(this, "cancel");
            return {saveButtonView: i2, cancelButtonView: n2};
          }
          get _alignmentLabels() {
            const t2 = this.locale;
            const e2 = this.t;
            const i2 = e2("nv");
            const n2 = e2("nw");
            const o2 = e2("nx");
            if (t2.uiLanguageDirection === "rtl") {
              return {right: o2, center: n2, left: i2};
            } else {
              return {left: i2, center: n2, right: o2};
            }
          }
        }
        function SO(t2) {
          return !!t2;
        }
        var EO = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="M15.5 11.5l1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>';
        const RO = 500;
        class OO extends mp {
          static get requires() {
            return [kb];
          }
          static get pluginName() {
            return "TablePropertiesUI";
          }
          constructor(t2) {
            super(t2);
            t2.config.define("table.tableProperties", {borderColors: aR, backgroundColors: aR});
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            this._balloon = t2.plugins.get(kb);
            this.view = this._createPropertiesView();
            this._undoStepBatch = null;
            t2.ui.componentFactory.add("tableProperties", (t3) => {
              const i2 = new hb(t3);
              i2.set({label: e2("kg"), icon: EO, tooltip: true});
              this.listenTo(i2, "execute", () => this._showView());
              return i2;
            });
          }
          destroy() {
            super.destroy();
            this.view.destroy();
          }
          _createPropertiesView() {
            const t2 = this.editor;
            const e2 = t2.editing.view.document;
            const i2 = t2.config.get("table.tableProperties");
            const n2 = __(i2.borderColors);
            const o2 = k_(t2.locale, n2);
            const r2 = __(i2.backgroundColors);
            const s2 = k_(t2.locale, r2);
            const a2 = new PO(t2.locale, {borderColors: o2, backgroundColors: s2});
            const c2 = t2.t;
            a2.render();
            this.listenTo(a2, "submit", () => {
              this._hideView();
            });
            this.listenTo(a2, "cancel", () => {
              if (this._undoStepBatch.operations.length) {
                t2.execute("undo", this._undoStepBatch);
              }
              this._hideView();
            });
            a2.keystrokes.set("Esc", (t3, e3) => {
              this._hideView();
              e3();
            });
            this.listenTo(t2.ui, "update", () => {
              if (!nS(e2.selection)) {
                this._hideView();
              } else if (this._isViewVisible) {
                YE(t2, "table");
              }
            });
            Db({
              emitter: a2,
              activator: () => this._isViewInBalloon,
              contextElements: [this._balloon.view.element],
              callback: () => this._hideView()
            });
            const l2 = tR(c2);
            const d2 = eR(c2);
            a2.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle"));
            a2.on("change:borderColor", this._getValidatedPropertyChangeCallback({
              viewField: a2.borderColorInput,
              commandName: "tableBorderColor",
              errorText: l2,
              validator: iR
            }));
            a2.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
              viewField: a2.borderWidthInput,
              commandName: "tableBorderWidth",
              errorText: d2,
              validator: oR
            }));
            a2.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
              viewField: a2.backgroundInput,
              commandName: "tableBackgroundColor",
              errorText: l2,
              validator: iR
            }));
            a2.on("change:width", this._getValidatedPropertyChangeCallback({
              viewField: a2.widthInput,
              commandName: "tableWidth",
              errorText: d2,
              validator: nR
            }));
            a2.on("change:height", this._getValidatedPropertyChangeCallback({
              viewField: a2.heightInput,
              commandName: "tableHeight",
              errorText: d2,
              validator: nR
            }));
            a2.on("change:alignment", this._getPropertyChangeCallback("tableAlignment"));
            return a2;
          }
          _fillViewFormFromCommandValues() {
            const t2 = this.editor.commands;
            this.view.set({
              borderStyle: t2.get("tableBorderStyle").value || "",
              borderColor: t2.get("tableBorderColor").value || "",
              borderWidth: t2.get("tableBorderWidth").value || "",
              backgroundColor: t2.get("tableBackgroundColor").value || "",
              width: t2.get("tableWidth").value || "",
              height: t2.get("tableHeight").value || "",
              alignment: t2.get("tableAlignment").value || ""
            });
          }
          _showView() {
            const t2 = this.editor;
            this._balloon.add({view: this.view, position: QE(t2)});
            this._undoStepBatch = t2.model.createBatch();
            this._fillViewFormFromCommandValues();
            this.view.focus();
          }
          _hideView() {
            if (!this._isViewInBalloon) {
              return;
            }
            const t2 = this.editor;
            this.stopListening(t2.ui, "update");
            this.view.saveButtonView.focus();
            this._balloon.remove(this.view);
            this.editor.editing.view.focus();
          }
          get _isViewVisible() {
            return this._balloon.visibleView === this.view;
          }
          get _isViewInBalloon() {
            return this._balloon.hasView(this.view);
          }
          _getPropertyChangeCallback(t2) {
            return (e2, i2, n2) => {
              this.editor.execute(t2, {value: n2, batch: this._undoStepBatch});
            };
          }
          _getValidatedPropertyChangeCallback({commandName: t2, viewField: e2, validator: i2, errorText: n2}) {
            const o2 = uh(() => {
              e2.errorText = n2;
            }, RO);
            return (n3, r2, s2) => {
              o2.cancel();
              if (i2(s2)) {
                this.editor.execute(t2, {value: s2, batch: this._undoStepBatch});
                e2.errorText = null;
              } else {
                o2();
              }
            };
          }
        }
        class IO extends mp {
          static get pluginName() {
            return "TableProperties";
          }
          static get requires() {
            return [_O, OO];
          }
        }
        const VO = "underline";
        class NO extends mp {
          static get pluginName() {
            return "UnderlineEditing";
          }
          init() {
            const t2 = this.editor;
            t2.model.schema.extend("$text", {allowAttributes: VO});
            t2.model.schema.setAttributeProperties(VO, {isFormatting: true, copyOnEnter: true});
            t2.conversion.attributeToElement({
              model: VO,
              view: "u",
              upcastAlso: {styles: {"text-decoration": "underline"}}
            });
            t2.commands.add(VO, new yk(t2, VO));
            t2.keystrokes.set("CTRL+U", "underline");
          }
        }
        var MO = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
        const BO = "underline";
        class zO extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.t;
            t2.ui.componentFactory.add(BO, (i2) => {
              const n2 = t2.commands.get(BO);
              const o2 = new hb(i2);
              o2.set({label: e2("jn"), icon: MO, keystroke: "CTRL+U", tooltip: true, isToggleable: true});
              o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled");
              this.listenTo(o2, "execute", () => {
                t2.execute(BO);
                t2.editing.view.focus();
              });
              return o2;
            });
          }
        }
        class LO extends mp {
          static get requires() {
            return [NO, zO];
          }
          static get pluginName() {
            return "Underline";
          }
        }
        function* FO(t2, e2) {
          for (const i2 of e2) {
            if (i2 && t2.getAttributeProperties(i2[0]).copyOnEnter) {
              yield i2;
            }
          }
        }
        class DO extends jw {
          execute() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            t2.change((i2) => {
              jO(this.editor.model, i2, e2.selection, t2.schema);
              this.fire("afterExecute", {writer: i2});
            });
          }
        }
        function jO(t2, e2, i2, n2) {
          const o2 = i2.isCollapsed;
          const r2 = i2.getFirstRange();
          const s2 = r2.start.parent;
          const a2 = r2.end.parent;
          if (n2.isLimit(s2) || n2.isLimit(a2)) {
            if (!o2 && s2 == a2) {
              t2.deleteContent(i2);
            }
            return;
          }
          if (o2) {
            const t3 = FO(e2.model.schema, i2.getAttributes());
            HO(e2, r2.start);
            e2.setSelectionAttribute(t3);
          } else {
            const n3 = !(r2.start.isAtStart && r2.end.isAtEnd);
            const o3 = s2 == a2;
            t2.deleteContent(i2, {leaveUnmerged: n3});
            if (n3) {
              if (o3) {
                HO(e2, i2.focus);
              } else {
                e2.setSelection(a2, 0);
              }
            }
          }
        }
        function HO(t2, e2) {
          t2.split(e2);
          t2.setSelection(e2.parent.nextSibling, 0);
        }
        class WO extends Gd {
          constructor(t2) {
            super(t2);
            const e2 = this.document;
            e2.on("keydown", (t3, i2) => {
              if (this.isEnabled && i2.keyCode == Nl.enter) {
                let n2;
                e2.once("enter", (t4) => n2 = t4, {priority: "highest"});
                e2.fire("enter", new Ku(e2, i2.domEvent, {isSoft: i2.shiftKey}));
                if (n2 && n2.stop.called) {
                  t3.stop();
                }
              }
            });
          }
          observe() {
          }
        }
        class qO extends mp {
          static get pluginName() {
            return "Enter";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.editing.view;
            const i2 = e2.document;
            e2.addObserver(WO);
            t2.commands.add("enter", new DO(t2));
            this.listenTo(i2, "enter", (i3, n2) => {
              n2.preventDefault();
              if (n2.isSoft) {
                return;
              }
              t2.execute("enter");
              e2.scrollToTheSelection();
            }, {priority: "low"});
          }
        }
        class UO extends jw {
          execute() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            t2.change((i2) => {
              GO(t2, i2, e2.selection);
              this.fire("afterExecute", {writer: i2});
            });
          }
          refresh() {
            const t2 = this.editor.model;
            const e2 = t2.document;
            this.isEnabled = $O(t2.schema, e2.selection);
          }
        }
        function $O(t2, e2) {
          if (e2.rangeCount > 1) {
            return false;
          }
          const i2 = e2.anchor;
          if (!i2 || !t2.checkChild(i2, "softBreak")) {
            return false;
          }
          const n2 = e2.getFirstRange();
          const o2 = n2.start.parent;
          const r2 = n2.end.parent;
          if ((JO(o2, t2) || JO(r2, t2)) && o2 !== r2) {
            return false;
          }
          return true;
        }
        function GO(t2, e2, i2) {
          const n2 = i2.isCollapsed;
          const o2 = i2.getFirstRange();
          const r2 = o2.start.parent;
          const s2 = o2.end.parent;
          const a2 = r2 == s2;
          if (n2) {
            const n3 = FO(t2.schema, i2.getAttributes());
            KO(t2, e2, o2.end);
            e2.removeSelectionAttribute(i2.getAttributeKeys());
            e2.setSelectionAttribute(n3);
          } else {
            const n3 = !(o2.start.isAtStart && o2.end.isAtEnd);
            t2.deleteContent(i2, {leaveUnmerged: n3});
            if (a2) {
              KO(t2, e2, i2.focus);
            } else {
              if (n3) {
                e2.setSelection(s2, 0);
              }
            }
          }
        }
        function KO(t2, e2, i2) {
          const n2 = e2.createElement("softBreak");
          t2.insertContent(n2, i2);
          e2.setSelection(n2, "after");
        }
        function JO(t2, e2) {
          if (t2.is("rootElement")) {
            return false;
          }
          return e2.isLimit(t2) || JO(t2.parent, e2);
        }
        class YO extends mp {
          static get pluginName() {
            return "ShiftEnter";
          }
          init() {
            const t2 = this.editor;
            const e2 = t2.model.schema;
            const i2 = t2.conversion;
            const n2 = t2.editing.view;
            const o2 = n2.document;
            e2.register("softBreak", {allowWhere: "$text", isInline: true});
            i2.for("upcast").elementToElement({model: "softBreak", view: "br"});
            i2.for("downcast").elementToElement({model: "softBreak", view: (t3, e3) => e3.createEmptyElement("br")});
            n2.addObserver(WO);
            t2.commands.add("shiftEnter", new UO(t2));
            this.listenTo(o2, "enter", (e3, i3) => {
              i3.preventDefault();
              if (!i3.isSoft) {
                return;
              }
              t2.execute("shiftEnter");
              n2.scrollToTheSelection();
            }, {priority: "low"});
          }
        }
        const QO = new Map();
        function XO(t2, e2, i2) {
          let n2 = QO.get(t2);
          if (!n2) {
            n2 = new Map();
            QO.set(t2, n2);
          }
          n2.set(e2, i2);
        }
        function ZO(t2, e2) {
          const i2 = QO.get(t2);
          if (i2 && i2.has(e2)) {
            return i2.get(e2);
          }
          return tI;
        }
        function tI(t2) {
          return [t2];
        }
        function eI(t2, e2, i2 = {}) {
          const n2 = ZO(t2.constructor, e2.constructor);
          try {
            t2 = t2.clone();
            return n2(t2, e2, i2);
          } catch (t3) {
            throw t3;
          }
        }
        function iI(t2, e2, i2) {
          t2 = t2.slice();
          e2 = e2.slice();
          const n2 = new nI(i2.document, i2.useRelations, i2.forceWeakRemove);
          n2.setOriginalOperations(t2);
          n2.setOriginalOperations(e2);
          const o2 = n2.originalOperations;
          if (t2.length == 0 || e2.length == 0) {
            return {operationsA: t2, operationsB: e2, originalOperations: o2};
          }
          const r2 = new WeakMap();
          for (const e3 of t2) {
            r2.set(e3, 0);
          }
          const s2 = {
            nextBaseVersionA: t2[t2.length - 1].baseVersion + 1,
            nextBaseVersionB: e2[e2.length - 1].baseVersion + 1,
            originalOperationsACount: t2.length,
            originalOperationsBCount: e2.length
          };
          let a2 = 0;
          while (a2 < t2.length) {
            const i3 = t2[a2];
            const o3 = r2.get(i3);
            if (o3 == e2.length) {
              a2++;
              continue;
            }
            const s3 = e2[o3];
            const c2 = eI(i3, s3, n2.getContext(i3, s3, true));
            const l2 = eI(s3, i3, n2.getContext(s3, i3, false));
            n2.updateRelation(i3, s3);
            n2.setOriginalOperations(c2, i3);
            n2.setOriginalOperations(l2, s3);
            for (const t3 of c2) {
              r2.set(t3, o3 + l2.length);
            }
            t2.splice(a2, 1, ...c2);
            e2.splice(o3, 1, ...l2);
          }
          if (i2.padWithNoOps) {
            const i3 = t2.length - s2.originalOperationsACount;
            const n3 = e2.length - s2.originalOperationsBCount;
            rI(t2, n3 - i3);
            rI(e2, i3 - n3);
          }
          oI(t2, s2.nextBaseVersionB);
          oI(e2, s2.nextBaseVersionA);
          return {operationsA: t2, operationsB: e2, originalOperations: o2};
        }
        class nI {
          constructor(t2, e2, i2 = false) {
            this.originalOperations = new Map();
            this._history = t2.history;
            this._useRelations = e2;
            this._forceWeakRemove = !!i2;
            this._relations = new Map();
          }
          setOriginalOperations(t2, e2 = null) {
            const i2 = e2 ? this.originalOperations.get(e2) : null;
            for (const e3 of t2) {
              this.originalOperations.set(e3, i2 || e3);
            }
          }
          updateRelation(t2, e2) {
            switch (t2.constructor) {
              case Zg: {
                switch (e2.constructor) {
                  case om: {
                    if (t2.targetPosition.isEqual(e2.sourcePosition) || e2.movedRange.containsPosition(t2.targetPosition)) {
                      this._setRelation(t2, e2, "insertAtSource");
                    } else if (t2.targetPosition.isEqual(e2.deletionPosition)) {
                      this._setRelation(t2, e2, "insertBetween");
                    } else if (t2.targetPosition.isAfter(e2.sourcePosition)) {
                      this._setRelation(t2, e2, "moveTargetAfter");
                    }
                    break;
                  }
                  case Zg: {
                    if (t2.targetPosition.isEqual(e2.sourcePosition) || t2.targetPosition.isBefore(e2.sourcePosition)) {
                      this._setRelation(t2, e2, "insertBefore");
                    } else {
                      this._setRelation(t2, e2, "insertAfter");
                    }
                    break;
                  }
                }
                break;
              }
              case rm: {
                switch (e2.constructor) {
                  case om: {
                    if (t2.splitPosition.isBefore(e2.sourcePosition)) {
                      this._setRelation(t2, e2, "splitBefore");
                    }
                    break;
                  }
                  case Zg: {
                    if (t2.splitPosition.isEqual(e2.sourcePosition) || t2.splitPosition.isBefore(e2.sourcePosition)) {
                      this._setRelation(t2, e2, "splitBefore");
                    }
                    break;
                  }
                }
                break;
              }
              case om: {
                switch (e2.constructor) {
                  case om: {
                    if (!t2.targetPosition.isEqual(e2.sourcePosition)) {
                      this._setRelation(t2, e2, "mergeTargetNotMoved");
                    }
                    if (t2.sourcePosition.isEqual(e2.targetPosition)) {
                      this._setRelation(t2, e2, "mergeSourceNotMoved");
                    }
                    if (t2.sourcePosition.isEqual(e2.sourcePosition)) {
                      this._setRelation(t2, e2, "mergeSameElement");
                    }
                    break;
                  }
                  case rm: {
                    if (t2.sourcePosition.isEqual(e2.splitPosition)) {
                      this._setRelation(t2, e2, "splitAtSource");
                    }
                  }
                }
                break;
              }
              case em: {
                const i2 = t2.newRange;
                if (!i2) {
                  return;
                }
                switch (e2.constructor) {
                  case Zg: {
                    const n2 = $h._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
                    const o2 = n2.containsPosition(i2.start) || n2.start.isEqual(i2.start);
                    const r2 = n2.containsPosition(i2.end) || n2.end.isEqual(i2.end);
                    if ((o2 || r2) && !n2.containsRange(i2)) {
                      this._setRelation(t2, e2, {
                        side: o2 ? "left" : "right",
                        path: o2 ? i2.start.path.slice() : i2.end.path.slice()
                      });
                    }
                    break;
                  }
                  case om: {
                    const n2 = i2.start.isEqual(e2.targetPosition);
                    const o2 = i2.start.isEqual(e2.deletionPosition);
                    const r2 = i2.end.isEqual(e2.deletionPosition);
                    const s2 = i2.end.isEqual(e2.sourcePosition);
                    if (n2 || o2 || r2 || s2) {
                      this._setRelation(t2, e2, {
                        wasInLeftElement: n2,
                        wasStartBeforeMergedElement: o2,
                        wasEndBeforeMergedElement: r2,
                        wasInRightElement: s2
                      });
                    }
                    break;
                  }
                }
                break;
              }
            }
          }
          getContext(t2, e2, i2) {
            return {
              aIsStrong: i2,
              aWasUndone: this._wasUndone(t2),
              bWasUndone: this._wasUndone(e2),
              abRelation: this._useRelations ? this._getRelation(t2, e2) : null,
              baRelation: this._useRelations ? this._getRelation(e2, t2) : null,
              forceWeakRemove: this._forceWeakRemove
            };
          }
          _wasUndone(t2) {
            const e2 = this.originalOperations.get(t2);
            return e2.wasUndone || this._history.isUndoneOperation(e2);
          }
          _getRelation(t2, e2) {
            const i2 = this.originalOperations.get(e2);
            const n2 = this._history.getUndoneOperation(i2);
            if (!n2) {
              return null;
            }
            const o2 = this.originalOperations.get(t2);
            const r2 = this._relations.get(o2);
            if (r2) {
              return r2.get(n2) || null;
            }
            return null;
          }
          _setRelation(t2, e2, i2) {
            const n2 = this.originalOperations.get(t2);
            const o2 = this.originalOperations.get(e2);
            let r2 = this._relations.get(n2);
            if (!r2) {
              r2 = new Map();
              this._relations.set(n2, r2);
            }
            r2.set(o2, i2);
          }
        }
        function oI(t2, e2) {
          for (const i2 of t2) {
            i2.baseVersion = e2++;
          }
        }
        function rI(t2, e2) {
          for (let i2 = 0; i2 < e2; i2++) {
            t2.push(new Sm(0));
          }
        }
        XO(Qg, Qg, (t2, e2, i2) => {
          if (t2.key === e2.key) {
            const n2 = t2.range.getDifference(e2.range).map((e3) => new Qg(e3, t2.key, t2.oldValue, t2.newValue, 0));
            const o2 = t2.range.getIntersection(e2.range);
            if (o2) {
              if (i2.aIsStrong) {
                n2.push(new Qg(o2, e2.key, e2.newValue, t2.newValue, 0));
              }
            }
            if (n2.length == 0) {
              return [new Sm(0)];
            }
            return n2;
          } else {
            return [t2];
          }
        });
        XO(Qg, tm, (t2, e2) => {
          if (t2.range.start.hasSameParentAs(e2.position) && t2.range.containsPosition(e2.position)) {
            const i2 = t2.range._getTransformedByInsertion(e2.position, e2.howMany, !e2.shouldReceiveAttributes);
            const n2 = i2.map((e3) => new Qg(e3, t2.key, t2.oldValue, t2.newValue, t2.baseVersion));
            if (e2.shouldReceiveAttributes) {
              const i3 = sI(e2, t2.key, t2.oldValue);
              if (i3) {
                n2.unshift(i3);
              }
            }
            return n2;
          }
          t2.range = t2.range._getTransformedByInsertion(e2.position, e2.howMany, false)[0];
          return [t2];
        });
        function sI(t2, e2, i2) {
          const n2 = t2.nodes;
          const o2 = n2.getNode(0).getAttribute(e2);
          if (o2 == i2) {
            return null;
          }
          const r2 = new $h(t2.position, t2.position.getShiftedBy(t2.howMany));
          return new Qg(r2, e2, o2, i2, 0);
        }
        XO(Qg, om, (t2, e2) => {
          const i2 = [];
          if (t2.range.start.hasSameParentAs(e2.deletionPosition)) {
            if (t2.range.containsPosition(e2.deletionPosition) || t2.range.start.isEqual(e2.deletionPosition)) {
              i2.push($h._createFromPositionAndShift(e2.graveyardPosition, 1));
            }
          }
          const n2 = t2.range._getTransformedByMergeOperation(e2);
          if (!n2.isCollapsed) {
            i2.push(n2);
          }
          return i2.map((e3) => new Qg(e3, t2.key, t2.oldValue, t2.newValue, t2.baseVersion));
        });
        XO(Qg, Zg, (t2, e2) => {
          const i2 = aI(t2.range, e2);
          return i2.map((e3) => new Qg(e3, t2.key, t2.oldValue, t2.newValue, t2.baseVersion));
        });
        function aI(t2, e2) {
          const i2 = $h._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
          let n2 = null;
          let o2 = [];
          if (i2.containsRange(t2, true)) {
            n2 = t2;
          } else if (t2.start.hasSameParentAs(i2.start)) {
            o2 = t2.getDifference(i2);
            n2 = t2.getIntersection(i2);
          } else {
            o2 = [t2];
          }
          const r2 = [];
          for (let t3 of o2) {
            t3 = t3._getTransformedByDeletion(e2.sourcePosition, e2.howMany);
            const i3 = e2.getMovedRangeStart();
            const n3 = t3.start.hasSameParentAs(i3);
            t3 = t3._getTransformedByInsertion(i3, e2.howMany, n3);
            r2.push(...t3);
          }
          if (n2) {
            r2.push(n2._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany, false)[0]);
          }
          return r2;
        }
        XO(Qg, rm, (t2, e2) => {
          if (t2.range.end.isEqual(e2.insertionPosition)) {
            if (!e2.graveyardPosition) {
              t2.range.end.offset++;
            }
            return [t2];
          }
          if (t2.range.start.hasSameParentAs(e2.splitPosition) && t2.range.containsPosition(e2.splitPosition)) {
            const i2 = t2.clone();
            i2.range = new $h(e2.moveTargetPosition.clone(), t2.range.end._getCombined(e2.splitPosition, e2.moveTargetPosition));
            t2.range.end = e2.splitPosition.clone();
            t2.range.end.stickiness = "toPrevious";
            return [t2, i2];
          }
          t2.range = t2.range._getTransformedBySplitOperation(e2);
          return [t2];
        });
        XO(tm, Qg, (t2, e2) => {
          const i2 = [t2];
          if (t2.shouldReceiveAttributes && t2.position.hasSameParentAs(e2.range.start) && e2.range.containsPosition(t2.position)) {
            const n2 = sI(t2, e2.key, e2.newValue);
            if (n2) {
              i2.push(n2);
            }
          }
          return i2;
        });
        XO(tm, tm, (t2, e2, i2) => {
          if (t2.position.isEqual(e2.position) && i2.aIsStrong) {
            return [t2];
          }
          t2.position = t2.position._getTransformedByInsertOperation(e2);
          return [t2];
        });
        XO(tm, Zg, (t2, e2) => {
          t2.position = t2.position._getTransformedByMoveOperation(e2);
          return [t2];
        });
        XO(tm, rm, (t2, e2) => {
          t2.position = t2.position._getTransformedBySplitOperation(e2);
          return [t2];
        });
        XO(tm, om, (t2, e2) => {
          t2.position = t2.position._getTransformedByMergeOperation(e2);
          return [t2];
        });
        XO(em, tm, (t2, e2) => {
          if (t2.oldRange) {
            t2.oldRange = t2.oldRange._getTransformedByInsertOperation(e2)[0];
          }
          if (t2.newRange) {
            t2.newRange = t2.newRange._getTransformedByInsertOperation(e2)[0];
          }
          return [t2];
        });
        XO(em, em, (t2, e2, i2) => {
          if (t2.name == e2.name) {
            if (i2.aIsStrong) {
              t2.oldRange = e2.newRange ? e2.newRange.clone() : null;
            } else {
              return [new Sm(0)];
            }
          }
          return [t2];
        });
        XO(em, om, (t2, e2) => {
          if (t2.oldRange) {
            t2.oldRange = t2.oldRange._getTransformedByMergeOperation(e2);
          }
          if (t2.newRange) {
            t2.newRange = t2.newRange._getTransformedByMergeOperation(e2);
          }
          return [t2];
        });
        XO(em, Zg, (t2, e2, i2) => {
          if (t2.oldRange) {
            t2.oldRange = $h._createFromRanges(t2.oldRange._getTransformedByMoveOperation(e2));
          }
          if (t2.newRange) {
            if (i2.abRelation) {
              const n2 = $h._createFromRanges(t2.newRange._getTransformedByMoveOperation(e2));
              if (i2.abRelation.side == "left" && e2.targetPosition.isEqual(t2.newRange.start)) {
                t2.newRange.start.path = i2.abRelation.path;
                t2.newRange.end = n2.end;
                return [t2];
              } else if (i2.abRelation.side == "right" && e2.targetPosition.isEqual(t2.newRange.end)) {
                t2.newRange.start = n2.start;
                t2.newRange.end.path = i2.abRelation.path;
                return [t2];
              }
            }
            t2.newRange = $h._createFromRanges(t2.newRange._getTransformedByMoveOperation(e2));
          }
          return [t2];
        });
        XO(em, rm, (t2, e2, i2) => {
          if (t2.oldRange) {
            t2.oldRange = t2.oldRange._getTransformedBySplitOperation(e2);
          }
          if (t2.newRange) {
            if (i2.abRelation) {
              const n2 = t2.newRange._getTransformedBySplitOperation(e2);
              if (t2.newRange.start.isEqual(e2.splitPosition) && i2.abRelation.wasStartBeforeMergedElement) {
                t2.newRange.start = Uh._createAt(e2.insertionPosition);
              } else if (t2.newRange.start.isEqual(e2.splitPosition) && !i2.abRelation.wasInLeftElement) {
                t2.newRange.start = Uh._createAt(e2.moveTargetPosition);
              }
              if (t2.newRange.end.isEqual(e2.splitPosition) && i2.abRelation.wasInRightElement) {
                t2.newRange.end = Uh._createAt(e2.moveTargetPosition);
              } else if (t2.newRange.end.isEqual(e2.splitPosition) && i2.abRelation.wasEndBeforeMergedElement) {
                t2.newRange.end = Uh._createAt(e2.insertionPosition);
              } else {
                t2.newRange.end = n2.end;
              }
              return [t2];
            }
            t2.newRange = t2.newRange._getTransformedBySplitOperation(e2);
          }
          return [t2];
        });
        XO(om, tm, (t2, e2) => {
          if (t2.sourcePosition.hasSameParentAs(e2.position)) {
            t2.howMany += e2.howMany;
          }
          t2.sourcePosition = t2.sourcePosition._getTransformedByInsertOperation(e2);
          t2.targetPosition = t2.targetPosition._getTransformedByInsertOperation(e2);
          return [t2];
        });
        XO(om, om, (t2, e2, i2) => {
          if (t2.sourcePosition.isEqual(e2.sourcePosition) && t2.targetPosition.isEqual(e2.targetPosition)) {
            if (!i2.bWasUndone) {
              return [new Sm(0)];
            } else {
              const i3 = e2.graveyardPosition.path.slice();
              i3.push(0);
              t2.sourcePosition = new Uh(e2.graveyardPosition.root, i3);
              t2.howMany = 0;
              return [t2];
            }
          }
          if (t2.sourcePosition.isEqual(e2.sourcePosition) && !t2.targetPosition.isEqual(e2.targetPosition) && !i2.bWasUndone && i2.abRelation != "splitAtSource") {
            const n2 = t2.targetPosition.root.rootName == "$graveyard";
            const o2 = e2.targetPosition.root.rootName == "$graveyard";
            const r2 = n2 && !o2;
            const s2 = o2 && !n2;
            const a2 = s2 || !r2 && i2.aIsStrong;
            if (a2) {
              const i3 = e2.targetPosition._getTransformedByMergeOperation(e2);
              const n3 = t2.targetPosition._getTransformedByMergeOperation(e2);
              return [new Zg(i3, t2.howMany, n3, 0)];
            } else {
              return [new Sm(0)];
            }
          }
          if (t2.sourcePosition.hasSameParentAs(e2.targetPosition)) {
            t2.howMany += e2.howMany;
          }
          t2.sourcePosition = t2.sourcePosition._getTransformedByMergeOperation(e2);
          t2.targetPosition = t2.targetPosition._getTransformedByMergeOperation(e2);
          if (!t2.graveyardPosition.isEqual(e2.graveyardPosition) || !i2.aIsStrong) {
            t2.graveyardPosition = t2.graveyardPosition._getTransformedByMergeOperation(e2);
          }
          return [t2];
        });
        XO(om, Zg, (t2, e2, i2) => {
          const n2 = $h._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
          if (e2.type == "remove" && !i2.bWasUndone && !i2.forceWeakRemove) {
            if (t2.deletionPosition.hasSameParentAs(e2.sourcePosition) && n2.containsPosition(t2.sourcePosition)) {
              return [new Sm(0)];
            }
          }
          if (t2.sourcePosition.hasSameParentAs(e2.targetPosition)) {
            t2.howMany += e2.howMany;
          }
          if (t2.sourcePosition.hasSameParentAs(e2.sourcePosition)) {
            t2.howMany -= e2.howMany;
          }
          t2.sourcePosition = t2.sourcePosition._getTransformedByMoveOperation(e2);
          t2.targetPosition = t2.targetPosition._getTransformedByMoveOperation(e2);
          if (!t2.graveyardPosition.isEqual(e2.targetPosition)) {
            t2.graveyardPosition = t2.graveyardPosition._getTransformedByMoveOperation(e2);
          }
          return [t2];
        });
        XO(om, rm, (t2, e2, i2) => {
          if (e2.graveyardPosition) {
            t2.graveyardPosition = t2.graveyardPosition._getTransformedByDeletion(e2.graveyardPosition, 1);
            if (t2.deletionPosition.isEqual(e2.graveyardPosition)) {
              t2.howMany = e2.howMany;
            }
          }
          if (t2.targetPosition.isEqual(e2.splitPosition)) {
            const n2 = e2.howMany != 0;
            const o2 = e2.graveyardPosition && t2.deletionPosition.isEqual(e2.graveyardPosition);
            if (n2 || o2 || i2.abRelation == "mergeTargetNotMoved") {
              t2.sourcePosition = t2.sourcePosition._getTransformedBySplitOperation(e2);
              return [t2];
            }
          }
          if (t2.sourcePosition.isEqual(e2.splitPosition)) {
            if (i2.abRelation == "mergeSourceNotMoved") {
              t2.howMany = 0;
              t2.targetPosition = t2.targetPosition._getTransformedBySplitOperation(e2);
              return [t2];
            }
            if (i2.abRelation == "mergeSameElement" || t2.sourcePosition.offset > 0) {
              t2.sourcePosition = e2.moveTargetPosition.clone();
              t2.targetPosition = t2.targetPosition._getTransformedBySplitOperation(e2);
              return [t2];
            }
          }
          if (t2.sourcePosition.hasSameParentAs(e2.splitPosition)) {
            t2.howMany = e2.splitPosition.offset;
          }
          t2.sourcePosition = t2.sourcePosition._getTransformedBySplitOperation(e2);
          t2.targetPosition = t2.targetPosition._getTransformedBySplitOperation(e2);
          return [t2];
        });
        XO(Zg, tm, (t2, e2) => {
          const i2 = $h._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
          const n2 = i2._getTransformedByInsertOperation(e2, false)[0];
          t2.sourcePosition = n2.start;
          t2.howMany = n2.end.offset - n2.start.offset;
          if (!t2.targetPosition.isEqual(e2.position)) {
            t2.targetPosition = t2.targetPosition._getTransformedByInsertOperation(e2);
          }
          return [t2];
        });
        XO(Zg, Zg, (t2, e2, i2) => {
          const n2 = $h._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
          const o2 = $h._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
          let r2 = i2.aIsStrong;
          let s2 = !i2.aIsStrong;
          if (i2.abRelation == "insertBefore" || i2.baRelation == "insertAfter") {
            s2 = true;
          } else if (i2.abRelation == "insertAfter" || i2.baRelation == "insertBefore") {
            s2 = false;
          }
          let a2;
          if (t2.targetPosition.isEqual(e2.targetPosition) && s2) {
            a2 = t2.targetPosition._getTransformedByDeletion(e2.sourcePosition, e2.howMany);
          } else {
            a2 = t2.targetPosition._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany);
          }
          if (cI(t2, e2) && cI(e2, t2)) {
            return [e2.getReversed()];
          }
          const c2 = n2.containsPosition(e2.targetPosition);
          if (c2 && n2.containsRange(o2, true)) {
            n2.start = n2.start._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany);
            n2.end = n2.end._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany);
            return lI([n2], a2);
          }
          const l2 = o2.containsPosition(t2.targetPosition);
          if (l2 && o2.containsRange(n2, true)) {
            n2.start = n2.start._getCombined(e2.sourcePosition, e2.getMovedRangeStart());
            n2.end = n2.end._getCombined(e2.sourcePosition, e2.getMovedRangeStart());
            return lI([n2], a2);
          }
          const d2 = Vs(t2.sourcePosition.getParentPath(), e2.sourcePosition.getParentPath());
          if (d2 == "prefix" || d2 == "extension") {
            n2.start = n2.start._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany);
            n2.end = n2.end._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany);
            return lI([n2], a2);
          }
          if (t2.type == "remove" && e2.type != "remove" && !i2.aWasUndone && !i2.forceWeakRemove) {
            r2 = true;
          } else if (t2.type != "remove" && e2.type == "remove" && !i2.bWasUndone && !i2.forceWeakRemove) {
            r2 = false;
          }
          const u2 = [];
          const h2 = n2.getDifference(o2);
          for (const t3 of h2) {
            t3.start = t3.start._getTransformedByDeletion(e2.sourcePosition, e2.howMany);
            t3.end = t3.end._getTransformedByDeletion(e2.sourcePosition, e2.howMany);
            const i3 = Vs(t3.start.getParentPath(), e2.getMovedRangeStart().getParentPath()) == "same";
            const n3 = t3._getTransformedByInsertion(e2.getMovedRangeStart(), e2.howMany, i3);
            u2.push(...n3);
          }
          const f2 = n2.getIntersection(o2);
          if (f2 !== null && r2) {
            f2.start = f2.start._getCombined(e2.sourcePosition, e2.getMovedRangeStart());
            f2.end = f2.end._getCombined(e2.sourcePosition, e2.getMovedRangeStart());
            if (u2.length === 0) {
              u2.push(f2);
            } else if (u2.length == 1) {
              if (o2.start.isBefore(n2.start) || o2.start.isEqual(n2.start)) {
                u2.unshift(f2);
              } else {
                u2.push(f2);
              }
            } else {
              u2.splice(1, 0, f2);
            }
          }
          if (u2.length === 0) {
            return [new Sm(t2.baseVersion)];
          }
          return lI(u2, a2);
        });
        XO(Zg, rm, (t2, e2, i2) => {
          let n2 = t2.targetPosition.clone();
          if (!t2.targetPosition.isEqual(e2.insertionPosition) || !e2.graveyardPosition || i2.abRelation == "moveTargetAfter") {
            n2 = t2.targetPosition._getTransformedBySplitOperation(e2);
          }
          const o2 = $h._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
          if (o2.end.isEqual(e2.insertionPosition)) {
            if (!e2.graveyardPosition) {
              t2.howMany++;
            }
            t2.targetPosition = n2;
            return [t2];
          }
          if (o2.start.hasSameParentAs(e2.splitPosition) && o2.containsPosition(e2.splitPosition)) {
            let t3 = new $h(e2.splitPosition, o2.end);
            t3 = t3._getTransformedBySplitOperation(e2);
            const i3 = [new $h(o2.start, e2.splitPosition), t3];
            return lI(i3, n2);
          }
          if (t2.targetPosition.isEqual(e2.splitPosition) && i2.abRelation == "insertAtSource") {
            n2 = e2.moveTargetPosition;
          }
          if (t2.targetPosition.isEqual(e2.insertionPosition) && i2.abRelation == "insertBetween") {
            n2 = t2.targetPosition;
          }
          const r2 = o2._getTransformedBySplitOperation(e2);
          const s2 = [r2];
          if (e2.graveyardPosition) {
            const n3 = o2.start.isEqual(e2.graveyardPosition) || o2.containsPosition(e2.graveyardPosition);
            if (t2.howMany > 1 && n3 && !i2.aWasUndone) {
              s2.push($h._createFromPositionAndShift(e2.insertionPosition, 1));
            }
          }
          return lI(s2, n2);
        });
        XO(Zg, om, (t2, e2, i2) => {
          const n2 = $h._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
          if (e2.deletionPosition.hasSameParentAs(t2.sourcePosition) && n2.containsPosition(e2.sourcePosition)) {
            if (t2.type == "remove" && !i2.forceWeakRemove) {
              if (!i2.aWasUndone) {
                const i3 = [];
                let n3 = e2.graveyardPosition.clone();
                let o3 = e2.targetPosition._getTransformedByMergeOperation(e2);
                if (t2.howMany > 1) {
                  i3.push(new Zg(t2.sourcePosition, t2.howMany - 1, t2.targetPosition, 0));
                  n3 = n3._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany - 1);
                  o3 = o3._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany - 1);
                }
                const r3 = e2.deletionPosition._getCombined(t2.sourcePosition, t2.targetPosition);
                const s2 = new Zg(n3, 1, r3, 0);
                const a2 = s2.getMovedRangeStart().path.slice();
                a2.push(0);
                const c2 = new Uh(s2.targetPosition.root, a2);
                o3 = o3._getTransformedByMove(n3, r3, 1);
                const l2 = new Zg(o3, e2.howMany, c2, 0);
                i3.push(s2);
                i3.push(l2);
                return i3;
              }
            } else {
              if (t2.howMany == 1) {
                if (!i2.bWasUndone) {
                  return [new Sm(0)];
                } else {
                  t2.sourcePosition = e2.graveyardPosition.clone();
                  t2.targetPosition = t2.targetPosition._getTransformedByMergeOperation(e2);
                  return [t2];
                }
              }
            }
          }
          const o2 = $h._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
          const r2 = o2._getTransformedByMergeOperation(e2);
          t2.sourcePosition = r2.start;
          t2.howMany = r2.end.offset - r2.start.offset;
          t2.targetPosition = t2.targetPosition._getTransformedByMergeOperation(e2);
          return [t2];
        });
        XO(im, tm, (t2, e2) => {
          t2.position = t2.position._getTransformedByInsertOperation(e2);
          return [t2];
        });
        XO(im, om, (t2, e2) => {
          if (t2.position.isEqual(e2.deletionPosition)) {
            t2.position = e2.graveyardPosition.clone();
            t2.position.stickiness = "toNext";
            return [t2];
          }
          t2.position = t2.position._getTransformedByMergeOperation(e2);
          return [t2];
        });
        XO(im, Zg, (t2, e2) => {
          t2.position = t2.position._getTransformedByMoveOperation(e2);
          return [t2];
        });
        XO(im, im, (t2, e2, i2) => {
          if (t2.position.isEqual(e2.position)) {
            if (i2.aIsStrong) {
              t2.oldName = e2.newName;
            } else {
              return [new Sm(0)];
            }
          }
          return [t2];
        });
        XO(im, rm, (t2, e2) => {
          const i2 = t2.position.path;
          const n2 = e2.splitPosition.getParentPath();
          if (Vs(i2, n2) == "same" && !e2.graveyardPosition) {
            const e3 = new im(t2.position.getShiftedBy(1), t2.oldName, t2.newName, 0);
            return [t2, e3];
          }
          t2.position = t2.position._getTransformedBySplitOperation(e2);
          return [t2];
        });
        XO(nm, nm, (t2, e2, i2) => {
          if (t2.root === e2.root && t2.key === e2.key) {
            if (!i2.aIsStrong || t2.newValue === e2.newValue) {
              return [new Sm(0)];
            } else {
              t2.oldValue = e2.newValue;
            }
          }
          return [t2];
        });
        XO(rm, tm, (t2, e2) => {
          if (t2.splitPosition.hasSameParentAs(e2.position) && t2.splitPosition.offset < e2.position.offset) {
            t2.howMany += e2.howMany;
          }
          t2.splitPosition = t2.splitPosition._getTransformedByInsertOperation(e2);
          t2.insertionPosition = rm.getInsertionPosition(t2.splitPosition);
          return [t2];
        });
        XO(rm, om, (t2, e2, i2) => {
          if (!t2.graveyardPosition && !i2.bWasUndone && t2.splitPosition.hasSameParentAs(e2.sourcePosition)) {
            const i3 = e2.graveyardPosition.path.slice();
            i3.push(0);
            const n2 = new Uh(e2.graveyardPosition.root, i3);
            const o2 = rm.getInsertionPosition(new Uh(e2.graveyardPosition.root, i3));
            const r2 = new rm(n2, 0, null, 0);
            r2.insertionPosition = o2;
            t2.splitPosition = t2.splitPosition._getTransformedByMergeOperation(e2);
            t2.insertionPosition = rm.getInsertionPosition(t2.splitPosition);
            t2.graveyardPosition = r2.insertionPosition.clone();
            t2.graveyardPosition.stickiness = "toNext";
            return [r2, t2];
          }
          if (t2.splitPosition.hasSameParentAs(e2.deletionPosition) && !t2.splitPosition.isAfter(e2.deletionPosition)) {
            t2.howMany--;
          }
          if (t2.splitPosition.hasSameParentAs(e2.targetPosition)) {
            t2.howMany += e2.howMany;
          }
          t2.splitPosition = t2.splitPosition._getTransformedByMergeOperation(e2);
          t2.insertionPosition = rm.getInsertionPosition(t2.splitPosition);
          if (t2.graveyardPosition) {
            t2.graveyardPosition = t2.graveyardPosition._getTransformedByMergeOperation(e2);
          }
          return [t2];
        });
        XO(rm, Zg, (t2, e2, i2) => {
          const n2 = $h._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
          if (t2.graveyardPosition) {
            const o3 = n2.start.isEqual(t2.graveyardPosition) || n2.containsPosition(t2.graveyardPosition);
            if (!i2.bWasUndone && o3) {
              const i3 = t2.splitPosition._getTransformedByMoveOperation(e2);
              const n3 = t2.graveyardPosition._getTransformedByMoveOperation(e2);
              const o4 = n3.path.slice();
              o4.push(0);
              const r2 = new Uh(n3.root, o4);
              const s2 = new Zg(i3, t2.howMany, r2, 0);
              return [s2];
            }
            t2.graveyardPosition = t2.graveyardPosition._getTransformedByMoveOperation(e2);
          }
          if (t2.splitPosition.hasSameParentAs(e2.sourcePosition) && n2.containsPosition(t2.splitPosition)) {
            const i3 = e2.howMany - (t2.splitPosition.offset - e2.sourcePosition.offset);
            t2.howMany -= i3;
            if (t2.splitPosition.hasSameParentAs(e2.targetPosition) && t2.splitPosition.offset < e2.targetPosition.offset) {
              t2.howMany += e2.howMany;
            }
            t2.splitPosition = e2.sourcePosition.clone();
            t2.insertionPosition = rm.getInsertionPosition(t2.splitPosition);
            return [t2];
          }
          const o2 = t2.splitPosition.isEqual(e2.targetPosition);
          if (o2 && (i2.baRelation == "insertAtSource" || i2.abRelation == "splitBefore")) {
            t2.howMany += e2.howMany;
            t2.splitPosition = t2.splitPosition._getTransformedByDeletion(e2.sourcePosition, e2.howMany);
            t2.insertionPosition = rm.getInsertionPosition(t2.splitPosition);
            return [t2];
          }
          if (!e2.sourcePosition.isEqual(e2.targetPosition)) {
            if (t2.splitPosition.hasSameParentAs(e2.sourcePosition) && t2.splitPosition.offset <= e2.sourcePosition.offset) {
              t2.howMany -= e2.howMany;
            }
            if (t2.splitPosition.hasSameParentAs(e2.targetPosition) && t2.splitPosition.offset < e2.targetPosition.offset) {
              t2.howMany += e2.howMany;
            }
          }
          t2.splitPosition.stickiness = "toNone";
          t2.splitPosition = t2.splitPosition._getTransformedByMoveOperation(e2);
          t2.splitPosition.stickiness = "toNext";
          if (t2.graveyardPosition) {
            t2.insertionPosition = t2.insertionPosition._getTransformedByMoveOperation(e2);
          } else {
            t2.insertionPosition = rm.getInsertionPosition(t2.splitPosition);
          }
          return [t2];
        });
        XO(rm, rm, (t2, e2, i2) => {
          if (t2.splitPosition.isEqual(e2.splitPosition)) {
            if (!t2.graveyardPosition && !e2.graveyardPosition) {
              return [new Sm(0)];
            }
            if (t2.graveyardPosition && e2.graveyardPosition && t2.graveyardPosition.isEqual(e2.graveyardPosition)) {
              return [new Sm(0)];
            }
            if (i2.abRelation == "splitBefore") {
              t2.howMany = 0;
              t2.graveyardPosition = t2.graveyardPosition._getTransformedBySplitOperation(e2);
              return [t2];
            }
          }
          if (t2.graveyardPosition && e2.graveyardPosition && t2.graveyardPosition.isEqual(e2.graveyardPosition)) {
            const n2 = t2.splitPosition.root.rootName == "$graveyard";
            const o2 = e2.splitPosition.root.rootName == "$graveyard";
            const r2 = n2 && !o2;
            const s2 = o2 && !n2;
            const a2 = s2 || !r2 && i2.aIsStrong;
            if (a2) {
              const i3 = [];
              if (e2.howMany) {
                i3.push(new Zg(e2.moveTargetPosition, e2.howMany, e2.splitPosition, 0));
              }
              if (t2.howMany) {
                i3.push(new Zg(t2.splitPosition, t2.howMany, t2.moveTargetPosition, 0));
              }
              return i3;
            } else {
              return [new Sm(0)];
            }
          }
          if (t2.graveyardPosition) {
            t2.graveyardPosition = t2.graveyardPosition._getTransformedBySplitOperation(e2);
          }
          if (t2.splitPosition.isEqual(e2.insertionPosition) && i2.abRelation == "splitBefore") {
            t2.howMany++;
            return [t2];
          }
          if (e2.splitPosition.isEqual(t2.insertionPosition) && i2.baRelation == "splitBefore") {
            const i3 = e2.insertionPosition.path.slice();
            i3.push(0);
            const n2 = new Uh(e2.insertionPosition.root, i3);
            const o2 = new Zg(t2.insertionPosition, 1, n2, 0);
            return [t2, o2];
          }
          if (t2.splitPosition.hasSameParentAs(e2.splitPosition) && t2.splitPosition.offset < e2.splitPosition.offset) {
            t2.howMany -= e2.howMany;
          }
          t2.splitPosition = t2.splitPosition._getTransformedBySplitOperation(e2);
          t2.insertionPosition = rm.getInsertionPosition(t2.splitPosition);
          return [t2];
        });
        function cI(t2, e2) {
          return t2.targetPosition._getTransformedByDeletion(e2.sourcePosition, e2.howMany) === null;
        }
        function lI(t2, e2) {
          const i2 = [];
          for (let n2 = 0; n2 < t2.length; n2++) {
            const o2 = t2[n2];
            const r2 = new Zg(o2.start, o2.end.offset - o2.start.offset, e2, 0);
            i2.push(r2);
            for (let e3 = n2 + 1; e3 < t2.length; e3++) {
              t2[e3] = t2[e3]._getTransformedByMove(r2.sourcePosition, r2.targetPosition, r2.howMany)[0];
            }
            e2 = e2._getTransformedByMove(r2.sourcePosition, r2.targetPosition, r2.howMany);
          }
          return i2;
        }
        class dI extends jw {
          constructor(t2) {
            super(t2);
            this._stack = [];
            this._createdBatches = new WeakSet();
            this.refresh();
          }
          refresh() {
            this.isEnabled = this._stack.length > 0;
          }
          addBatch(t2) {
            const e2 = this.editor.model.document.selection;
            const i2 = {ranges: e2.hasOwnRange ? Array.from(e2.getRanges()) : [], isBackward: e2.isBackward};
            this._stack.push({batch: t2, selection: i2});
            this.refresh();
          }
          clearStack() {
            this._stack = [];
            this.refresh();
          }
          _restoreSelection(t2, e2, i2) {
            const n2 = this.editor.model;
            const o2 = n2.document;
            const r2 = [];
            for (const e3 of t2) {
              const t3 = uI(e3, i2);
              const n3 = t3.find((t4) => t4.start.root != o2.graveyard);
              if (n3) {
                r2.push(n3);
              }
            }
            if (r2.length) {
              n2.change((t3) => {
                t3.setSelection(r2, {backward: e2});
              });
            }
          }
          _undo(t2, e2) {
            const i2 = this.editor.model;
            const n2 = i2.document;
            this._createdBatches.add(e2);
            const o2 = t2.operations.slice().filter((t3) => t3.isDocumentOperation);
            o2.reverse();
            for (const t3 of o2) {
              const o3 = t3.baseVersion + 1;
              const r2 = Array.from(n2.history.getOperations(o3));
              const s2 = iI([t3.getReversed()], r2, {
                useRelations: true,
                document: this.editor.model.document,
                padWithNoOps: false,
                forceWeakRemove: true
              });
              const a2 = s2.operationsA;
              for (const o4 of a2) {
                e2.addOperation(o4);
                i2.applyOperation(o4);
                n2.history.setOperationAsUndone(t3, o4);
              }
            }
          }
        }
        function uI(t2, e2) {
          const i2 = t2.getTransformedByOperations(e2);
          i2.sort((t3, e3) => t3.start.isBefore(e3.start) ? -1 : 1);
          for (let t3 = 1; t3 < i2.length; t3++) {
            const e3 = i2[t3 - 1];
            const n2 = i2[t3];
            if (e3.end.isTouching(n2.start)) {
              e3.end = n2.end;
              i2.splice(t3, 1);
              t3--;
            }
          }
          return i2;
        }
        class hI extends dI {
          execute(t2 = null) {
            const e2 = t2 ? this._stack.findIndex((e3) => e3.batch == t2) : this._stack.length - 1;
            const i2 = this._stack.splice(e2, 1)[0];
            const n2 = this.editor.model.createBatch("transparent");
            this.editor.model.enqueueChange(n2, () => {
              this._undo(i2.batch, n2);
              const t3 = this.editor.model.document.history.getOperations(i2.batch.baseVersion);
              this._restoreSelection(i2.selection.ranges, i2.selection.isBackward, t3);
              this.fire("revert", i2.batch, n2);
            });
            this.refresh();
          }
        }
        class fI extends dI {
          execute() {
            const t2 = this._stack.pop();
            const e2 = this.editor.model.createBatch("transparent");
            this.editor.model.enqueueChange(e2, () => {
              const i2 = t2.batch.operations[t2.batch.operations.length - 1];
              const n2 = i2.baseVersion + 1;
              const o2 = this.editor.model.document.history.getOperations(n2);
              this._restoreSelection(t2.selection.ranges, t2.selection.isBackward, o2);
              this._undo(t2.batch, e2);
            });
            this.refresh();
          }
        }
        class gI extends mp {
          static get pluginName() {
            return "UndoEditing";
          }
          constructor(t2) {
            super(t2);
            this._batchRegistry = new WeakSet();
          }
          init() {
            const t2 = this.editor;
            this._undoCommand = new hI(t2);
            this._redoCommand = new fI(t2);
            t2.commands.add("undo", this._undoCommand);
            t2.commands.add("redo", this._redoCommand);
            this.listenTo(t2.model, "applyOperation", (t3, e2) => {
              const i2 = e2[0];
              if (!i2.isDocumentOperation) {
                return;
              }
              const n2 = i2.batch;
              const o2 = this._redoCommand._createdBatches.has(n2);
              const r2 = this._undoCommand._createdBatches.has(n2);
              const s2 = this._batchRegistry.has(n2);
              if (s2 || n2.type == "transparent" && !o2 && !r2) {
                return;
              } else {
                if (o2) {
                  this._undoCommand.addBatch(n2);
                } else if (!r2) {
                  this._undoCommand.addBatch(n2);
                  this._redoCommand.clearStack();
                }
              }
              this._batchRegistry.add(n2);
            }, {priority: "highest"});
            this.listenTo(this._undoCommand, "revert", (t3, e2, i2) => {
              this._redoCommand.addBatch(i2);
            });
            t2.keystrokes.set("CTRL+Z", "undo");
            t2.keystrokes.set("CTRL+Y", "redo");
            t2.keystrokes.set("CTRL+SHIFT+Z", "redo");
          }
        }
        var mI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.042 9.367l2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
        var pI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M14.958 9.367l-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
        class bI extends mp {
          init() {
            const t2 = this.editor;
            const e2 = t2.locale;
            const i2 = t2.t;
            const n2 = e2.uiLanguageDirection == "ltr" ? mI : pI;
            const o2 = e2.uiLanguageDirection == "ltr" ? pI : mI;
            this._addButton("undo", i2("mo"), "CTRL+Z", n2);
            this._addButton("redo", i2("mp"), "CTRL+Y", o2);
          }
          _addButton(t2, e2, i2, n2) {
            const o2 = this.editor;
            o2.ui.componentFactory.add(t2, (r2) => {
              const s2 = o2.commands.get(t2);
              const a2 = new hb(r2);
              a2.set({label: e2, icon: n2, keystroke: i2, tooltip: true});
              a2.bind("isEnabled").to(s2, "isEnabled");
              this.listenTo(a2, "execute", () => {
                o2.execute(t2);
                o2.editing.view.focus();
              });
              return a2;
            });
          }
        }
        class wI extends mp {
          static get requires() {
            return [gI, bI];
          }
          static get pluginName() {
            return "Undo";
          }
        }
        class kI extends mp {
          static get requires() {
            return [Rx, qO, YO, cP, wI];
          }
          static get pluginName() {
            return "Essentials";
          }
        }
        class _I extends Fw {
        }
        _I.builtinPlugins = [rk, uk, vk, Sk, r_, p_, A_, R_, W_, bv, cy, fy, Ry, Ky, zx, Wx, vC, PC, tT, zT, WT, wP, CP, vP, kP, yP, _P, xP, RP, BP, HP, DE, lO, dO, IO, LO, kI, V_];
      }])["default"];
    });
  });

  // src/pdf-editor/CkEditor5.js
  var require_CkEditor5 = __commonJS((exports, module) => {
    var BalloonEditor = require_ckeditor();
    module.exports = {
      removeTextEditor: function remove(el) {
      },
      initTextEditor: function(el) {
        ckEditor(el);
      }
    };
    function ckEditor(el) {
      if (!el || el.classList.contains("initialized"))
        return;
      el.classList.add("initialized");
      BalloonEditor.create(el, {
        toolbar: {
          items: [
            "undo",
            "redo",
            "|",
            "bold",
            "italic",
            "underline",
            "strikethrough",
            "subscript",
            "superscript",
            "|",
            "alignment",
            "indent",
            "outdent",
            "fontFamily",
            "fontSize",
            "fontBackgroundColor",
            "fontColor",
            "|",
            "specialCharacters",
            "horizontalLine",
            "link"
          ]
        },
        language: "ru",
        image: {
          toolbar: [
            "imageUpload",
            "imageStyle:alignLeft",
            "imageStyle:full",
            "imageStyle:alignRight"
          ],
          styles: [
            "full",
            "alignLeft",
            "alignRight"
          ]
        },
        table: {
          contentToolbar: [
            "tableColumn",
            "tableRow",
            "mergeTableCells",
            "tableCellProperties",
            "tableProperties"
          ]
        },
        licenseKey: ""
      }).then((editor) => {
        el.editor = editor;
      });
    }
  });

  // src/pdf-editor/ForItextFormatter.js
  var require_ForItextFormatter = __commonJS((exports, module) => {
    var pageStyles2 = require_page_styles();
    function fixPageBreaks_by_AStanislavsky(tmp) {
      let s = tmp.querySelector(".page.container").style;
      s.height = "200px";
      s.display = "table-cell";
    }
    module.exports = function(html) {
      let tmp = tmpElement(html);
      let props = {};
      let page = tmp.querySelector(".page");
      props.left = page.getAttribute("pdf-editor-page-pad-left") || 5;
      props.top = page.getAttribute("pdf-editor-page-pad-top") || 5;
      props.right = page.getAttribute("pdf-editor-page-pad-right") || 5;
      props.bottom = page.getAttribute("pdf-editor-page-pad-bottom") || 5;
      props.betweenElements = page.getAttribute("pdf-editor-page-pad-between-elements") || 5;
      props.betweenBlocks = page.getAttribute("pdf-editor-page-pad-between-blocks") || 5;
      fixPageBreaks_by_AStanislavsky(tmp);
      fixFlex(tmp, props);
      fixImagesAlign(tmp);
      fixTablesAlign(tmp);
      pageBreaks(tmp);
      return `
        <html>
            <head>${style(props)}</head>
            <body>${tmp.innerHTML}</body>
        </html>
    `;
    };
    function style(props) {
      return `
        ${pageStyles2}
        <style>
            figure > img {
                display: block;
                margin: 0 auto;
                max-width: 100%;
                min-width: 50px;
            }
            figure.image.image_resized img {
                width: 100%;
            }
           .image-style-align-left {
                float: left;
            }
           .image-style-align-right {
                float: right;
            }
            @page {
                margin-top: ${props.top}mm;
                margin-left: ${props.left}mm;
                margin-bottom: ${props.bottom}mm;
                margin-right: ${props.right}mm;
            }
        </style>
    `;
    }
    function pageBreaks(tmp) {
      tmp.querySelectorAll(".page-break").forEach((el) => {
        el.innerHTML = "";
        el.classList.remove("page-break");
      });
    }
    function fixFlex(el, props) {
      el.querySelectorAll(".row").forEach((row) => {
        let columns = row.querySelectorAll(".col-xs");
        let spacesCount = columns.length - 1;
        let spaceAvailable = 207 - props.left - props.right - props.betweenElements * spacesCount;
        let cellWidth = spaceAvailable / columns.length;
        columns.forEach((col, i) => {
          let s = col.style;
          s.display = "inline-block";
          s.float = "left";
          !i && (s.clear = "both");
          s.verticalAlign = "top";
          let w = cellWidth;
          if (i !== spacesCount) {
            s.paddingRight = `${props.betweenElements}mm`;
          }
          s.width = w + "mm";
          s.marginBottom = `${props.betweenBlocks}mm`;
        });
      });
    }
    function fixImagesAlign(el) {
      el.querySelectorAll("figure.image").forEach((imgBlock) => {
        let centerAlign = !imgBlock.classList.contains("image-style-align-left") && !imgBlock.classList.contains("image-style-align-right");
        if (centerAlign)
          imgBlock.parentNode.style.textAlign = "center";
      });
    }
    function fixTablesAlign(el) {
      el.querySelectorAll("figure.table").forEach((tableBlock) => {
        let centerAlign = !tableBlock.style.float;
        if (!centerAlign)
          return;
        tableBlock.parentNode.style.textAlign = "center";
        tableBlock.style.display = "inline-block";
      });
    }
    function tmpElement(html) {
      let tmp = document.createElement("div");
      tmp.innerHTML = html;
      return tmp;
    }
  });

  // src/pdf-editor/TemplatesFactory.js
  var require_TemplatesFactory = __commonJS((exports, module) => {
    var TemplatesFactory2 = class {
      createBlocks() {
        let row = `<div class='dropzone origin row'></div>`;
        return this.createTemplate(row) + this.createTemplate(this.pageBreakBlock());
      }
      createTemplate(content, col) {
        return `<div class='template ${col ? "col-xs" : ""}'>${content}</div>`;
      }
      imgBlock() {
        let svg = `<svg preserveAspectRatio='xMidYMid meet' xmlns='http://www.w3.org/2000/svg' 
                            width='100px' height='100px' viewbox='0 0 100 100'>
                          <path stroke='black' fill='none' 
                                d='M10,90v-20l30,-30l15,15l35,-35v70z M5,5h90v90h-90z M30,10a10,10,0,1,0,0.001,0z'></path>
                        </svg>`;
        return `<img draggable="false" class="img" width="100px" height="100px"  src="data:image/svg+xml;base64,${btoa(svg)}" >`;
      }
      textBlock() {
        return `<span>
                    \u0415\u0441\u043B\u0438 \u0443 \u043C\u0435\u043D\u044F \u043C\u043D\u043E\u0433\u043E \u041A\u0426 \u0435\u0441\u0442\u044C, \u044F \u0438\u043C\u0435\u044E \u043F\u0440\u0430\u0432\u043E \u043D\u043E\u0441\u0438\u0442\u044C \u043C\u0430\u043B\u0438\u043D\u043E\u0432\u044B\u0435 \u0448\u0442\u0430\u043D\u044B, 
                    \u0438 \u043F\u0435\u0440\u0435\u0434\u043E \u043C\u043D\u043E\u0439 \u0438 \u043F\u0430\u0446\u0430\u043A \u0434\u043E\u043B\u0436\u0435\u043D 2 \u0440\u0430\u0437\u0430 \u043F\u0440\u0438\u0441\u0435\u0434\u0430\u0442\u044C, \u0438 \u0447\u0430\u0442\u043B\u0430\u043D\u0438\u043D \u043A\u0443 \u0434\u0435\u043B\u0430\u0442\u044C, 
                    \u0438 \u044D\u0446\u0438\u043B\u043E\u043F \u043C\u0435\u043D\u044F \u043D\u0435 \u0438\u043C\u0435\u0435\u0442 \u043F\u0440\u0430\u0432\u0430 \u0431\u0438\u0442\u044C \u043F\u043E \u043D\u043E\u0447\u0430\u043C, \u043D\u0438\u043A\u043E\u0433\u0434\u0430!
                </span>`;
      }
      tableBlock() {
        let t = this.td();
        t += t + t + t;
        t = `<tr>${t}</tr>`;
        t += t + t;
        return `<table style="border: 1.5px solid"><tbody>${t}</tbody></table>`;
      }
      td() {
        return `<td style="border: 1.5px solid"></td>`;
      }
      headerBlock() {
        return `<p style="text-align:center;"><span class="text-huge"><strong>\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A</strong></span></p>`;
      }
      pageBreakBlock() {
        return `<div class="page-break" style="page-break-after: always">\u0440\u0430\u0437\u0440\u044B\u0432 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B</div>`;
      }
      videoBlock() {
        let svg = `<svg preserveAspectRatio='xMidYMid meet' xmlns='http://www.w3.org/2000/svg' 
                            width='120px' height='100px' viewbox='0 0 120 100'>
                            <g stroke='black' fill='none'>
                              <rect x="1" y="1" rx="10" width="118" height="98"></rect>
                              <path d="M70,50,l-15,-10v20z"></path>
                            </g>      
                        </svg>`;
        return `<img draggable="false" class="img" width="120px" height="100px"  src="data:image/svg+xml;base64,${btoa(svg)}" >`;
      }
      createElements(properties) {
        let allBlocks = [
          this.headerBlock,
          this.textBlock,
          this.imgBlock,
          this.tableBlock
        ];
        if (properties.videoBlock) {
          allBlocks.push(this.videoBlock);
        }
        return allBlocks.map((fn) => {
          let content = `<div class="${fn.name} add_editor_here">${fn.call(this)}</div>`;
          return this.createTemplate(content, true);
        }).join("");
      }
    };
    module.exports = TemplatesFactory2;
  });

  // src/pdf-editor/pdf-editor.js
  require_();
  require_2();
  var ver = require_package().version;
  var dnd = require_dnd();
  var htmlTemplate = require_html_template();
  var TextEditor = require_CkEditor5();
  var blocks = require_blocks();
  var svgOverlay = require_svgOverlay();
  var documentCleaner = require_documentCleaner();
  var forItextFormatter = require_ForItextFormatter();
  var mouseoverButtons = require_mouseoverButtons();
  var pageStyles = require_page_styles();
  var TemplatesFactory = require_TemplatesFactory();
  var pageProperties = require_pageProperties();
  var templatesFactory = new TemplatesFactory();
  var PdfEditor = class {
    constructor(properties) {
      this.properties = properties || {};
      this.properties.blockProperties = this.properties.blockProperties || {};
      this.properties.buttonsSize = this.properties.buttonsSize || 25;
      this.initPdfEditor();
      this.writeVersion();
      dnd.initDnD(this);
      this.initCollapsePanels();
      this.initClearBlockSelectionOnClickInMilkListener();
      blocks.initBlocks(this);
      svgOverlay.initSvgOverlay(this);
      addEventListener("mouseup", () => {
        this.manageHoverState();
        this.removeEmptyRows();
        this.addSingleRowToEmptyBlocks();
      });
      pageProperties.initPageProperties(this);
      console.log("pdf-editor: " + ver);
    }
    removeEmptyRows() {
      setTimeout(() => {
        let allBlocks = this.targetElement.querySelectorAll(".pdf-editor .page > .template");
        allBlocks.forEach((b) => {
          if (!b.firstChild)
            return;
          this.clearNotNeededRows(b.firstChild);
          if (b.childElementCount === 1)
            b.firstChild.classList && b.firstChild.classList.remove("empty-drop-zone");
          this.manageExtraRows(b.firstChild);
          this.markEmptyRows(b.firstChild);
        });
      });
    }
    initPdfEditor() {
      let targetElement = this.properties.target;
      if (typeof targetElement === "string")
        targetElement = document.querySelector(targetElement);
      this.targetElement = targetElement;
      targetElement.innerHTML = htmlTemplate(this.properties);
      targetElement.querySelector(".sidePanel #blocks").innerHTML = templatesFactory.createBlocks();
      targetElement.querySelector(".sidePanel #elements").innerHTML = templatesFactory.createElements(this.properties);
      targetElement.addEventListener("mousemove", (e) => mouseoverButtons.manage(e, this));
      let importBtn = targetElement.querySelector("#block_attach_button");
      importBtn && importBtn.addEventListener("click", () => this.openImportWindowFunc());
    }
    writeVersion() {
      let page = this.targetElement.querySelector(".page");
      if (!page.getAttribute("created-ver"))
        page.setAttribute("created-ver", ver);
      page.setAttribute("last-edited-ver", ver);
    }
    initClearBlockSelectionOnClickInMilkListener() {
      this.targetElement.querySelector(".content").addEventListener("click", (e) => {
        let clear = ["content", "page"].find((c) => e.target.classList.contains(c));
        clear |= e.target.querySelector(".page-break");
        if (clear)
          this.clickOnBlock(null);
      });
    }
    initCollapsePanels() {
      this.targetElement.querySelectorAll(".groupName").forEach((groupName) => {
        groupName.addEventListener("click", () => {
          groupName.classList.toggle("collapsed");
        });
      });
    }
    manageHoverState(target) {
      if (target === this.lastHover)
        return;
      this.lastHover = target;
      this.targetElement.querySelectorAll(".page.container > .template").forEach((tpl) => tpl.classList.remove("hover-state"));
      if (!target)
        return;
      target.classList.add("hover-state");
    }
    addSingleRowToEmptyBlocks() {
      setTimeout(() => {
        this.targetElement.querySelectorAll(".page.container > .template").forEach((tpl) => {
          if (!tpl.innerHTML.length) {
            tpl.append(this.newDropZone());
          }
        });
      }, 10);
    }
    markEmptyRows(target) {
      if (!target)
        return;
      target.parentNode.querySelectorAll(".dropzone").forEach((dz) => {
        let single = dz.parentNode.querySelectorAll(".dropzone").length === 1;
        let empty = dz.innerHTML.trim() === "";
        dz.classList.toggle("empty-drop-zone", empty && !single);
      });
    }
    manageExtraRows(target) {
      if (!target)
        return;
      try {
        let first = [...target.parentNode.querySelectorAll(".dropzone")].shift();
        if (first && first.innerHTML.trim() !== "") {
          target.parentNode.insertBefore(this.newDropZone(), first);
        }
        let last = [...target.parentNode.querySelectorAll(".dropzone")].pop();
        if (last && last.innerHTML.trim() !== "") {
          target.parentNode.append(this.newDropZone());
        }
      } catch (e) {
        console.error(e);
      }
    }
    clearNotNeededRows(target) {
      if (!target)
        return;
      try {
        if (target.parentNode.childNodes.length === 1 && target.innerHTML === "")
          return;
        let dropZones = target.parentNode.querySelectorAll(".dropzone");
        for (let i = 0; i < dropZones.length; i++) {
          if (dropZones.length > 1 && dropZones[i].innerHTML.trim() === "") {
            dropZones[i].remove();
            dnd.removeElement(dropZones[i]);
          }
        }
      } catch (e) {
        console.error(e);
      }
    }
    isModified() {
      return this.initial !== this.getDocument();
    }
    newDropZone() {
      let dz = document.createElement("div");
      dz.className = "dropzone row";
      this.initDz(dz);
      return dz;
    }
    initEditor(el) {
      this.removeBySel(".dz-buttons, .template-buttons");
      TextEditor.initTextEditor(el);
    }
    initDz(dropZone) {
      dnd.pushElement(dropZone);
      dropZone.classList.remove("origin");
    }
    removeBySel(sel) {
      this.targetElement.querySelectorAll(sel).forEach((e) => e.remove());
    }
    clickOnBlock(el) {
      this.selectedBlock = el;
      blocks.handleClick(el);
    }
    getRawPage() {
      return this.targetElement.querySelector(".page").outerHTML;
    }
    cleanDocument(text) {
      return documentCleaner.clean(text).innerHTML;
    }
    getDocument() {
      return this.cleanDocument(this.getRawPage());
    }
    forItext(html) {
      return forItextFormatter(html || this.getDocument());
    }
    loadDocument(data) {
      if (!data)
        return;
      this.initial = data;
      let content = this.targetElement.querySelector(".content");
      content.innerHTML = pageStyles + data;
      this.initBlocksInDocument(content);
      dnd.pushElement(content.querySelector(".page"));
      pageProperties.initPageProperties(this);
    }
    initBlocksInDocument(content) {
      content.querySelectorAll(".headerBlock, .textBlock, .imgBlock, .tableBlock, .videoBlock").forEach((el) => {
        el.classList.add("add_editor_here");
        el.classList.add("ck-editor__editable_inline");
      });
      let templates = content.querySelectorAll(".template");
      templates.forEach((tpl) => blocks.initTemplate(tpl, ".dropzone"));
      content.querySelectorAll(".template:not(.col-xs)").forEach((block) => {
        if (!block.firstChild)
          return;
        this.manageExtraRows(block.firstChild);
        this.markEmptyRows(block.firstChild);
      });
    }
    getPageStyles() {
      return pageStyles;
    }
    setOpenImportWindowFunc(openImportWindowFunc) {
      this.openImportWindowFunc = openImportWindowFunc;
    }
    importBlockData(blockData) {
      if (!this.selectedBlock || !this.selectedBlock.parentNode)
        return console.log("no selected block found");
      let tmp = document.createElement("div");
      tmp.innerHTML = blockData;
      let importingBlock = tmp.querySelector("div");
      if (importingBlock) {
        this.selectedBlock.innerHTML = importingBlock.innerHTML;
        this.initBlocksInDocument(this.selectedBlock);
      }
    }
  };
  window.PdfEditor = PdfEditor;
})();
(function() {
    var s = document.createElement('style');
    s.innerHTML = `/* src/pdf-editor/pdf-editor.css */
.pdf-editor.wrapper {
  display: flex;
  flex-direction: row;
  --bg-col: #444;
}
.pdf-editor .content {
  flex-grow: 1;
  background: var(--bg-col);
  overflow-y: scroll;
  padding: 50px 20px 50vh 20px;
  text-align: center;
}
.pdf-editor .page {
  box-shadow: 1px 1px 4px 1px #2226;
}
.pdf-editor .sidePanel,
.pdf-editor .propsPanel {
  display: flex;
  width: 360px;
  background: #333;
  flex-direction: column;
  border-left: 1px solid gray;
  border-right: 1px solid gray;
  box-sizing: border-box;
}
.pdf-editor .templates {
  padding: 10px 25px;
}
.pdf-editor .templates .template {
  margin-bottom: 5px;
}
.pdf-editor .buttons {
  padding: 5px 5px 0 5px;
}
.pdf-editor .buttons button {
  line-height: 30px;
  border-radius: 11px;
}
.pdf-editor .template {
  transition: 0.2s;
}
.pdf-editor #elements .template {
  transition: 0.2s;
  background: #eee;
}
.pdf-editor .sidePanel .dropzone {
  background-color: #eee;
  min-height: 35px;
}
.pdf-editor .sidePanel .template:hover {
  transform: scale(1.1);
  cursor: move;
}
.dropzone {
  background-color: #0001;
}
.handle {
  cursor: move;
}
.copy,
.up,
.del,
.down {
  cursor: pointer;
}
.handle,
.copy,
.del,
.up,
.down {
  background-color: rgba(249, 249, 249, 0.4);
  display: inline-block;
  border-radius: 15%;
  transition: 0.2s;
  margin: 2px;
}
.handle:hover,
.copy:hover,
.del:hover,
.up:hover,
.down:hover {
  background-color: rgba(254, 177, 62, 0.8);
}
.dz-buttons,
.template-buttons {
  opacity: 0;
  position: relative;
  overflow: visible;
  width: 0px;
  height: 0px;
  line-height: 0;
}
.template-buttons {
  transform: translate(-40px, 0);
}
.template-buttons > div {
  width: 40px;
  height: 60px;
}
div.dz-buttons {
  margin-left: 700px;
}
.svg-overlay {
  position: fixed;
  top: 0;
  left: 0;
  pointer-events: none;
}
table td {
  min-width: 32px;
  height: 20px;
  border: 1px solid black;
  padding: 6.4px;
}
.tableBlock {
  padding-top: 3px;
  padding-bottom: 3px;
}
.textBlock,
.headerBlock,
.imgBlock,
.videoBlock,
.tableBlock {
  padding: 0 9.6px;
  border: 1px solid transparent;
}
.tableBlock figure {
  margin: 1em auto;
}
.sub-label {
  font-size: 16px;
  color: #999;
  font-family: Arial, sans-serif;
}
.sub-label:first-child {
  padding-top: 5px;
}
.sidePanel #elements > div.template {
  box-shadow: 0 0 0 1px gray;
  text-align: center;
}
div.videoBlock:not(.ck) figure.image,
div.imgBlock:not(.ck) figure.image {
  margin: 15px 0px 10px 0px;
}
div:not(#elements) div.videoBlock:not(.ck) > img,
div:not(#elements) div.imgBlock:not(.ck) > img {
  margin: 15px 5px 10px 5px;
}
div.videoBlock:not(.ck),
div.imgBlock:not(.ck) {
  text-align: center;
}
div.videoBlock:not(.ck) figure.image-style-align-left,
div.imgBlock:not(.ck) figure.image-style-align-left {
  text-align: left;
}
div.videoBlock:not(.ck) figure.image-style-align-right,
div.imgBlock:not(.ck) figure.image-style-align-right {
  text-align: right;
}
.sidePanel #elements table {
  margin-top: 5px;
  margin-bottom: 5px;
}
.sidePanel #elements img {
  margin-bottom: -4px;
}
div.template table {
  border-collapse: collapse;
}
.sidePanel textarea {
  width: 333px;
  height: 84px;
}
.sidePanel button,
.sidePanel input[type=text] {
  height: 28px;
  width: 337px;
}
.sidePanel textarea,
.sidePanel input[type=text] {
  border-radius: 4px;
  background: #444;
  color: white;
  border: 1px solid #999;
  margin-bottom: 5px;
}
.groupName {
  width: 360px;
  padding-left: 15px;
  border-top: 1px solid gray;
  border-bottom: 1px solid gray;
  font-size: 20px;
  line-height: 30px;
  font-family: Arial, sans-serif;
  color: #999;
  box-sizing: border-box;
  cursor: pointer;
}
.groupName + div {
  transition: 300ms;
  max-height: 100vh;
  overflow: hidden;
}
.groupName.collapsed + div {
  max-height: 0;
  min-height: 0 !important;
  padding-top: 0 !important;
  padding-bottom: 0 !important;
  overflow: hidden;
}
.groupName:after {
  content: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30'><circle fill='%23777' cx='15' cy='15' r='10' /><polyline stroke-width='3' points='10 13 15 18 20 13' fill='none' stroke='%23444'/></svg>");
  transition: 300ms;
  float: right;
  margin-right: 10px;
  display: inline-block;
  line-height: 0px;
}
.groupName.collapsed:after {
  transform: rotate(90deg) scale(-1, -1);
}
.sidePanel table {
}
figure.table,
.tableBlock {
  text-align: center;
}
.tableBlock > table {
  margin: 14px;
}
table {
  display: inline-block;
  border: 0 !important;
}
.sidePanel tr:nth-child(2) td:nth-child(3) {
  background: lightgray;
}
.pdf-editor .page {
  width: 800px;
}
.ckeditor-uploading {
  animation: ckeditor-uploading-animation 1s infinite linear;
  background-image: linear-gradient(to left, steelblue, steelblue 49px, #0000 50px, #0000 100px);
  background-size: 100px 5px;
  background-repeat: repeat-x;
}
.ckeditor-uploading-complete {
  background-color: #5a7e53;
}
.ckeditor-uploading-error {
  background-color: #875a5a;
}
@keyframes ckeditor-uploading-animation {
  0% {
    background-position: 0 calc(100% - 0.1px);
  }
  100% {
    background-position: 100px calc(100% - 0.1px);
  }
}

/* dependencies/flexboxgrid/flexboxgrid.min.css */
.container,
.container-fluid {
  margin-right: auto;
  margin-left: auto;
}
.container-fluid {
  padding-right: 2rem;
  padding-left: 2rem;
}
.row {
  box-sizing: border-box;
  display: -webkit-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-flex: 0;
  -ms-flex: 0 1 auto;
  flex: 0 1 auto;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: normal;
  -ms-flex-direction: row;
  flex-direction: row;
  -ms-flex-wrap: wrap;
  flex-wrap: wrap;
  margin-right: -.5rem;
  margin-left: -.5rem;
}
.row.reverse {
  -webkit-box-orient: horizontal;
  -webkit-box-direction: reverse;
  -ms-flex-direction: row-reverse;
  flex-direction: row-reverse;
}
.col.reverse {
  -webkit-box-orient: vertical;
  -webkit-box-direction: reverse;
  -ms-flex-direction: column-reverse;
  flex-direction: column-reverse;
}
.col-xs,
.col-xs-1,
.col-xs-10,
.col-xs-11,
.col-xs-12,
.col-xs-2,
.col-xs-3,
.col-xs-4,
.col-xs-5,
.col-xs-6,
.col-xs-7,
.col-xs-8,
.col-xs-9,
.col-xs-offset-0,
.col-xs-offset-1,
.col-xs-offset-10,
.col-xs-offset-11,
.col-xs-offset-12,
.col-xs-offset-2,
.col-xs-offset-3,
.col-xs-offset-4,
.col-xs-offset-5,
.col-xs-offset-6,
.col-xs-offset-7,
.col-xs-offset-8,
.col-xs-offset-9 {
  box-sizing: border-box;
  -webkit-box-flex: 0;
  -ms-flex: 0 0 auto;
  flex: 0 0 auto;
  padding-right: .5rem;
  padding-left: .5rem;
}
.col-xs {
  -webkit-box-flex: 1;
  -ms-flex-positive: 1;
  flex-grow: 1;
  -ms-flex-preferred-size: 0;
  flex-basis: 0;
  max-width: 100%;
}
.col-xs-1 {
  -ms-flex-preferred-size: 8.33333333%;
  flex-basis: 8.33333333%;
  max-width: 8.33333333%;
}
.col-xs-2 {
  -ms-flex-preferred-size: 16.66666667%;
  flex-basis: 16.66666667%;
  max-width: 16.66666667%;
}
.col-xs-3 {
  -ms-flex-preferred-size: 25%;
  flex-basis: 25%;
  max-width: 25%;
}
.col-xs-4 {
  -ms-flex-preferred-size: 33.33333333%;
  flex-basis: 33.33333333%;
  max-width: 33.33333333%;
}
.col-xs-5 {
  -ms-flex-preferred-size: 41.66666667%;
  flex-basis: 41.66666667%;
  max-width: 41.66666667%;
}
.col-xs-6 {
  -ms-flex-preferred-size: 50%;
  flex-basis: 50%;
  max-width: 50%;
}
.col-xs-7 {
  -ms-flex-preferred-size: 58.33333333%;
  flex-basis: 58.33333333%;
  max-width: 58.33333333%;
}
.col-xs-8 {
  -ms-flex-preferred-size: 66.66666667%;
  flex-basis: 66.66666667%;
  max-width: 66.66666667%;
}
.col-xs-9 {
  -ms-flex-preferred-size: 75%;
  flex-basis: 75%;
  max-width: 75%;
}
.col-xs-10 {
  -ms-flex-preferred-size: 83.33333333%;
  flex-basis: 83.33333333%;
  max-width: 83.33333333%;
}
.col-xs-11 {
  -ms-flex-preferred-size: 91.66666667%;
  flex-basis: 91.66666667%;
  max-width: 91.66666667%;
}
.col-xs-12 {
  -ms-flex-preferred-size: 100%;
  flex-basis: 100%;
  max-width: 100%;
}
.col-xs-offset-0 {
  margin-left: 0;
}
.col-xs-offset-1 {
  margin-left: 8.33333333%;
}
.col-xs-offset-2 {
  margin-left: 16.66666667%;
}
.col-xs-offset-3 {
  margin-left: 25%;
}
.col-xs-offset-4 {
  margin-left: 33.33333333%;
}
.col-xs-offset-5 {
  margin-left: 41.66666667%;
}
.col-xs-offset-6 {
  margin-left: 50%;
}
.col-xs-offset-7 {
  margin-left: 58.33333333%;
}
.col-xs-offset-8 {
  margin-left: 66.66666667%;
}
.col-xs-offset-9 {
  margin-left: 75%;
}
.col-xs-offset-10 {
  margin-left: 83.33333333%;
}
.col-xs-offset-11 {
  margin-left: 91.66666667%;
}
.start-xs {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  justify-content: flex-start;
  text-align: start;
}
.center-xs {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  justify-content: center;
  text-align: center;
}
.end-xs {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  justify-content: flex-end;
  text-align: end;
}
.top-xs {
  -webkit-box-align: start;
  -ms-flex-align: start;
  align-items: flex-start;
}
.middle-xs {
  -webkit-box-align: center;
  -ms-flex-align: center;
  align-items: center;
}
.bottom-xs {
  -webkit-box-align: end;
  -ms-flex-align: end;
  align-items: flex-end;
}
.around-xs {
  -ms-flex-pack: distribute;
  justify-content: space-around;
}
.between-xs {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  justify-content: space-between;
}
.first-xs {
  -webkit-box-ordinal-group: 0;
  -ms-flex-order: -1;
  order: -1;
}
.last-xs {
  -webkit-box-ordinal-group: 2;
  -ms-flex-order: 1;
  order: 1;
}
@media only screen and (min-width:48em) {
  .container {
    width: 49rem;
  }
  .col-sm,
  .col-sm-1,
  .col-sm-10,
  .col-sm-11,
  .col-sm-12,
  .col-sm-2,
  .col-sm-3,
  .col-sm-4,
  .col-sm-5,
  .col-sm-6,
  .col-sm-7,
  .col-sm-8,
  .col-sm-9,
  .col-sm-offset-0,
  .col-sm-offset-1,
  .col-sm-offset-10,
  .col-sm-offset-11,
  .col-sm-offset-12,
  .col-sm-offset-2,
  .col-sm-offset-3,
  .col-sm-offset-4,
  .col-sm-offset-5,
  .col-sm-offset-6,
  .col-sm-offset-7,
  .col-sm-offset-8,
  .col-sm-offset-9 {
    box-sizing: border-box;
    -webkit-box-flex: 0;
    -ms-flex: 0 0 auto;
    flex: 0 0 auto;
    padding-right: .5rem;
    padding-left: .5rem;
  }
  .col-sm {
    -webkit-box-flex: 1;
    -ms-flex-positive: 1;
    flex-grow: 1;
    -ms-flex-preferred-size: 0;
    flex-basis: 0;
    max-width: 100%;
  }
  .col-sm-1 {
    -ms-flex-preferred-size: 8.33333333%;
    flex-basis: 8.33333333%;
    max-width: 8.33333333%;
  }
  .col-sm-2 {
    -ms-flex-preferred-size: 16.66666667%;
    flex-basis: 16.66666667%;
    max-width: 16.66666667%;
  }
  .col-sm-3 {
    -ms-flex-preferred-size: 25%;
    flex-basis: 25%;
    max-width: 25%;
  }
  .col-sm-4 {
    -ms-flex-preferred-size: 33.33333333%;
    flex-basis: 33.33333333%;
    max-width: 33.33333333%;
  }
  .col-sm-5 {
    -ms-flex-preferred-size: 41.66666667%;
    flex-basis: 41.66666667%;
    max-width: 41.66666667%;
  }
  .col-sm-6 {
    -ms-flex-preferred-size: 50%;
    flex-basis: 50%;
    max-width: 50%;
  }
  .col-sm-7 {
    -ms-flex-preferred-size: 58.33333333%;
    flex-basis: 58.33333333%;
    max-width: 58.33333333%;
  }
  .col-sm-8 {
    -ms-flex-preferred-size: 66.66666667%;
    flex-basis: 66.66666667%;
    max-width: 66.66666667%;
  }
  .col-sm-9 {
    -ms-flex-preferred-size: 75%;
    flex-basis: 75%;
    max-width: 75%;
  }
  .col-sm-10 {
    -ms-flex-preferred-size: 83.33333333%;
    flex-basis: 83.33333333%;
    max-width: 83.33333333%;
  }
  .col-sm-11 {
    -ms-flex-preferred-size: 91.66666667%;
    flex-basis: 91.66666667%;
    max-width: 91.66666667%;
  }
  .col-sm-12 {
    -ms-flex-preferred-size: 100%;
    flex-basis: 100%;
    max-width: 100%;
  }
  .col-sm-offset-0 {
    margin-left: 0;
  }
  .col-sm-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-sm-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-sm-offset-3 {
    margin-left: 25%;
  }
  .col-sm-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-sm-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-sm-offset-6 {
    margin-left: 50%;
  }
  .col-sm-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-sm-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-sm-offset-9 {
    margin-left: 75%;
  }
  .col-sm-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-sm-offset-11 {
    margin-left: 91.66666667%;
  }
  .start-sm {
    -webkit-box-pack: start;
    -ms-flex-pack: start;
    justify-content: flex-start;
    text-align: start;
  }
  .center-sm {
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
    text-align: center;
  }
  .end-sm {
    -webkit-box-pack: end;
    -ms-flex-pack: end;
    justify-content: flex-end;
    text-align: end;
  }
  .top-sm {
    -webkit-box-align: start;
    -ms-flex-align: start;
    align-items: flex-start;
  }
  .middle-sm {
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
  }
  .bottom-sm {
    -webkit-box-align: end;
    -ms-flex-align: end;
    align-items: flex-end;
  }
  .around-sm {
    -ms-flex-pack: distribute;
    justify-content: space-around;
  }
  .between-sm {
    -webkit-box-pack: justify;
    -ms-flex-pack: justify;
    justify-content: space-between;
  }
  .first-sm {
    -webkit-box-ordinal-group: 0;
    -ms-flex-order: -1;
    order: -1;
  }
  .last-sm {
    -webkit-box-ordinal-group: 2;
    -ms-flex-order: 1;
    order: 1;
  }
}
@media only screen and (min-width:64em) {
  .container {
    width: 65rem;
  }
  .col-md,
  .col-md-1,
  .col-md-10,
  .col-md-11,
  .col-md-12,
  .col-md-2,
  .col-md-3,
  .col-md-4,
  .col-md-5,
  .col-md-6,
  .col-md-7,
  .col-md-8,
  .col-md-9,
  .col-md-offset-0,
  .col-md-offset-1,
  .col-md-offset-10,
  .col-md-offset-11,
  .col-md-offset-12,
  .col-md-offset-2,
  .col-md-offset-3,
  .col-md-offset-4,
  .col-md-offset-5,
  .col-md-offset-6,
  .col-md-offset-7,
  .col-md-offset-8,
  .col-md-offset-9 {
    box-sizing: border-box;
    -webkit-box-flex: 0;
    -ms-flex: 0 0 auto;
    flex: 0 0 auto;
    padding-right: .5rem;
    padding-left: .5rem;
  }
  .col-md {
    -webkit-box-flex: 1;
    -ms-flex-positive: 1;
    flex-grow: 1;
    -ms-flex-preferred-size: 0;
    flex-basis: 0;
    max-width: 100%;
  }
  .col-md-1 {
    -ms-flex-preferred-size: 8.33333333%;
    flex-basis: 8.33333333%;
    max-width: 8.33333333%;
  }
  .col-md-2 {
    -ms-flex-preferred-size: 16.66666667%;
    flex-basis: 16.66666667%;
    max-width: 16.66666667%;
  }
  .col-md-3 {
    -ms-flex-preferred-size: 25%;
    flex-basis: 25%;
    max-width: 25%;
  }
  .col-md-4 {
    -ms-flex-preferred-size: 33.33333333%;
    flex-basis: 33.33333333%;
    max-width: 33.33333333%;
  }
  .col-md-5 {
    -ms-flex-preferred-size: 41.66666667%;
    flex-basis: 41.66666667%;
    max-width: 41.66666667%;
  }
  .col-md-6 {
    -ms-flex-preferred-size: 50%;
    flex-basis: 50%;
    max-width: 50%;
  }
  .col-md-7 {
    -ms-flex-preferred-size: 58.33333333%;
    flex-basis: 58.33333333%;
    max-width: 58.33333333%;
  }
  .col-md-8 {
    -ms-flex-preferred-size: 66.66666667%;
    flex-basis: 66.66666667%;
    max-width: 66.66666667%;
  }
  .col-md-9 {
    -ms-flex-preferred-size: 75%;
    flex-basis: 75%;
    max-width: 75%;
  }
  .col-md-10 {
    -ms-flex-preferred-size: 83.33333333%;
    flex-basis: 83.33333333%;
    max-width: 83.33333333%;
  }
  .col-md-11 {
    -ms-flex-preferred-size: 91.66666667%;
    flex-basis: 91.66666667%;
    max-width: 91.66666667%;
  }
  .col-md-12 {
    -ms-flex-preferred-size: 100%;
    flex-basis: 100%;
    max-width: 100%;
  }
  .col-md-offset-0 {
    margin-left: 0;
  }
  .col-md-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-md-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-md-offset-3 {
    margin-left: 25%;
  }
  .col-md-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-md-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-md-offset-6 {
    margin-left: 50%;
  }
  .col-md-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-md-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-md-offset-9 {
    margin-left: 75%;
  }
  .col-md-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-md-offset-11 {
    margin-left: 91.66666667%;
  }
  .start-md {
    -webkit-box-pack: start;
    -ms-flex-pack: start;
    justify-content: flex-start;
    text-align: start;
  }
  .center-md {
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
    text-align: center;
  }
  .end-md {
    -webkit-box-pack: end;
    -ms-flex-pack: end;
    justify-content: flex-end;
    text-align: end;
  }
  .top-md {
    -webkit-box-align: start;
    -ms-flex-align: start;
    align-items: flex-start;
  }
  .middle-md {
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
  }
  .bottom-md {
    -webkit-box-align: end;
    -ms-flex-align: end;
    align-items: flex-end;
  }
  .around-md {
    -ms-flex-pack: distribute;
    justify-content: space-around;
  }
  .between-md {
    -webkit-box-pack: justify;
    -ms-flex-pack: justify;
    justify-content: space-between;
  }
  .first-md {
    -webkit-box-ordinal-group: 0;
    -ms-flex-order: -1;
    order: -1;
  }
  .last-md {
    -webkit-box-ordinal-group: 2;
    -ms-flex-order: 1;
    order: 1;
  }
}
@media only screen and (min-width:75em) {
  .container {
    width: 76rem;
  }
  .col-lg,
  .col-lg-1,
  .col-lg-10,
  .col-lg-11,
  .col-lg-12,
  .col-lg-2,
  .col-lg-3,
  .col-lg-4,
  .col-lg-5,
  .col-lg-6,
  .col-lg-7,
  .col-lg-8,
  .col-lg-9,
  .col-lg-offset-0,
  .col-lg-offset-1,
  .col-lg-offset-10,
  .col-lg-offset-11,
  .col-lg-offset-12,
  .col-lg-offset-2,
  .col-lg-offset-3,
  .col-lg-offset-4,
  .col-lg-offset-5,
  .col-lg-offset-6,
  .col-lg-offset-7,
  .col-lg-offset-8,
  .col-lg-offset-9 {
    box-sizing: border-box;
    -webkit-box-flex: 0;
    -ms-flex: 0 0 auto;
    flex: 0 0 auto;
    padding-right: .5rem;
    padding-left: .5rem;
  }
  .col-lg {
    -webkit-box-flex: 1;
    -ms-flex-positive: 1;
    flex-grow: 1;
    -ms-flex-preferred-size: 0;
    flex-basis: 0;
    max-width: 100%;
  }
  .col-lg-1 {
    -ms-flex-preferred-size: 8.33333333%;
    flex-basis: 8.33333333%;
    max-width: 8.33333333%;
  }
  .col-lg-2 {
    -ms-flex-preferred-size: 16.66666667%;
    flex-basis: 16.66666667%;
    max-width: 16.66666667%;
  }
  .col-lg-3 {
    -ms-flex-preferred-size: 25%;
    flex-basis: 25%;
    max-width: 25%;
  }
  .col-lg-4 {
    -ms-flex-preferred-size: 33.33333333%;
    flex-basis: 33.33333333%;
    max-width: 33.33333333%;
  }
  .col-lg-5 {
    -ms-flex-preferred-size: 41.66666667%;
    flex-basis: 41.66666667%;
    max-width: 41.66666667%;
  }
  .col-lg-6 {
    -ms-flex-preferred-size: 50%;
    flex-basis: 50%;
    max-width: 50%;
  }
  .col-lg-7 {
    -ms-flex-preferred-size: 58.33333333%;
    flex-basis: 58.33333333%;
    max-width: 58.33333333%;
  }
  .col-lg-8 {
    -ms-flex-preferred-size: 66.66666667%;
    flex-basis: 66.66666667%;
    max-width: 66.66666667%;
  }
  .col-lg-9 {
    -ms-flex-preferred-size: 75%;
    flex-basis: 75%;
    max-width: 75%;
  }
  .col-lg-10 {
    -ms-flex-preferred-size: 83.33333333%;
    flex-basis: 83.33333333%;
    max-width: 83.33333333%;
  }
  .col-lg-11 {
    -ms-flex-preferred-size: 91.66666667%;
    flex-basis: 91.66666667%;
    max-width: 91.66666667%;
  }
  .col-lg-12 {
    -ms-flex-preferred-size: 100%;
    flex-basis: 100%;
    max-width: 100%;
  }
  .col-lg-offset-0 {
    margin-left: 0;
  }
  .col-lg-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-lg-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-lg-offset-3 {
    margin-left: 25%;
  }
  .col-lg-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-lg-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-lg-offset-6 {
    margin-left: 50%;
  }
  .col-lg-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-lg-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-lg-offset-9 {
    margin-left: 75%;
  }
  .col-lg-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-lg-offset-11 {
    margin-left: 91.66666667%;
  }
  .start-lg {
    -webkit-box-pack: start;
    -ms-flex-pack: start;
    justify-content: flex-start;
    text-align: start;
  }
  .center-lg {
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
    text-align: center;
  }
  .end-lg {
    -webkit-box-pack: end;
    -ms-flex-pack: end;
    justify-content: flex-end;
    text-align: end;
  }
  .top-lg {
    -webkit-box-align: start;
    -ms-flex-align: start;
    align-items: flex-start;
  }
  .middle-lg {
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
  }
  .bottom-lg {
    -webkit-box-align: end;
    -ms-flex-align: end;
    align-items: flex-end;
  }
  .around-lg {
    -ms-flex-pack: distribute;
    justify-content: space-around;
  }
  .between-lg {
    -webkit-box-pack: justify;
    -ms-flex-pack: justify;
    justify-content: space-between;
  }
  .first-lg {
    -webkit-box-ordinal-group: 0;
    -ms-flex-order: -1;
    order: -1;
  }
  .last-lg {
    -webkit-box-ordinal-group: 2;
    -ms-flex-order: 1;
    order: 1;
  }
}

/* node_modules/dragula/dist/dragula.min.css */
.gu-mirror {
  position: fixed !important;
  margin: 0 !important;
  z-index: 9999 !important;
  opacity: .8;
}
.gu-hide {
  display: none !important;
}
.gu-unselectable {
  -webkit-user-select: none !important;
  -moz-user-select: none !important;
  -ms-user-select: none !important;
  user-select: none !important;
}
.gu-transit {
  opacity: .2;
}
`;
    document.body.append(s);
})();